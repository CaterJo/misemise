{"ast":null,"code":"/*!\n * bundle created at \"Thu Jul 11 2019 15:24:35 GMT+0900 (GMT+09:00)\"\n * version: 3.9.0\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"underscore\"), require(\"tui-code-snippet\"), require(\"backbone\"), require(\"jquery\"), require(\"tui-date-picker\"), require(\"tui-pagination\"));else if (typeof define === 'function' && define.amd) define([\"underscore\", \"tui-code-snippet\", \"backbone\", \"jquery\", \"tui-date-picker\", \"tui-pagination\"], factory);else if (typeof exports === 'object') exports[\"Grid\"] = factory(require(\"underscore\"), require(\"tui-code-snippet\"), require(\"backbone\"), require(\"jquery\"), require(\"tui-date-picker\"), require(\"tui-pagination\"));else root[\"tui\"] = root[\"tui\"] || {}, root[\"tui\"][\"Grid\"] = factory(root[\"_\"], root[\"tui\"] && root[\"tui\"][\"util\"], root[\"Backbone\"], root[\"$\"], root[\"tui\"] && root[\"tui\"][\"DatePicker\"], root[\"tui\"] && root[\"tui\"][\"Pagination\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_34__, __WEBPACK_EXTERNAL_MODULE_38__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId])\n          /******/\n          return installedModules[moduleId].exports;\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n        var module = installedModules[moduleId] = {\n          /******/\n          exports: {},\n\n          /******/\n          id: moduleId,\n\n          /******/\n          loaded: false\n          /******/\n\n        };\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.loaded = true;\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n      __webpack_require__.p = \"\";\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(0);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview The entry file of Grid\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var Grid = __webpack_require__(1);\n\n      __webpack_require__(83);\n\n      Grid.setLanguage('en');\n      module.exports = Grid;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview The Grid class for the external API.\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var View = __webpack_require__(4);\n\n      var ModelManager = __webpack_require__(6);\n\n      var ViewFactory = __webpack_require__(33);\n\n      var DomEventBus = __webpack_require__(58);\n\n      var DomState = __webpack_require__(59);\n\n      var PublicEventEmitter = __webpack_require__(60);\n\n      var PainterManager = __webpack_require__(61);\n\n      var PainterController = __webpack_require__(72);\n\n      var NetAddOn = __webpack_require__(73);\n\n      var ComponentHolder = __webpack_require__(76);\n\n      var util = __webpack_require__(17);\n\n      var i18n = __webpack_require__(42);\n\n      var themeManager = __webpack_require__(77);\n\n      var themeNameConst = __webpack_require__(10).themeName;\n\n      var instanceMap = {};\n      /**\n       * Grid public API\n       * @class Grid\n       * @param {Object} options\n       *      @param {Array} [options.data] - Grid data for making rows.\n       *      @param {Object} [options.header] - Options object for header.\n       *      @param {number} [options.header.height=40] - The height of the header area.\n       *      @param {Array} [options.header.complexColumns] - This options creates new parent headers of the multiple columns\n       *          which includes the headers of spcified columns, and sets up the hierarchy.\n       *      @param {boolean} [options.virtualScrolling=false] - If set to true, use virtual-scrolling so that large\n       *          amount of data can be processed performantly. When using this option that sets true, the rowHeight option\n       *          must set value.\n       *      @param {string|number} [options.rowHeight] - The height of each rows. The default value is 'auto',\n       *          the height of each rows expands to dom's height. If set to number, the height is fixed.\n       *      @param {number} [options.minRowHeight=40] - The minimum height of each rows. When this value is larger than\n       *          the row's height, it set to the row's height.\n       *      @param {string|number} [options.bodyHeight] - The height of body area. The default value is 'auto',\n       *          the height of body area expands to total height of rows. If set to 'fitToParent', the height of the grid\n       *          will expand to fit the height of parent element. If set to number, the height is fixed.\n       *      @param {number} [options.minBodyHeight=minRowHeight] - The minimum height of body area. When this value\n       *          is larger than the body's height, it set to the body's height.\n       *      @param {Object} [options.columnOptions] - Option object for all columns\n       *      @param {number} [options.columnOptions.minWidth=50] - Minimum width of each columns\n       *      @param {boolean} [options.columnOptions.resizable=true] - If set to true, resize-handles of each columns\n       *          will be shown.\n       *      @param {number} [options.columnOptions.frozenCount=0] - The number of frozen columns.\n       *          The columns indexed from 0 to this value will always be shown on the left side.\n       *          {@link Grid#setFrozenColumnCount} can be used for setting this value dynamically.\n       *      @param {number} [options.columnOptions.frozenBorderWidth=1] - The value of frozen border width.\n       *          When the frozen columns are created by \"frozenCount\" option, the frozen border width set.\n       *      @param {Object} [options.treeColumnOptions] - Option object for the tree column.\n       *      @param {string} [options.treeColumnOptions.name] - The name of column that makes tree column.\n       *      @param {boolean} [options.treeColumnOptions.useIcon=true] - If set to true, the folder or file icon is created on\n       *          the left side of the tree cell data.\n       *      @param {boolean} [options.treeColumnOptions.useCascadingCheckbox] - If set to true, a cascading relationship is\n       *          created in the checkbox between parent and child rows.\n       *      @param {Object} [options.copyOptions] - Option object for clipboard copying\n       *      @param {boolean} [options.copyOptions.useFormattedValue] - Whether to use formatted values or original values\n       *          as a string to be copied to the clipboard\n       *      @param {boolean} [options.useClientSort=true] - If set to true, sorting will be executed by client itself\n       *          without server.\n       *      @param {string} [options.editingEvent='dblclick'] - If set to 'click', editable cell in the view-mode will be\n       *          changed to edit-mode by a single click.\n       *      @param {boolean} [options.scrollX=true] - Specifies whether to show horizontal scrollbar.\n       *      @param {boolean} [options.scrollY=true] - Specifies whether to show vertical scrollbar.\n       *      @param {boolean} [options.showDummyRows=false] - If set to true, empty area will be filled with dummy rows.\n       *      @param {?string} [options.keyColumnName=null] - The name of the column to be used to identify each rows.\n       *          If not specified, unique value for each rows will be created internally.\n       *      @param {boolean} [options.heightResizable=false] - If set to true, a handle for resizing height will be shown.\n       *      @param {Object} [options.pagination=null] - Options for tui.Pagination.\n       *          If set to null or false, pagination will not be used.\n       *      @param {string} [options.selectionUnit='cell'] - The unit of selection on Grid. ('cell', 'row')\n       *      @param {Array} [options.rowHeaders] - Options for making the row header. The row header content is number of\n       *          each row or input element. The value of each item is enable to set string type. (ex: ['rowNum', 'checkbox'])\n       *          @param {string} [options.rowHeaders.type] - The type of the row header. ('rowNum', 'checkbox', 'radio')\n       *          @param {string} [options.rowHeaders.title] - The title of the row header on the grid header area.\n       *          @param {number} [options.rowHeaders.width] - The width of the row header.\n       *          @param {function} [options.rowHeaders.template] - Template function which returns the content(HTML) of\n       *              the row header. This function takes a parameter an K-V object as a parameter to match template values.\n       *      @param {Array} options.columns - The configuration of the grid columns.\n       *          @param {string} options.columns.name - The name of the column.\n       *          @param {boolean} [options.columns.ellipsis=false] - If set to true, ellipsis will be used\n       *              for overflowing content.\n       *          @param {string} [options.columns.align=left] - Horizontal alignment of the column content.\n       *              Available values are 'left', 'center', 'right'.\n       *          @param {string} [options.columns.valign=middle] - Vertical alignment of the column content.\n       *              Available values are 'top', 'middle', 'bottom'.\n       *          @param {string} [options.columns.className] - The name of the class to be used for all cells of\n       *              the column.\n       *          @param {string} [options.columns.title] - The title of the column to be shown on the header.\n       *          @param {number} [options.columns.width] - The width of the column. The unit is pixel. If this value\n       *              isn't set, the column's width is automatically resized.\n       *          @param {number} [options.columns.minWidth=50] - The minimum width of the column. The unit is pixel.\n       *          @param {boolean} [options.columns.hidden] - If set to true, the column will not be shown.\n       *          @param {boolean} [options.columns.resizable] - If set to false, the width of the column\n       *              will not be changed.\n       *          @param {Object} [options.columns.validation] - The options to be used for validation.\n       *              Validation is executed whenever data is changed or the {@link Grid#validate} is called.\n       *          @param {boolean} [options.columns.validation.required=false] - If set to true, the data of the column\n       *              will be checked to be not empty.\n       *          @param {string} [options.columns.validation.dataType='string'] - Specifies the type of the cell value.\n       *              Avilable types are 'string' and 'number'.\n       *          @param {string} [options.columns.defaultValue] - The default value to be shown when the column\n       *              doesn't have a value.\n       *          @param {function} [options.columns.formatter] - The function that formats the value of the cell.\n       *              The retrurn value of the function will be shown as the value of the cell.\n       *          @param {boolean} [options.columns.useHtmlEntity=true] - If set to true, the value of the cell\n       *              will be encoded as HTML entities.\n       *          @param {boolean} [options.columns.ignored=false] - If set to true, the value of the column will be\n       *               ignored when setting up the list of modified rows.\n       *          @param {boolean} [options.columns.sortable=false] - If set to true, sort button will be shown on\n       *              the right side of the column header, which executes the sort action when clicked.\n       *          @param {string} [options.columns.sortingType='asc'] - If set to desc, will execute descending sort initially\n       *              when sort button is clicked.\n       *          @param {function} [options.columns.onBeforeChange] - The function that will be\n       *              called before changing the value of the cell. If stop() method in event object is called,\n       *              the changing will be canceled.\n       *          @param {function} [options.columns.onAfterChange] - The function that will be\n       *              called after changing the value of the cell.\n       *          @param {Object} [options.columns.editOptions] - The object for configuring editing UI.\n       *              @param {string} [options.columns.editOptions.type='text'] - The string value that specifies\n       *                  the type of the editing UI.\n       *                  Available values are 'text', 'password', 'select', 'radio', 'checkbox'.\n       *              @param {boolean} [options.columns.editOptions.useViewMode=true] - If set to true, default mode\n       *                  of the cell will be the 'view-mode'. The mode will be switched to 'edit-mode' only when user\n       *                  double click or press 'ENTER' key on the cell. If set to false, the cell will always show the\n       *                  input elements as a default.\n       *              @param {Array} [options.columns.editOptions.listItems] - Specifies the option items for the\n       *                  'select', 'radio', 'checkbox' type. The item of the array must contain properties named\n       *                  'text' and 'value'. (e.g. [{text: 'option1', value: 1}, {...}])\n       *              @param {function} [options.columns.editOptions.onFocus] - The function that will be\n       *                  called when a 'focus' event occurred on an input element\n       *              @param {function} [options.columns.editOptions.onBlur] - The function that will be\n       *                  called when a 'blur' event occurred on an input element\n       *              @param {function} [options.columns.editOptions.onKeyDown] - The function that will be\n       *                  called when a 'keydown' event occurred on an input element\n       *              @param {(string|function)} [options.columns.editOptions.prefix] - The HTML string to be\n       *                  shown left to the input element. If it's a function, the return value will be used.\n       *              @param {(string|function)} [options.columns.editOptions.postfix] - The HTML string to be\n       *                  shown right to the input element. If it's a function, the return value will be used.\n       *              @param {function} [options.columns.editOptions.converter] - The function whose\n       *                  return value (HTML) represents the UI of the cell. If the return value is\n       *                  falsy(null|undefined|false), default UI will be shown.\n       *              @param {Object} [options.columns.copyOptions] - Option object for clipboard copying.\n       *                  This option is column specific, and overrides the global copyOptions.\n       *              @param {boolean} [options.columns.copyOptions.useFormattedValue] - Whether to use\n       *                  formatted values or original values as a string to be copied to the clipboard\n       *              @param {boolean} [options.columns.copyOptions.useListItemText] - Whether to use\n       *                  concatenated text or original values as a string to be copied to the clipboard\n       *              @param {function} [options.columns.copyOptions.customValue] - Whether to use\n       *                  customized value from \"customValue\" callback or original values as a string to be copied to the clipboard\n       *          @param {Array} [options.columns.relations] - Specifies relation between this and other column.\n       *              @param {Array} [options.columns.relations.targetNames] - Array of the names of target columns.\n       *              @param {function} [options.columns.relations.disabled] - If returns true, target columns\n       *                  will be disabled.\n       *              @param {function} [options.columns.relations.editable] - If returns true, target columns\n       *                  will be editable.\n       *              @param {function} [options.columns.relations.listItems] - The function whose return\n       *                  value specifies the option list for the 'select', 'radio', 'checkbox' type.\n       *                  The options list of target columns will be replaced with the return value of this function.\n       *          @param {string} [options.columns.whiteSpace='nowrap'] - If set to 'normal', the text line is broken\n       *              by fitting to the column's width. If set to 'pre', spaces are preserved and the text is braken by\n       *              new line characters. If set to 'pre-wrap', spaces are preserved, the text line is broken by\n       *              fitting to the column's width and new line characters. If set to 'pre-line', spaces are merged,\n       *              the text line is broken by fitting to the column's width and new line characters.\n       *          @param {Object} [options.columns.component] - Option for using tui-component\n       *              @param {string} [options.columns.component.name] - The name of the compnent to use\n       *                  for this column\n       *              @param {Object} [options.columns.component.options] - The options object to be used for\n       *                  creating the component\n       *      @param {Object} [options.summary] - The object for configuring summary area.\n       *          @param {number} [options.summary.height] - The height of the summary area.\n       *          @param {string} [options.summary.position='bottom'] - The position of the summary area. ('bottom', 'top')\n       *          @param {(string|Object)} [options.summary.defaultContent]\n       *              The configuring of summary cell for every column.\n       *              This options can be overriden for each column by columnContent options.\n       *              If type is string, the value is used as HTML of summary cell for every columns\n       *              without auto-calculation.\n       *              @param {boolean} [options.summary.defaultContent.useAutoSummary=true]\n       *                  If set to true, the summary value of every column is served as a paramater to the template\n       *                  function whenever data is changed.\n       *              @param {function} [options.summary.defaultContent.template] - Template function which returns the\n       *                  content(HTML) of the column of the summary. This function takes an K-V object as a parameter\n       *                  which contains a summary values keyed by 'sum', 'avg', 'min', 'max' and 'cnt'.\n       *          @param {Object} [options.summary.columnContent]\n       *              The configuring of summary cell for each column.\n       *              Sub options below are keyed by each column name.\n       *              If type of value of this object is string, the value is used as HTML of summary cell for\n       *              the column without auto-calculation.\n       *              @param {boolean} [options.summary.columnContent.useAutoSummary=true]\n       *                  If set to true, the summary value of each column is served as a paramater to the template\n       *                  function whenever data is changed.\n       *              @param {function} [options.summary.columnContent.template] - Template function which returns the\n       *                  content(HTML) of the column of the summary. This function takes an K-V object as a parameter\n       *                  which contains a summary values keyed by 'sum', 'avg', 'min', 'max' and 'cnt'.\n       *      @param {boolean} [options.usageStatistics=true] Send the hostname to google analytics.\n       *          If you do not want to send the hostname, this option set to false.\n       */\n\n      var Grid = View.extend(\n      /** @lends Grid.prototype */\n      {\n        initialize: function initialize(options) {\n          options = snippet.extend({\n            usageStatistics: true\n          }, options);\n\n          if (options.footer) {\n            util.warning('The \"footer\" option is deprecated since 2.5.0 and replaced by \"summary\" option.');\n            options.summary = options.footer;\n          }\n\n          this.id = util.getUniqueKey();\n          this.domState = new DomState(this.$el);\n          this.domEventBus = DomEventBus.create();\n          this.modelManager = this._createModelManager(options);\n          this.painterManager = this._createPainterManager();\n          this.componentHolder = this._createComponentHolder(options.pagination);\n          this.viewFactory = this._createViewFactory(options);\n          this.container = this.viewFactory.createContainer();\n          this.publicEventEmitter = this._createPublicEventEmitter();\n          this.container.render();\n          this.refreshLayout();\n\n          if (!themeManager.isApplied()) {\n            themeManager.apply(themeNameConst.DEFAULT);\n          }\n\n          this.addOn = {};\n          instanceMap[this.id] = this;\n\n          if (options.data) {\n            this.setData(options.data);\n          }\n\n          if (options.usageStatistics) {\n            snippet.sendHostname('grid', 'UA-129951906-1');\n          }\n        },\n\n        /**\n         * Creates core model and returns it.\n         * @param {Object} options - Options set by user\n         * @returns {module:model/manager} - New model manager object\n         * @private\n         */\n        _createModelManager: function _createModelManager(options) {\n          var modelOptions = _.assign({}, options, {\n            gridId: this.id,\n            publicObject: this\n          });\n\n          _.omit(modelOptions, 'el');\n\n          return new ModelManager(modelOptions, this.domState, this.domEventBus);\n        },\n\n        /**\n         * Creates painter manager and returns it\n         * @returns {module:painter/manager}\n         * @private\n         */\n        _createPainterManager: function _createPainterManager() {\n          var controller = new PainterController({\n            focusModel: this.modelManager.focusModel,\n            dataModel: this.modelManager.dataModel,\n            columnModel: this.modelManager.columnModel,\n            selectionModel: this.modelManager.selectionModel\n          });\n          return new PainterManager({\n            gridId: this.id,\n            selectType: this.modelManager.columnModel.get('selectType'),\n            fixedRowHeight: this.modelManager.dimensionModel.get('fixedRowHeight'),\n            domEventBus: this.domEventBus,\n            controller: controller\n          });\n        },\n\n        /**\n         * Creates a view factory.\n         * @param {options} options - options\n         * @returns {module:view/factory}\n         * @private\n         */\n        _createViewFactory: function _createViewFactory(options) {\n          var viewOptions = _.pick(options, ['heightResizable', 'summary', 'usageStatistics']);\n\n          var dependencies = {\n            modelManager: this.modelManager,\n            painterManager: this.painterManager,\n            componentHolder: this.componentHolder,\n            domEventBus: this.domEventBus,\n            domState: this.domState\n          };\n          return new ViewFactory(_.assign(dependencies, viewOptions));\n        },\n\n        /**\n         * Creates a pagination component.\n         * @param {Object} pgOptions - pagination options\n         * @returns {module:component/pagination}\n         * @private\n         */\n        _createComponentHolder: function _createComponentHolder(pgOptions) {\n          return new ComponentHolder({\n            pagination: pgOptions\n          });\n        },\n\n        /**\n         * Creates public event emitter and returns it.\n         * @returns {module:publicEventEmitter} - New public event emitter\n         * @private\n         */\n        _createPublicEventEmitter: function _createPublicEventEmitter() {\n          var emitter = new PublicEventEmitter(this);\n          emitter.listenToFocusModel(this.modelManager.focusModel);\n          emitter.listenToDomEventBus(this.domEventBus);\n          emitter.listenToDataModel(this.modelManager.dataModel);\n          emitter.listenToSelectionModel(this.modelManager.selectionModel);\n          return emitter;\n        },\n\n        /**\n         * Disables all rows.\n         */\n        disable: function disable() {\n          this.modelManager.dataModel.setDisabled(true);\n        },\n\n        /**\n         * Enables all rows.\n         */\n        enable: function enable() {\n          this.modelManager.dataModel.setDisabled(false);\n        },\n\n        /**\n         * Disables the row identified by the rowkey.\n         * @param {number|string} rowKey - The unique key of the target row\n         */\n        disableRow: function disableRow(rowKey) {\n          this.modelManager.dataModel.disableRow(rowKey);\n        },\n\n        /**\n         * Enables the row identified by the rowKey.\n         * @param {number|string} rowKey - The unique key of the target row\n         */\n        enableRow: function enableRow(rowKey) {\n          this.modelManager.dataModel.enableRow(rowKey);\n        },\n\n        /**\n         * Returns the value of the cell identified by the rowKey and columnName.\n         * @param {number|string} rowKey - The unique key of the target row.\n         * @param {string} columnName - The name of the column\n         * @param {boolean} [isOriginal] - It set to true, the original value will be return.\n         * @returns {number|string} - The value of the cell\n         */\n        getValue: function getValue(rowKey, columnName, isOriginal) {\n          return this.modelManager.dataModel.getValue(rowKey, columnName, isOriginal);\n        },\n\n        /**\n         * Returns a list of all values in the specified column.\n         * @param {string} columnName - The name of the column\n         * @param {boolean} [isJsonString=false] - It set to true, return value will be converted to JSON string.\n         * @returns {(Array|string)} - A List of all values in the specified column. (or JSON string of the list)\n         */\n        getColumnValues: function getColumnValues(columnName, isJsonString) {\n          return this.modelManager.dataModel.getColumnValues(columnName, isJsonString);\n        },\n\n        /**\n         * Returns the object that contains all values in the specified row.\n         * @param {number|string} rowKey - The unique key of the target row\n         * @param {boolean} [isJsonString=false] - If set to true, return value will be converted to JSON string.\n         * @returns {Object|string} - The object that contains all values in the row. (or JSON string of the object)\n         */\n        getRow: function getRow(rowKey, isJsonString) {\n          return this.modelManager.dataModel.getRowData(rowKey, isJsonString);\n        },\n\n        /**\n         * Returns the object that contains all values in the row at specified index.\n         * @param {number} index - The index of the row\n         * @param {boolean} [isJsonString=false] - If set to true, return value will be converted to JSON string.\n         * @returns {Object|string} - The object that contains all values in the row. (or JSON string of the object)\n         */\n        getRowAt: function getRowAt(index, isJsonString) {\n          return this.modelManager.dataModel.getRowDataAt(index, isJsonString);\n        },\n\n        /**\n         * Returns the total number of the rows.\n         * @returns {number} - The total number of the rows\n         */\n        getRowCount: function getRowCount() {\n          return this.modelManager.dataModel.length;\n        },\n\n        /**\n         * Returns data of currently focused cell\n         * @returns {number} rowKey - The unique key of the row\n         * @returns {string} columnName - The name of the column\n         * @returns {string} value - The value of the cell\n         */\n        getFocusedCell: function getFocusedCell() {\n          var addr = this.modelManager.focusModel.which();\n          var value = this.getValue(addr.rowKey, addr.columnName);\n          return {\n            rowKey: addr.rowKey,\n            columnName: addr.columnName,\n            value: value\n          };\n        },\n\n        /**\n         * Returns the jquery object of the cell identified by the rowKey and columnName.\n         * @param {number|string} rowKey - The unique key of the row\n         * @param {string} columnName - The name of the column\n         * @returns {jQuery} - The jquery object of the cell element\n         */\n        getElement: function getElement(rowKey, columnName) {\n          return this.modelManager.dataModel.getElement(rowKey, columnName);\n        },\n\n        /**\n         * Sets the value of the cell identified by the specified rowKey and columnName.\n         * @param {number|string} rowKey - The unique key of the row\n         * @param {string} columnName - The name of the column\n         * @param {number|string} columnValue - The value to be set\n         */\n        setValue: function setValue(rowKey, columnName, columnValue) {\n          this.modelManager.dataModel.setValue(rowKey, columnName, columnValue);\n        },\n\n        /**\n         * Sets the all values in the specified column.\n         * @param {string} columnName - The name of the column\n         * @param {number|string} columnValue - The value to be set\n         * @param {boolean} [isCheckCellState=true] - If set to true, only editable and not disabled cells will be affected.\n         */\n        setColumnValues: function setColumnValues(columnName, columnValue, isCheckCellState) {\n          this.modelManager.dataModel.setColumnValues(columnName, columnValue, isCheckCellState);\n        },\n\n        /**\n         * Replaces all rows with the specified list. This will not change the original data.\n         * @param {Array} data - A list of new rows\n         */\n        resetData: function resetData(data) {\n          this.modelManager.dataModel.resetData(data);\n        },\n\n        /**\n         * Replaces all rows with the specified list. This will change the original data.\n         * @param {Array} data - A list of new rows\n         * @param {function} callback - The function that will be called when done.\n         */\n        setData: function setData(data, callback) {\n          this.modelManager.dataModel.setData(data, true, callback);\n        },\n\n        /**\n         * Sets the height of body-area.\n         * @param {number} value - The number of pixel\n         */\n        setBodyHeight: function setBodyHeight(value) {\n          this.modelManager.dimensionModel.set({\n            bodyHeight: value,\n            fixedHeight: value !== 'auto'\n          });\n        },\n\n        /**\n         * Sets focus on the cell identified by the specified rowKey and columnName.\n         * @param {number|string} rowKey - The unique key of the row\n         * @param {string} columnName - The name of the column\n         * @param {boolean} [isScrollable=false] - If set to true, the view will scroll to the cell element.\n         */\n        focus: function focus(rowKey, columnName, isScrollable) {\n          this.modelManager.focusModel.focusClipboard();\n          this.modelManager.focusModel.focus(rowKey, columnName, isScrollable);\n        },\n\n        /**\n         * Sets focus on the cell at the specified index of row and column.\n         * @param {number|string} rowIndex - The index of the row\n         * @param {string} columnIndex - The index of the column\n         * @param {boolean} [isScrollable=false] - If set to true, the view will scroll to the cell element.\n         */\n        focusAt: function focusAt(rowIndex, columnIndex, isScrollable) {\n          this.modelManager.focusModel.focusAt(rowIndex, columnIndex, isScrollable);\n        },\n\n        /**\n         * Sets focus on the cell at the specified index of row and column and starts to edit.\n         * @param {number|string} rowKey - The unique key of the row\n         * @param {string} columnName - The name of the column\n         * @param {boolean} [isScrollable=false] - If set to true, the view will scroll to the cell element.\n         */\n        focusIn: function focusIn(rowKey, columnName, isScrollable) {\n          this.modelManager.focusModel.focusIn(rowKey, columnName, isScrollable);\n        },\n\n        /**\n         * Sets focus on the cell at the specified index of row and column and starts to edit.\n         * @param {number|string} rowIndex - The index of the row\n         * @param {string} columnIndex - The index of the column\n         * @param {boolean} [isScrollable=false] - If set to true, the view will scroll to the cell element.\n         */\n        focusInAt: function focusInAt(rowIndex, columnIndex, isScrollable) {\n          this.modelManager.focusModel.focusInAt(rowIndex, columnIndex, isScrollable);\n        },\n\n        /**\n         * Makes view ready to get keyboard input.\n         */\n        activateFocus: function activateFocus() {\n          this.modelManager.focusModel.focusClipboard();\n        },\n\n        /**\n         * Removes focus from the focused cell.\n         */\n        blur: function blur() {\n          this.modelManager.focusModel.blur();\n        },\n\n        /**\n         * Checks all rows.\n         */\n        checkAll: function checkAll() {\n          this.modelManager.dataModel.checkAll();\n        },\n\n        /**\n         * Checks the row identified by the specified rowKey.\n         * @param {number|string} rowKey - The unique key of the row\n         */\n        check: function check(rowKey) {\n          this.modelManager.dataModel.check(rowKey);\n        },\n\n        /**\n         * Unchecks all rows.\n         */\n        uncheckAll: function uncheckAll() {\n          this.modelManager.dataModel.uncheckAll();\n        },\n\n        /**\n         * Unchecks the row identified by the specified rowKey.\n         * @param {number|string} rowKey - The unique key of the row\n         */\n        uncheck: function uncheck(rowKey) {\n          this.modelManager.dataModel.uncheck(rowKey);\n        },\n\n        /**\n         * Removes all rows.\n         */\n        clear: function clear() {\n          this.modelManager.dataModel.setData([]);\n        },\n\n        /**\n         * Removes the row identified by the specified rowKey.\n         * @param {number|string} rowKey - The unique key of the row\n         * @param {boolean|object} [options] - Options. If the type is boolean, this value is equivalent to\n         *     options.removeOriginalData.\n         * @param {boolean} [options.removeOriginalData] - If set to true, the original data will be removed.\n         * @param {boolean} [options.keepRowSpanData] - If set to true, the value of the merged cells will not be\n         *     removed although the target is first cell of them.\n         */\n        removeRow: function removeRow(rowKey, options) {\n          if (snippet.isBoolean(options) && options) {\n            options = {\n              removeOriginalData: true\n            };\n          }\n\n          this.modelManager.dataModel.removeRow(rowKey, options);\n        },\n\n        /**\n         * Removes all checked rows.\n         * @param {boolean} showConfirm - If set to true, confirm message will be shown before remove.\n         * @returns {boolean} - True if there's at least one row removed.\n         */\n        removeCheckedRows: function removeCheckedRows(showConfirm) {\n          var rowKeys = this.getCheckedRowKeys();\n          var confirmMessage = i18n.get('net.confirmDelete', {\n            count: rowKeys.length\n          });\n\n          if (rowKeys.length > 0 && (!showConfirm || confirm(confirmMessage))) {\n            _.each(rowKeys, function (rowKey) {\n              this.modelManager.dataModel.removeRow(rowKey);\n            }, this);\n\n            return true;\n          }\n\n          return false;\n        },\n\n        /**\n         * Enables the row identified by the rowKey to be able to check.\n         * @param {number|string} rowKey - The unique key of the row\n         */\n        enableCheck: function enableCheck(rowKey) {\n          this.modelManager.dataModel.enableCheck(rowKey);\n        },\n\n        /**\n         * Disables the row identified by the spcified rowKey to not be abled to check.\n         * @param {number|string} rowKey - The unique keyof the row.\n         */\n        disableCheck: function disableCheck(rowKey) {\n          this.modelManager.dataModel.disableCheck(rowKey);\n        },\n\n        /**\n         * Returns a list of the rowKey of checked rows.\n         * @param {boolean} [isJsonString=false] - If set to true, return value will be converted to JSON string.\n         * @returns {Array|string} - A list of the rowKey. (or JSON string of the list)\n         */\n        getCheckedRowKeys: function getCheckedRowKeys(isJsonString) {\n          var checkedRowList = this.modelManager.dataModel.getRows(true);\n\n          var checkedRowKeyList = _.pluck(checkedRowList, 'rowKey');\n\n          return isJsonString ? JSON.stringify(checkedRowKeyList) : checkedRowKeyList;\n        },\n\n        /**\n         * Returns a list of the checked rows.\n         * @param {boolean} [useJson=false] - If set to true, return value will be converted to JSON string.\n         * @returns {Array|string} - A list of the checked rows. (or JSON string of the list)\n         */\n        getCheckedRows: function getCheckedRows(useJson) {\n          var checkedRowList = this.modelManager.dataModel.getRows(true);\n          return useJson ? JSON.stringify(checkedRowList) : checkedRowList;\n        },\n\n        /**\n         * Returns a list of the column model.\n         * @returns {Array} - A list of the column model.\n         */\n        getColumns: function getColumns() {\n          return this.modelManager.columnModel.get('dataColumns');\n        },\n\n        /**\n         * Returns the object that contains the lists of changed data compared to the original data.\n         * The object has properties 'createdRows', 'updatedRows', 'deletedRows'.\n         * @param {Object} [options] Options\n         *     @param {boolean} [options.checkedOnly=false] - If set to true, only checked rows will be considered.\n         *     @param {boolean} [options.withRawData=false] - If set to true, the data will contains\n         *         the row data for internal use.\n         *     @param {boolean} [options.rowKeyOnly=false] - If set to true, only keys of the changed\n         *         rows will be returned.\n         *     @param {Array} [options.ignoredColumns] - A list of column name to be excluded.\n         * @returns {{createdRows: Array, updatedRows: Array, deletedRows: Array}} - Object that contains the result list.\n         */\n        getModifiedRows: function getModifiedRows(options) {\n          return this.modelManager.dataModel.getModifiedRows(options);\n        },\n\n        /**\n         * Inserts the new row with specified data to the end of table.\n         * @param {Object} [row] - The data for the new row\n         * @param {Object} [options] - Options\n         * @param {number} [options.at] - The index at which new row will be inserted\n         * @param {boolean} [options.extendPrevRowSpan] - If set to true and the previous row at target index\n         *        has a rowspan data, the new row will extend the existing rowspan data.\n         * @param {boolean} [options.focus] - If set to true, move focus to the new row after appending\n         * @param {(Number|String)} [options.parentRowKey] - Tree row key of the parent which appends given rows\n         * @param {number} [options.offset] - Tree offset from first sibling\n         */\n        appendRow: function appendRow(row, options) {\n          this.modelManager.dataModel.appendRow(row, options);\n        },\n\n        /**\n         * Inserts the new row with specified data to the beginning of table.\n         * @param {Object} [row] - The data for the new row\n         * @param {Object} [options] - Options\n         * @param {boolean} [options.focus] - If set to true, move focus to the new row after appending\n         */\n        prependRow: function prependRow(row, options) {\n          this.modelManager.dataModel.prependRow(row, options);\n        },\n\n        /**\n         * Returns true if there are at least one row modified.\n         * @returns {boolean} - True if there are at least one row modified.\n         */\n        isModified: function isModified() {\n          return this.modelManager.dataModel.isModified();\n        },\n\n        /**\n         * Returns the instance of specified AddOn.\n         * @param {string} name - The name of the AddOn\n         * @returns {instance} addOn - The instance of the AddOn\n         */\n        getAddOn: function getAddOn(name) {\n          return name ? this.addOn[name] : this.addOn;\n        },\n\n        /**\n         * Restores the data to the original data.\n         * (Original data is set by {@link Grid#setData|setData}\n         */\n        restore: function restore() {\n          this.modelManager.dataModel.restore();\n        },\n\n        /**\n         * Sets options for header.\n         * @param {Object} options - Options for header\n         * @param {number} [options.height] -  The height value\n         * @param {Array} [options.complexColumns] - The complex columns info\n         */\n        setHeader: function setHeader(options) {\n          if (options.height) {\n            this.modelManager.dimensionModel.set('headerHeight', options.height);\n          }\n\n          if (options.complexColumns) {\n            this.modelManager.columnModel.set({\n              complexHeaderColumns: options.complexColumns\n            });\n          }\n        },\n\n        /**\n         * Sets the count of frozen columns.\n         * @param {number} count - The count of columns to be frozen\n         */\n        setFrozenColumnCount: function setFrozenColumnCount(count) {\n          this.modelManager.columnModel.set('frozenCount', count);\n        },\n\n        /**\n         * Sets the list of column model.\n         * @param {Array} columns - A new list of column model\n         * @example\n         * {\n         *      columnName1: 'title1',\n         *      columnName2: 'title2',\n         *      columnName3: 'title3'\n         * }\n         */\n        setColumns: function setColumns(columns) {\n          this.modelManager.columnModel.set('columns', columns);\n        },\n\n        /**\n         * Set columns title\n         * @param {string} columnsMap - columns map to be change\n         */\n        setColumnTitles: function setColumnTitles(columnsMap) {\n          this.modelManager.columnModel.setColumnTitles(columnsMap);\n        },\n\n        /**\n         * Creates an specified AddOn and use it on this instance.\n         * @param {string} name - The name of the AddOn to use.\n         * @param {Object} options - The option objects for configuring the AddON.\n         * @returns {Grid} - This instance.\n         */\n        use: function use(name, options) {\n          if (name === 'Net') {\n            options = _.assign({\n              domEventBus: this.domEventBus,\n              renderModel: this.modelManager.renderModel,\n              dataModel: this.modelManager.dataModel,\n              pagination: this.componentHolder.getInstance('pagination')\n            }, options);\n            this.addOn.Net = new NetAddOn(options);\n            this.publicEventEmitter.listenToNetAddon(this.addOn.Net);\n          }\n\n          return this;\n        },\n\n        /**\n         * Returns a list of all rows.\n         * @returns {Array} - A list of all rows\n         */\n        getRows: function getRows() {\n          return this.modelManager.dataModel.getRows();\n        },\n\n        /**\n         * Sorts all rows by the specified column.\n         * @param {string} columnName - The name of the column to be used to compare the rows\n         * @param {boolean} [ascending] - Whether the sort order is ascending.\n         *        If not specified, use the negative value of the current order.\n         */\n        sort: function sort(columnName, ascending) {\n          this.modelManager.dataModel.sortByField(columnName, ascending);\n        },\n\n        /**\n         * Unsorts all rows. (Sorts by rowKey).\n         */\n        unSort: function unSort() {\n          this.sort('rowKey');\n        },\n\n        /**\n         * Gets state of the sorted column in rows\n         * @returns {{columnName: string, ascending: boolean, useClient: boolean}} Sorted column's state\n         */\n        getSortState: function getSortState() {\n          return this.modelManager.dataModel.sortOptions;\n        },\n\n        /**\n         * Adds the specified css class to cell element identified by the rowKey and className\n         * @param {number|string} rowKey - The unique key of the row\n         * @param {string} columnName - The name of the column\n         * @param {string} className - The css class name to add\n         */\n        addCellClassName: function addCellClassName(rowKey, columnName, className) {\n          this.modelManager.dataModel.get(rowKey).addCellClassName(columnName, className);\n        },\n\n        /**\n         * Adds the specified css class to all cell elements in the row identified by the rowKey\n         * @param {number|string} rowKey - The unique key of the row\n         * @param {string} className - The css class name to add\n         */\n        addRowClassName: function addRowClassName(rowKey, className) {\n          this.modelManager.dataModel.get(rowKey).addClassName(className);\n        },\n\n        /**\n         * Removes the specified css class from the cell element indentified by the rowKey and columnName.\n         * @param {number|string} rowKey - The unique key of the row\n         * @param {string} columnName - The name of the column\n         * @param {string} className - The css class name to be removed\n         */\n        removeCellClassName: function removeCellClassName(rowKey, columnName, className) {\n          this.modelManager.dataModel.get(rowKey).removeCellClassName(columnName, className);\n        },\n\n        /**\n         * Removes the specified css class from all cell elements in the row identified by the rowKey.\n         * @param {number|string} rowKey - The unique key of the row\n         * @param {string} className - The css class name to be removed\n         */\n        removeRowClassName: function removeRowClassName(rowKey, className) {\n          this.modelManager.dataModel.get(rowKey).removeClassName(className);\n        },\n\n        /**\n         * Returns the rowspan data of the cell identified by the rowKey and columnName.\n         * @param {number|string} rowKey - The unique key of the row\n         * @param {string} columnName - The name of the column\n         * @returns {Object} - Row span data\n         */\n        getRowSpanData: function getRowSpanData(rowKey, columnName) {\n          return this.modelManager.dataModel.getRowSpanData(rowKey, columnName);\n        },\n\n        /**\n         * Returns the index of the row indentified by the rowKey.\n         * @param {number|string} rowKey - The unique key of the row\n         * @returns {number} - The index of the row\n         */\n        getIndexOfRow: function getIndexOfRow(rowKey) {\n          return this.modelManager.dataModel.indexOfRowKey(rowKey);\n        },\n\n        /**\n         * Returns the index of the column indentified by the column name.\n         * @param {string} columnName - The unique key of the column\n         * @returns {number} - The index of the column\n         */\n        getIndexOfColumn: function getIndexOfColumn(columnName) {\n          return this.modelManager.columnModel.indexOfColumnName(columnName);\n        },\n\n        /**\n         * Returns an instance of tui.Pagination.\n         * @returns {tui.Pagination}\n         */\n        getPagination: function getPagination() {\n          return this.componentHolder.getInstance('pagination');\n        },\n\n        /**\n         * Sets the width of the dimension.\n         * @param {number} width - The width of the dimension\n         */\n        setWidth: function setWidth(width) {\n          this.modelManager.dimensionModel.setWidth(width);\n        },\n\n        /**\n         * Sets the height of the dimension.\n         * @param {number} height - The height of the dimension\n         */\n        setHeight: function setHeight(height) {\n          this.modelManager.dimensionModel.setHeight(height);\n        },\n\n        /**\n         * Refreshs the layout view. Use this method when the view was rendered while hidden.\n         */\n        refreshLayout: function refreshLayout() {\n          this.modelManager.dimensionModel.refreshLayout();\n        },\n\n        /**\n         * Resets the width of each column by using initial setting of column models.\n         */\n        resetColumnWidths: function resetColumnWidths() {\n          this.modelManager.coordColumnModel.resetColumnWidths();\n        },\n\n        /**\n         * Shows columns\n         * @param {...string} arguments - Column names to show\n         */\n        showColumn: function showColumn() {\n          var args = snippet.toArray(arguments);\n          this.modelManager.columnModel.setHidden(args, false);\n        },\n\n        /**\n         * Hides columns\n         * @param {...string} arguments - Column names to hide\n         */\n        hideColumn: function hideColumn() {\n          var args = snippet.toArray(arguments);\n          this.modelManager.columnModel.setHidden(args, true);\n        },\n\n        /**\n         * Sets the HTML string of given column summary.\n         * The type of content is the same as the options.summary.columnContent of the constructor.\n         * @param {string} columnName - column name\n         * @param {string|object} content - HTML string or options object.\n         */\n        setSummaryColumnContent: function setSummaryColumnContent(columnName, content) {\n          this.modelManager.summaryModel.setColumnContent(columnName, content, true);\n        },\n\n        /**\n         * Returns the values of given column summary.\n         * If the column name is not specified, all values of available columns are returned.\n         * The shape of returning object looks like the example below.\n         * @param {string} [columnName] - column name\n         * @returns {Object}\n         * @example\n         * {\n         *    column1: {\n         *        sum: 1000,\n         *        avg: 200,\n         *        max: 300,\n         *        min: 50,\n         *        cnt: 5\n         *    },\n         *    column2: {\n         *        sum: 2000,\n         *        avg: 300,\n         *        max: 600,\n         *        min: 80,\n         *        cnt: 5\n         *    }\n         * }\n         */\n        getSummaryValues: function getSummaryValues(columnName) {\n          if (this.modelManager.summaryModel) {\n            return this.modelManager.summaryModel.getValues(columnName);\n          }\n\n          return null;\n        },\n\n        /**\n         * Sets the HTML string of given column summary.\n         * @deprecated since version 2.5.0 and is replaced by \"setSummaryColumnContent\" API\n         * @param {string} columnName - column name\n         * @param {string} contents - HTML string\n         */\n        setFooterColumnContent: function setFooterColumnContent(columnName, contents) {\n          this.modelManager.columnModel.setSummaryContent(columnName, contents);\n        },\n\n        /**\n         * Validates all data and returns the result.\n         * Return value is an array which contains only rows which have invalid cell data.\n         * @returns {Array.<Object>} An array of error object\n         * @example\n         * // return value example\n         * [\n         *     {\n         *         rowKey: 1,\n         *         errors: [\n         *             {\n         *                 columnName: 'c1',\n         *                 errorCode: 'REQUIRED'\n         *             },\n         *             {\n         *                 columnName: 'c2',\n         *                 errorCode: 'REQUIRED'\n         *             }\n         *         ]\n         *     },\n         *     {\n         *         rowKey: 3,\n         *         errors: [\n         *             {\n         *                 columnName: 'c2',\n         *                 errorCode: 'REQUIRED'\n         *             }\n         *         ]\n         *     }\n         * ]\n         */\n        validate: function validate() {\n          return this.modelManager.dataModel.validate();\n        },\n\n        /**\n         * Finds rows by conditions\n         * @param {Object|Function} conditions - object (key: column name, value: column value) or\n         *     function that check the value and returns true/false result to find rows\n         * @returns {Array} Row list\n         * @example <caption>Conditions type is object.</caption>\n         * grid.findRows({\n         *     artist: 'Birdy',\n         *     price: 10000\n         * });\n         * @example <caption>Conditions type is function.</caption>\n         * grid.findRows(function(row) {\n         *     return (/b/ig.test(row.artist) && row.price > 10000);\n         * });\n         */\n        findRows: function findRows(conditions) {\n          return this.modelManager.dataModel.findRows(conditions);\n        },\n\n        /**\n         * Copy to clipboard\n         */\n        copyToClipboard: function copyToClipboard() {\n          this.modelManager.clipboardModel.setClipboardText();\n\n          if (!window.clipboardData) {\n            // Accessing the clipboard is a security concern on chrome\n            document.execCommand('copy');\n          }\n        },\n\n        /**\n         * Selects cells or rows by range\n         * @param {Object} range - Selection range\n         *     @param {Array} [range.start] - Index info of start selection (ex: [rowIndex, columnIndex])\n         *     @param {Array} [range.end] - Index info of end selection (ex: [rowIndex, columnIndex])\n         */\n        selection: function selection(range) {\n          var selectionModel = this.modelManager.selectionModel;\n          var start = range.start;\n          var end = range.end;\n          var unit = selectionModel.getSelectionUnit();\n          selectionModel.start(start[0], start[1], unit);\n          selectionModel.update(end[0], end[1], unit);\n        },\n\n        /**\n         * Expands tree row\n         * @param {number|string} rowKey - row key\n         * @param {boolean} recursive - true for recursively expand all descendant\n         * @returns {Array.<number|string>} - children or descendant of given row\n         */\n        expand: function expand(rowKey, recursive) {\n          return this.modelManager.dataModel.treeExpand(rowKey, recursive);\n        },\n\n        /**\n         * Expands all tree row\n         */\n        expandAll: function expandAll() {\n          this.modelManager.dataModel.treeExpandAll();\n        },\n\n        /**\n         * Expands tree row\n         * @param {number|string} rowKey - row key\n         * @param {boolean} recursive - true for recursively expand all descendant\n         * @returns {Array.<number|string>} - children or descendant of given row\n         */\n        collapse: function collapse(rowKey, recursive) {\n          return this.modelManager.dataModel.treeCollapse(rowKey, recursive);\n        },\n\n        /**\n         * Collapses all tree row\n         */\n        collapseAll: function collapseAll() {\n          this.modelManager.dataModel.treeCollapseAll();\n        },\n\n        /**\n         * Gets the ancestors of the row which has the given row key\n         * @param {number|string} rowKey - row key\n         * @returns {Array.<TreeRow>} - the ancestor rows\n         */\n        getAncestors: function getAncestors(rowKey) {\n          return this.modelManager.dataModel.getTreeAncestors(rowKey);\n        },\n\n        /**\n         * Gets the descendants of the row which has the given row key\n         * @param {number|string} rowKey - row key\n         * @returns {Array.<TreeRow>} - the descendant rows\n         */\n        getDescendants: function getDescendants(rowKey) {\n          return this.modelManager.dataModel.getTreeDescendants(rowKey);\n        },\n\n        /**\n         * Gets the parent of the row which has the given row key\n         * @param {number|string} rowKey - row key\n         * @returns {TreeRow} - the parent row\n         */\n        getParent: function getParent(rowKey) {\n          return this.modelManager.dataModel.getTreeParent(rowKey);\n        },\n\n        /**\n         * Gets the children of the row which has the given row key\n         * @param {number|string} rowKey - row key\n         * @returns {Array.<TreeRow>} - the children rows\n         */\n        getChildren: function getChildren(rowKey) {\n          return this.modelManager.dataModel.getTreeChildren(rowKey);\n        },\n\n        /**\n         * Gets the depth of the row which has the given row key\n         * @param {number|string} rowKey - row key to test\n         * @returns {number} - the depth\n         */\n        getDepth: function getDepth(rowKey) {\n          return this.modelManager.dataModel.getTreeDepth(rowKey);\n        },\n\n        /**\n         * Destroys the instance.\n         */\n        destroy: function destroy() {\n          this.modelManager.destroy();\n          this.container.destroy();\n          this.modelManager = this.container = null;\n        }\n      });\n      /**\n       * Returns an instance of the grid associated to the id.\n       * @static\n       * @param  {number} id - ID of the target grid\n       * @returns {Grid} - Grid instance\n       * var Grid = tui.Grid; // or require('tui-grid')\n       *\n       * Grid.getInstanceById(id);\n       */\n\n      Grid.getInstanceById = function (id) {\n        return instanceMap[id];\n      };\n      /**\n       * Apply theme to all grid instances with the preset options of a given name.\n       * @static\n       * @param {string} presetName - preset theme name. Available values are 'default', 'striped' and 'clean'.\n       * @param {Object} [extOptions] - if exist, extend preset options with this object.\n       *     @param {Object} [extOptions.outline] - Styles for the table outline.\n       *         @param {string} [extOptions.outline.border] - Color of the table outline.\n       *         @param {boolean} [extOptions.outline.showVerticalBorder] - Whether vertical outlines of\n       *             the table are visible.\n       *     @param {Object} [extOptions.selection] - Styles for a selection layer.\n       *         @param {string} [extOptions.selection.background] - Background color of a selection layer.\n       *         @param {string} [extOptions.selection.border] - Border color of a selection layer.\n       *     @param {Object} [extOptions.scrollbar] - Styles for scrollbars.\n       *         @param {string} [extOptions.scrollbar.border] - Border color of scrollbars.\n       *         @param {string} [extOptions.scrollbar.background] - Background color of scrollbars.\n       *         @param {string} [extOptions.scrollbar.emptySpace] - Color of extra spaces except scrollbar.\n       *         @param {string} [extOptions.scrollbar.thumb] - Color of thumbs in scrollbars.\n       *         @param {string} [extOptions.scrollbar.active] - Color of arrows(for IE) or\n       *              thumb:hover(for other browsers) in scrollbars.\n       *     @param {Object} [extOptions.frozenBorder] - Styles for a frozen border.\n       *         @param {string} [extOptions.frozenBorder.border] - Border color of a frozen border.\n       *     @param {Object} [extOptions.area] - Styles for the table areas.\n       *         @param {Object} [extOptions.area.header] - Styles for the header area in the table.\n       *             @param {string} [extOptions.area.header.background] - Background color of the header area\n       *                 in the table.\n       *             @param {string} [extOptions.area.header.border] - Border color of the header area\n       *                 in the table.\n       *         @param {Object} [extOptions.area.body] - Styles for the body area in the table.\n       *             @param {string} [extOptions.area.body.background] - Background color of the body area\n       *                 in the table.\n       *         @param {Object} [extOptions.area.summary] - Styles for the summary area in the table.\n       *             @param {string} [extOptions.area.summary.background] - Background color of the summary area\n       *                 in the table.\n       *             @param {string} [extOptions.area.summary.border] - Border color of the summary area\n       *                 in the table.\n       *     @param {Object} [extOptions.cell] - Styles for the table cells.\n       *         @param {Object} [extOptions.cell.normal] - Styles for normal cells.\n       *             @param {string} [extOptions.cell.normal.background] - Background color of normal cells.\n       *             @param {string} [extOptions.cell.normal.border] - Border color of normal cells.\n       *             @param {string} [extOptions.cell.normal.text] - Text color of normal cells.\n       *             @param {boolean} [extOptions.cell.normal.showVerticalBorder] - Whether vertical borders of\n       *                 normal cells are visible.\n       *             @param {boolean} [extOptions.cell.normal.showHorizontalBorder] - Whether horizontal borders of\n       *                 normal cells are visible.\n       *         @param {Object} [extOptions.cell.head] - Styles for head cells.\n       *             @param {string} [extOptions.cell.head.background] - Background color of head cells.\n       *             @param {string} [extOptions.cell.head.border] - border color of head cells.\n       *             @param {string} [extOptions.cell.head.text] - text color of head cells.\n       *             @param {boolean} [extOptions.cell.head.showVerticalBorder] - Whether vertical borders of\n       *                 head cells are visible.\n       *             @param {boolean} [extOptions.cell.head.showHorizontalBorder] - Whether horizontal borders of\n       *                 head cells are visible.\n       *         @param {Object} [extOptions.cell.selectedHead] - Styles for selected head cells.\n       *             @param {string} [extOptions.cell.selectedHead.background] - background color of selected haed cells.\n       *         @param {Object} [extOptions.cell.rowHead] - Styles for row's head cells.\n       *             @param {string} [extOptions.cell.rowHead.background] - Background color of row's head cells.\n       *             @param {string} [extOptions.cell.rowHead.border] - border color of row's head cells.\n       *             @param {string} [extOptions.cell.rowHead.text] - text color of row's head cells.\n       *             @param {boolean} [extOptions.cell.rowHead.showVerticalBorder] - Whether vertical borders of\n       *                 row's head cells are visible.\n       *             @param {boolean} [extOptions.cell.rowHead.showHorizontalBorder] - Whether horizontal borders of\n       *                 row's head cells are visible.\n       *         @param {Object} [extOptions.cell.selectedRowHead] - Styles for selected row's head cells.\n       *             @param {string} [extOptions.cell.selectedRowHead.background] - background color of selected row's haed cells.\n       *         @param {Object} [extOptions.cell.summary] - Styles for cells in the summary area.\n       *             @param {string} [extOptions.cell.summary.background] - Background color of cells in the summary area.\n       *             @param {string} [extOptions.cell.summary.border] - border color of cells in the summary area.\n       *             @param {string} [extOptions.cell.summary.text] - text color of cells in the summary area.\n       *             @param {boolean} [extOptions.cell.summary.showVerticalBorder] - Whether vertical borders of\n       *                 cells in the summary area are visible.\n       *             @param {boolean} [extOptions.cell.summary.showHorizontalBorder] - Whether horizontal borders of\n       *                 cells in the summary area are visible.\n       *         @param {Object} [extOptions.cell.focused] - Styles for a focused cell.\n       *             @param {string} [extOptions.cell.focused.background] - background color of a focused cell.\n       *             @param {string} [extOptions.cell.focused.border] - border color of a focused cell.\n       *         @param {Object} [extOptions.cell.focusedInactive] - Styles for a inactive focus cell.\n       *             @param {string} [extOptions.cell.focusedInactive.border] - border color of a inactive focus cell.\n       *         @param {Object} [extOptions.cell.required] - Styles for required cells.\n       *             @param {string} [extOptions.cell.required.background] - background color of required cells.\n       *             @param {string} [extOptions.cell.required.text] - text color of required cells.\n       *         @param {Object} [extOptions.cell.editable] - Styles for editable cells.\n       *             @param {string} [extOptions.cell.editable.background] - background color of the editable cells.\n       *             @param {string} [extOptions.cell.editable.text] - text color of the selected editable cells.\n       *         @param {Object} [extOptions.cell.disabled] - Styles for disabled cells.\n       *             @param {string} [extOptions.cell.disabled.background] - background color of disabled cells.\n       *             @param {string} [extOptions.cell.disabled.text] - text color of disabled cells.\n       *         @param {Object} [extOptions.cell.invalid] - Styles for invalid cells.\n       *             @param {string} [extOptions.cell.invalid.background] - background color of invalid cells.\n       *             @param {string} [extOptions.cell.invalid.text] - text color of invalid cells.\n       *         @param {Object} [extOptions.cell.currentRow] - Styles for cells in a current row.\n       *             @param {string} [extOptions.cell.currentRow.background] - background color of cells in a current row.\n       *             @param {string} [extOptions.cell.currentRow.text] - text color of cells in a current row.\n       *         @param {Object} [extOptions.cell.evenRow] - Styles for cells in even rows.\n       *             @param {string} [extOptions.cell.evenRow.background] - background color of cells in even rows.\n       *             @param {string} [extOptions.cell.evenRow.text] - text color of cells in even rows.\n       *         @param {Object} [extOptions.cell.oddRow] - Styles for cells in even rows.\n       *             @param {string} [extOptions.cell.oddRow.background] - background color of cells in odd rows.\n       *             @param {string} [extOptions.cell.oddRow.text] - text color of cells in odd rows.\n       *         @param {Object} [extOptions.cell.dummy] - Styles for dummy cells.\n       *             @param {string} [extOptions.cell.dummy.background] - background color of dummy cells.\n       * @example\n       * var Grid = tui.Grid; // or require('tui-grid')\n       *\n       * Grid.applyTheme('striped', {\n       *     grid: {\n       *         border: '#aaa',\n       *         text: '#333'\n       *     },\n       *     cell: {\n       *         disabled: {\n       *             text: '#999'\n       *         }\n       *     }\n       * });\n       */\n\n\n      Grid.applyTheme = function (presetName, extOptions) {\n        themeManager.apply(presetName, extOptions);\n      };\n      /**\n       * Set language\n       * @static\n       * @param {string} localeCode - Code to set locale messages and\n       *     this is the language or language-region combination (ex: en-US)\n       * @param {Object} [data] - Messages using in Grid\n       * @example\n       * var Grid = tui.Grid; // or require('tui-grid')\n       *\n       * Grid.setLanguage('en'); // default and set English\n       * Grid.setLanguage('ko'); // set Korean\n       * Grid.setLanguage('en-US', { // set new language\n       *      display: {\n       *          noData: 'No data.',\n       *          loadingData: 'Loading data.',\n       *          resizeHandleGuide: 'You can change the width of the column by mouse drag, ' +\n       *                              'and initialize the width by double-clicking.'\n       *      },\n       *      net: {\n       *          confirmCreate: 'Are you sure you want to create {{count}} data?',\n       *          confirmUpdate: 'Are you sure you want to update {{count}} data?',\n       *          confirmDelete: 'Are you sure you want to delete {{count}} data?',\n       *          confirmModify: 'Are you sure you want to modify {{count}} data?',\n       *          noDataToCreate: 'No data to create.',\n       *          noDataToUpdate: 'No data to update.',\n       *          noDataToDelete: 'No data to delete.',\n       *          noDataToModify: 'No data to modify.',\n       *          failResponse: 'An error occurred while requesting data.\\nPlease try again.'\n       *      }\n       * });\n       */\n\n\n      Grid.setLanguage = function (localeCode, data) {\n        i18n.setLanguage(localeCode, data);\n      };\n\n      module.exports = Grid;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Base class for Views\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var Backbone = __webpack_require__(5);\n      /**\n       * Base class for Views\n       * @module base/view\n       * @ignore\n       */\n\n\n      var View = Backbone.View.extend(\n      /** @lends module:base/view.prototype */\n      {\n        initialize: function initialize() {\n          this._children = [];\n        },\n\n        /**\n         * Add children views\n         * @param {(Object|Array)} views - View instance of Array of view instances\n         * @private\n         */\n        _addChildren: function _addChildren(views) {\n          if (!_.isArray(views)) {\n            views = [views];\n          }\n\n          [].push.apply(this._children, _.compact(views));\n        },\n\n        /**\n         * Render children and returns thier elements as array.\n         * @returns {array.<HTMLElement>} An array of element of children\n         */\n        _renderChildren: function _renderChildren() {\n          var elements = _.map(this._children, function (view) {\n            return view.render().el;\n          });\n\n          return elements;\n        },\n\n        /**\n         * Trigger 'appended' event on child view.\n         * @private\n         */\n        _triggerChildrenAppended: function _triggerChildrenAppended() {\n          _.each(this._children, function (view) {\n            view.trigger('appended');\n          });\n        },\n\n        /**\n         * 자식 View를 제거한 뒤 자신도 제거한다.\n         */\n        destroy: function destroy() {\n          this.stopListening();\n\n          this._destroyChildren();\n\n          this.remove();\n        },\n\n        /**\n         * 등록되어있는 자식 View 들을 제거한다.\n         */\n        _destroyChildren: function _destroyChildren() {\n          if (this._children) {\n            while (this._children.length > 0) {\n              this._children.pop().destroy();\n            }\n          }\n        }\n      });\n      module.exports = View;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n      /***/\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Model Manager\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var ColumnModelData = __webpack_require__(8);\n\n      var TreeRowListData = __webpack_require__(11);\n\n      var RowListData = __webpack_require__(12);\n\n      var DimensionModel = __webpack_require__(21);\n\n      var CoordRowModel = __webpack_require__(22);\n\n      var CoordColumnModel = __webpack_require__(23);\n\n      var CoordConverterModel = __webpack_require__(24);\n\n      var FocusModel = __webpack_require__(25);\n\n      var RenderModel = __webpack_require__(26);\n\n      var SmartRenderModel = __webpack_require__(29);\n\n      var SelectionModel = __webpack_require__(30);\n\n      var SummaryModel = __webpack_require__(31);\n\n      var ClipboardModel = __webpack_require__(32);\n\n      var util = __webpack_require__(17);\n\n      var defaultOptions = {\n        data: [],\n        columns: [],\n        keyColumnName: null,\n        selectType: '',\n        autoNumbering: true,\n        header: {\n          height: 40,\n          complexColumns: []\n        },\n        columnOptions: {\n          minWidth: 50,\n          resizable: true,\n          frozenCount: 0\n        },\n        fitToParentHeight: false,\n        fixedRowHeight: false,\n        fixedHeight: false,\n        showDummyRows: false,\n        virtualScrolling: false,\n        copyOptions: null,\n        scrollX: true,\n        scrollY: true,\n        useClientSort: true,\n        editingEvent: 'dblclick',\n        rowHeight: 'auto',\n        bodyHeight: 'auto',\n        minRowHeight: 40,\n        minBodyHeight: 130,\n        selectionUnit: 'cell'\n      };\n      /**\n       * Model Manager\n       * @module model/manager\n       * @param {Object} options - Options to create models\n       * @param {module/domState} domState - DomState instance\n       * @ignore\n       */\n\n      var ModelManager = snippet.defineClass(\n      /** @lends module:modelManager.prototype */\n      {\n        init: function init(options, domState, domEventBus) {\n          options = $.extend(true, {}, defaultOptions, options);\n          this.gridId = options.gridId;\n          this.columnModel = this._createColumnModel(options);\n          this.dataModel = this._createDataModel(options, domState, domEventBus);\n          this.dimensionModel = this._createDimensionModel(options, domState, domEventBus);\n          this.coordRowModel = this._createCoordRowModel(domState);\n          this.focusModel = this._createFocusModel(options, domState, domEventBus);\n          this.coordColumnModel = this._createCoordColumnModel(options.columnOptions, domEventBus);\n          this.renderModel = this._createRenderModel(options);\n          this.coordConverterModel = this._createCoordConverterModel();\n          this.selectionModel = this._createSelectionModel(options, domEventBus);\n          this.summaryModel = this._createSummaryModel(options.summary);\n          this.clipboardModel = this._createClipboardModel(options, domEventBus);\n        },\n\n        /**\n         * Creates an instance of column model and returns it.\n         * @param  {Object} options - Options\n         * @returns {module:data/columnModel} A new instance\n         * @private\n         */\n        _createColumnModel: function _createColumnModel(options) {\n          return new ColumnModelData({\n            keyColumnName: options.keyColumnName,\n            frozenCount: options.columnOptions.frozenCount,\n            complexHeaderColumns: options.header.complexColumns,\n            copyOptions: options.copyOptions,\n            columns: options.columns,\n            rowHeaders: options.rowHeaders,\n            treeColumnOptions: options.treeColumnOptions\n          });\n        },\n\n        /**\n         * Creates an instance of data model and returns it.\n         * @param  {Object} options - Options\n         * @param  {module:domState} domState - domState\n         * @param  {module:event/domEventBus} domEventBus - domEventBus\n         * @returns {module:data/rowList} - A new instance\n         * @private\n         */\n        _createDataModel: function _createDataModel(options, domState, domEventBus) {\n          var isTreeGrid = this.columnModel.hasTreeColumn();\n          var ListDataModel = isTreeGrid ? TreeRowListData : RowListData;\n          return new ListDataModel([], {\n            gridId: this.gridId,\n            domState: domState,\n            domEventBus: domEventBus,\n            columnModel: this.columnModel,\n            useClientSort: options.useClientSort,\n            publicObject: options.publicObject\n          });\n        },\n\n        /* eslint-disable complexity */\n\n        /**\n         * Creates an instance of dimension model and returns it.\n         * @param  {Object} options - Options\n         * @param  {module:domState} domState - domState\n         * @param  {module:event/domEventBus} domEventBus - domEventBus\n         * @returns {module:model/dimension} - A new instance\n         * @private\n         */\n        _createDimensionModel: function _createDimensionModel(options, domState, domEventBus) {\n          var dimensionModel;\n          var columnOptions = options.columnOptions;\n          var fixedRowHeight = !isNaN(options.rowHeight);\n          var fixedHeight = options.bodyHeight !== 'auto';\n          var minRowHeight = options.minRowHeight;\n          var minBodyHeight = options.minBodyHeight;\n          var rowHeight = fixedRowHeight ? Math.max(minRowHeight, options.rowHeight) : minRowHeight;\n          var bodyHeight = fixedHeight ? Math.max(minBodyHeight, options.bodyHeight) : minBodyHeight;\n          var frozenBorderWidth, attrs;\n\n          if (columnOptions.frozenCount) {\n            frozenBorderWidth = Number(columnOptions.frozenBorderWidth) || 1;\n          } else {\n            frozenBorderWidth = 0;\n          }\n\n          attrs = {\n            headerHeight: options.header.height,\n            bodyHeight: bodyHeight,\n            summaryHeight: options.summary ? options.summary.height : 0,\n            summaryPosition: options.summary ? options.summary.position || 'bottom' : null,\n            rowHeight: rowHeight,\n            fitToParentHeight: options.bodyHeight === 'fitToParent',\n            scrollX: !!options.scrollX,\n            scrollY: !!options.scrollY,\n            fixedRowHeight: fixedRowHeight,\n            fixedHeight: fixedHeight,\n            minRowHeight: minRowHeight,\n            minBodyHeight: minBodyHeight || rowHeight,\n            minimumColumnWidth: columnOptions.minWidth,\n            frozenBorderWidth: frozenBorderWidth\n          };\n\n          if (fixedRowHeight === false && options.virtualScrolling) {\n            util.warning('If the virtualScrolling is set to true, the rowHeight must be set to number type.');\n            attrs.fixedRowHeight = true;\n          }\n\n          dimensionModel = new DimensionModel(attrs, {\n            columnModel: this.columnModel,\n            dataModel: this.dataModel,\n            domState: domState,\n            domEventBus: domEventBus\n          });\n          return dimensionModel;\n        },\n\n        /* eslint-enable complexity */\n\n        /**\n         * Creates an instance of coordRow model and returns it\n         * @param {module:domState} domState - domState\n         * @returns {module:model/coordRow}\n         * @private\n         */\n        _createCoordRowModel: function _createCoordRowModel(domState) {\n          return new CoordRowModel(null, {\n            dataModel: this.dataModel,\n            dimensionModel: this.dimensionModel,\n            domState: domState\n          });\n        },\n\n        /**\n         * Creates an instance of coordColumn model and returns it\n         * @param  {Object} columnOptions - Column options\n         * @param {module:event/domEventBus} domEventBus - domEventBus\n         * @returns {module:model/coordColumnModel}\n         * @private\n         */\n        _createCoordColumnModel: function _createCoordColumnModel(columnOptions, domEventBus) {\n          var attrs = {\n            resizable: columnOptions.resizable\n          };\n          return new CoordColumnModel(attrs, {\n            columnModel: this.columnModel,\n            dimensionModel: this.dimensionModel,\n            domEventBus: domEventBus\n          });\n        },\n\n        /**\n         * Creates an instance of coordConvert model and returns it\n         * @returns {module:model/coordConverterModel}\n         * @private\n         */\n        _createCoordConverterModel: function _createCoordConverterModel() {\n          return new CoordConverterModel(null, {\n            columnModel: this.columnModel,\n            dataModel: this.dataModel,\n            dimensionModel: this.dimensionModel,\n            focusModel: this.focusModel,\n            coordRowModel: this.coordRowModel,\n            renderModel: this.renderModel,\n            coordColumnModel: this.coordColumnModel\n          });\n        },\n\n        /**\n         * Creates an instance of focus model and returns it.\n         * @param  {Object} options - options\n         * @param  {module:domState} domState - DomState instance\n         * @param  {module:event/domState} domEventBus - Dom event bus\n         * @returns {module:model/focus} - A new instance\n         * @private\n         */\n        _createFocusModel: function _createFocusModel(options, domState, domEventBus) {\n          return new FocusModel(null, {\n            columnModel: this.columnModel,\n            dataModel: this.dataModel,\n            coordRowModel: this.coordRowModel,\n            domEventBus: domEventBus,\n            domState: domState,\n            editingEvent: options.editingEvent\n          });\n        },\n\n        /**\n         * Creates an instance of seleciton model and returns it.\n         * @param {Object} options - options\n         * @param {module:event/domEventBus} domEventBus - domEventBus\n         * @returns {module:model/selection} - A new instance\n         * @private\n         */\n        _createSelectionModel: function _createSelectionModel(options, domEventBus) {\n          return new SelectionModel({\n            selectionUnit: options.selectionUnit\n          }, {\n            columnModel: this.columnModel,\n            dataModel: this.dataModel,\n            dimensionModel: this.dimensionModel,\n            coordConverterModel: this.coordConverterModel,\n            coordRowModel: this.coordRowModel,\n            renderModel: this.renderModel,\n            focusModel: this.focusModel,\n            domEventBus: domEventBus\n          });\n        },\n\n        /**\n         * Creates an instance of render model and returns it.\n         * @param  {Object} options - Options\n         * @returns {module:model/render} - A new instance\n         * @private\n         */\n        _createRenderModel: function _createRenderModel(options) {\n          var attrs, renderOptions, Constructor;\n          attrs = {\n            emptyMessage: options.emptyMessage,\n            showDummyRows: options.showDummyRows\n          };\n          renderOptions = {\n            columnModel: this.columnModel,\n            dataModel: this.dataModel,\n            dimensionModel: this.dimensionModel,\n            focusModel: this.focusModel,\n            coordRowModel: this.coordRowModel,\n            coordColumnModel: this.coordColumnModel\n          };\n          Constructor = options.virtualScrolling ? SmartRenderModel : RenderModel;\n          return new Constructor(attrs, renderOptions);\n        },\n\n        /**\n         * Creates an instance of summary model and returns it.\n         * @param  {Object} summaryOptions - summary options\n         * @returns {module:model/summary} - A new instance\n         * @private\n         */\n        _createSummaryModel: function _createSummaryModel(summaryOptions) {\n          if (!summaryOptions) {\n            return null;\n          }\n\n          return new SummaryModel(null, {\n            dataModel: this.dataModel,\n            columnModel: this.columnModel,\n            columnContent: summaryOptions.columnContent,\n            defaultContent: summaryOptions.defaultContent\n          });\n        },\n\n        /**\n         * Creates an instance of clipboard model and returns it\n         * @param {Object} options - options\n         * @param {module:event/domEventBus} domEventBus - domEventBus\n         * @returns {module:model/clipboard}\n         * @private\n         */\n        _createClipboardModel: function _createClipboardModel(options, domEventBus) {\n          return new ClipboardModel(null, {\n            columnModel: this.columnModel,\n            dataModel: this.dataModel,\n            selectionModel: this.selectionModel,\n            renderModel: this.renderModel,\n            focusModel: this.focusModel,\n            copyOptions: options.copyOptions,\n            domEventBus: domEventBus\n          });\n        },\n\n        /**\n         * Destroy\n         */\n        destroy: function destroy() {\n          _.each(this, function (value, property) {\n            if (value && snippet.isFunction(value._destroy)) {\n              value._destroy();\n            }\n\n            if (value && snippet.isFunction(value.stopListening)) {\n              value.stopListening();\n            }\n\n            this[property] = null;\n          }, this);\n        }\n      });\n      module.exports = ModelManager;\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n      /***/\n    },\n    /* 8 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview 컬럼 모델\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var Model = __webpack_require__(9);\n\n      var frameConst = __webpack_require__(10).frame;\n\n      var defaultRowHeaders = {\n        rowNum: {\n          type: 'rowNum',\n          title: 'No.',\n          name: '_number',\n          align: 'center',\n          fixedWidth: true,\n          width: 50,\n          hidden: false\n        },\n        checkbox: {\n          type: 'checkbox',\n          title: '<input type=\"checkbox\" />',\n          name: '_button',\n          align: 'center',\n          fixedWidth: true,\n          width: 50,\n          hidden: false,\n          editOptions: {\n            type: 'mainButton'\n          }\n        },\n        radio: {\n          type: 'radio',\n          title: 'select',\n          name: '_button',\n          align: 'center',\n          fixedWidth: true,\n          width: 50,\n          hidden: false,\n          editOptions: {\n            type: 'mainButton'\n          }\n        }\n      };\n      /**\n       * 컬럼 모델 데이터를 다루는 객체\n       * @module model/data/columnModel\n       * @extends module:base/model\n       * @ignore\n       */\n\n      var ColumnModel = Model.extend(\n      /** @lends module:model/data/columnModel.prototype */\n      {\n        initialize: function initialize() {\n          Model.prototype.initialize.apply(this, arguments);\n          this.textType = {\n            normal: true,\n            text: true,\n            password: true\n          };\n\n          this._setColumns(this.get('rowHeaders'), this.get('columns'));\n\n          this.on('change', this._onChange, this);\n        },\n        defaults: {\n          keyColumnName: null,\n          frozenCount: 0,\n          rowHeaders: [],\n          dataColumns: [],\n          visibleColumns: [],\n          // 이 리스트는 메타컬럼/데이터컬럼 구분하지 않고 저장\n          selectType: '',\n          columnModelMap: {},\n          relationsMap: {},\n          complexHeaderColumns: [],\n          copyOptions: {\n            useFormattedValue: false\n          },\n          treeColumnOptions: {\n            name: null,\n            useIcon: true,\n            useCascadingCheckbox: true\n          }\n        },\n\n        /**\n         * index 에 해당하는 columnModel 을 반환한다.\n         * @param {Number} index    조회할 컬럼모델의 인덱스 값\n         * @param {Boolean} isVisible [isVisible=false] 화면에 노출되는 컬럼모델 기준으로 찾을것인지 여부.\n         * @returns {object} 조회한 컬럼 모델\n         */\n        at: function at(index, isVisible) {\n          var columns = isVisible ? this.getVisibleColumns() : this.get('dataColumns');\n          return columns[index];\n        },\n\n        /**\n         * columnName 에 해당하는 index를 반환한다.\n         * @param {string} columnName   컬럼명\n         * @param {Boolean} isVisible [isVisible=false] 화면에 노출되는 컬럼모델 기준으로 반환할 것인지 여부.\n         * @returns {number} index   컬럼명에 해당하는 인덱스 값\n         */\n        indexOfColumnName: function indexOfColumnName(columnName, isVisible) {\n          var columns;\n\n          if (isVisible) {\n            columns = this.getVisibleColumns();\n          } else {\n            columns = this.get('dataColumns');\n          }\n\n          return _.findIndex(columns, {\n            name: columnName\n          });\n        },\n\n        /**\n         * Returns state that the column is included in left side by column name\n         * @param {String} columnName - Column name\n         * @returns {Boolean} Whether the column is included in left side or not\n         */\n        isLside: function isLside(columnName) {\n          var index = this.indexOfColumnName(columnName, true);\n          var frozenCount = this.getVisibleFrozenCount(false);\n          return index > -1 && index < frozenCount;\n        },\n\n        /**\n         * 화면에 노출되는 (!hidden) 컬럼 모델 리스트를 반환한다.\n         * @param {String} [whichSide] 열고정 영역인지, 열고정이 아닌 영역인지 여부. 지정하지 않았을 경우 전체 visibleList를 반환한다.\n         * @param {boolean} [withMeta=false] 메타컬럼 포함 여부. 지정하지 않으면 데이터컬럼리스트 기준으로 반환한다.\n         * @returns {Array}  조회한 컬럼모델 배열\n         */\n        getVisibleColumns: function getVisibleColumns(whichSide, withMeta) {\n          var startIndex = withMeta ? 0 : this.getVisibleMetaColumnCount();\n          var visibleColumnFixCount = this.getVisibleFrozenCount(withMeta);\n          var columns;\n          whichSide = whichSide && whichSide.toUpperCase();\n\n          if (whichSide === frameConst.L) {\n            columns = this.get('visibleColumns').slice(startIndex, visibleColumnFixCount);\n          } else if (whichSide === frameConst.R) {\n            columns = this.get('visibleColumns').slice(visibleColumnFixCount);\n          } else {\n            columns = this.get('visibleColumns').slice(startIndex);\n          }\n\n          return columns;\n        },\n\n        /**\n         * 현재 보여지고 있는 메타컬럼의 카운트를 반환한다.\n         * @returns {number} count\n         */\n        getVisibleMetaColumnCount: function getVisibleMetaColumnCount() {\n          var models = this.get('rowHeaders');\n          var totalLength = models.length;\n\n          var hiddenLength = _.where(models, {\n            hidden: true\n          }).length;\n\n          return totalLength - hiddenLength;\n        },\n\n        /**\n         * 현재 노출되는 컬럼들 중, 고정된 컬럼들(L-side)의 갯수를 반환한다.\n         * @param {boolean} [withMeta=false] 현재 보여지고 있는 메타컬럼의 count를 합칠지 여부\n         * @returns {number} Visible frozen count\n         */\n        getVisibleFrozenCount: function getVisibleFrozenCount(withMeta) {\n          var count = this.get('frozenCount');\n\n          var fixedColumns = _.first(this.get('dataColumns'), count);\n\n          var visibleFixedColumns, visibleCount;\n          visibleFixedColumns = _.filter(fixedColumns, function (column) {\n            return !column.hidden;\n          });\n          visibleCount = visibleFixedColumns.length;\n\n          if (withMeta) {\n            visibleCount += this.getVisibleMetaColumnCount();\n          }\n\n          return visibleCount;\n        },\n\n        /**\n         * 인자로 받은 columnName 에 해당하는 columnModel 을 반환한다.\n         * @param {String} columnName   컬럼명\n         * @returns {Object} 컬럼명에 해당하는 컬럼모델\n         */\n        getColumnModel: function getColumnModel(columnName) {\n          return this.get('columnModelMap')[columnName];\n        },\n\n        /**\n         * columnName 에 해당하는 컬럼의 타입이 textType 인지 확인한다.\n         * 랜더링시 html 태그 문자열을 제거할때 사용됨.\n         * @param {String} columnName 컬럼명\n         * @returns {boolean} text 타입인지 여부\n         */\n        isTextType: function isTextType(columnName) {\n          return !!this.textType[this.getEditType(columnName)];\n        },\n\n        /**\n         * test the column with given name is a tree column\n         * @param {String} columnName column name to test\n         * @returns {boolean} true if the column is tree column\n         */\n        isTreeType: function isTreeType(columnName) {\n          return this.get('treeColumnOptions').name === columnName;\n        },\n\n        /**\n         * test if any one of columns has a tree column\n         * @returns {boolean} true if it has a tree column\n         */\n        hasTreeColumn: function hasTreeColumn() {\n          return snippet.isString(this.get('treeColumnOptions').name);\n        },\n\n        /**\n         * gets treeColumnOptions.useIcon\n         * @returns {boolean} whether use tree icon\n         */\n        useTreeIcon: function useTreeIcon() {\n          var useIcon = this.get('treeColumnOptions').useIcon;\n          return _.isUndefined(useIcon) ? true : useIcon;\n        },\n\n        /**\n         * Get cascade usage in the tree-grid's checkbox\n         * @returns {boolean} Whether using the cascading checkbox or not\n         */\n        useCascadingCheckbox: function useCascadingCheckbox() {\n          var useCascadingCheckbox = this.get('treeColumnOptions').useCascadingCheckbox;\n          return _.isUndefined(useCascadingCheckbox) ? true : useCascadingCheckbox;\n        },\n\n        /**\n         * 컬럼 모델로부터 editType 을 반환한다.\n         * @param {string} columnName The name of the target column\n         * @returns {string} 해당하는 columnName 의 editType 을 반환한다.\n         */\n        getEditType: function getEditType(columnName) {\n          var columnModel = this.getColumnModel(columnName);\n          var editType = 'normal';\n\n          if (columnName === '_button' || columnName === '_number') {\n            editType = columnName;\n          } else if (columnModel && columnModel.editOptions && columnModel.editOptions.type) {\n            editType = columnModel.editOptions.type;\n          }\n\n          return editType;\n        },\n\n        /**\n         * Whether copying the visible text or not\n         * @param {string} columnName - Column name\n         * @returns {boolena} State\n         */\n        copyVisibleTextOfEditingColumn: function copyVisibleTextOfEditingColumn(columnName) {\n          var columnModel = this.getColumnModel(columnName);\n\n          if (snippet.pick(columnModel, 'editOptions', 'listItems')) {\n            return !!snippet.pick(columnModel, 'copyOptions', 'useListItemText');\n          }\n\n          return false;\n        },\n\n        /**\n         * 인자로 받은 컬럼 모델에서 !hidden을 만족하는 리스트를 추려서 반환한다.\n         * @param {Array} rowHeaders 메타 컬럼 모델 리스트\n         * @param {Array} dataColumns 데이터 컬럼 모델 리스트\n         * @returns {Array} hidden 이 설정되지 않은 전체 컬럼 모델 리스트\n         * @private\n         */\n        _makeVisibleColumns: function _makeVisibleColumns(rowHeaders, dataColumns) {\n          rowHeaders = rowHeaders || this.get('rowHeaders');\n          dataColumns = dataColumns || this.get('dataColumns');\n          return _.filter(rowHeaders.concat(dataColumns), function (item) {\n            return !item.hidden;\n          });\n        },\n\n        /**\n         * 각 columnModel 의 relations 를 모아 주체가 되는 columnName 기준으로 relationsMap 를 생성하여 반환한다.\n         * @param {Array} columns - Column Model List\n         * @returns {{}|{columnName1: Array, columnName1: Array}} columnName 기준으로 생성된 relationsMap\n         * @private\n         */\n        _getRelationListMap: function _getRelationListMap(columns) {\n          var relationsMap = {};\n\n          _.each(columns, function (columnModel) {\n            var columnName = columnModel.name;\n\n            if (columnModel.relations) {\n              relationsMap[columnName] = columnModel.relations;\n            }\n          });\n\n          return relationsMap;\n        },\n\n        /**\n         * ignored 가 true 로 설정된 columnName 의 list 를 반환한다.\n         * @returns {Array} ignored 가 true 로 설정된 columnName 배열.\n         */\n        getIgnoredColumnNames: function getIgnoredColumnNames() {\n          var dataColumns = this.get('dataColumns');\n          var ignoredColumnNames = [];\n\n          _.each(dataColumns, function (columnModel) {\n            if (columnModel.ignored) {\n              ignoredColumnNames.push(columnModel.name);\n            }\n          });\n\n          return ignoredColumnNames;\n        },\n\n        /**\n         * Set column title by columns map\n         * @param {Array} targetColumns - columns to change\n         * @param {object} columnsMap - name and title to change\n         * @private\n         */\n        _changeColumnTitlesByName: function _changeColumnTitlesByName(targetColumns, columnsMap) {\n          _.each(columnsMap, function (value, key) {\n            var idx = _.findIndex(targetColumns, function (data) {\n              return data.name === key;\n            });\n\n            if (idx !== -1) {\n              targetColumns[idx].title = value;\n            }\n          });\n        },\n\n        /**\n         * Set column title by columns map\n         * @param {object} columnsMap - name and title to change\n         * @private\n         */\n        setColumnTitles: function setColumnTitles(columnsMap) {\n          var dataColumns = this.get('dataColumns');\n          var complexHeaderColumns = this.get('complexHeaderColumns');\n\n          this._changeColumnTitlesByName(dataColumns, columnsMap);\n\n          if (complexHeaderColumns.length) {\n            this._changeColumnTitlesByName(complexHeaderColumns, columnsMap);\n          }\n\n          this.trigger('columnModelChange');\n        },\n\n        /**\n         * Set column model by data\n         * @param {array} rowHeaders - Data of row headers\n         * @param {array} columns - Data of columns\n         * @param {number} [frozenCount] Count of frozen column\n         * @private\n         */\n        _setColumns: function _setColumns(rowHeaders, columns, frozenCount) {\n          var relationsMap, visibleColumns, dataColumns;\n\n          if (snippet.isUndefined(frozenCount)) {\n            frozenCount = this.get('frozenCount');\n          }\n\n          rowHeaders = this._getRowHeadersData(rowHeaders);\n          dataColumns = $.extend(true, [], columns);\n          relationsMap = this._getRelationListMap(dataColumns);\n          visibleColumns = this._makeVisibleColumns(rowHeaders, dataColumns);\n          this.set({\n            selectType: this._getSelectType(rowHeaders),\n            rowHeaders: rowHeaders,\n            dataColumns: dataColumns,\n            columnModelMap: _.indexBy(rowHeaders.concat(dataColumns), 'name'),\n            relationsMap: relationsMap,\n            frozenCount: Math.max(0, frozenCount),\n            visibleColumns: visibleColumns\n          }, {\n            silent: true\n          });\n          this.unset('columns', {\n            silent: true\n          });\n          this.trigger('columnModelChange');\n        },\n\n        /**\n         * Get data of row headers\n         * @param {object} options - Options to set each row header\n         * @returns {array} Row headers data\n         * @private\n         */\n        _getRowHeadersData: function _getRowHeadersData(options) {\n          var rowHeadersData = [];\n          var type, isObject;\n          var defaultData;\n          var hasTitle;\n\n          _.each(options, function (data) {\n            isObject = _.isObject(data);\n            type = isObject ? data.type : data;\n            defaultData = defaultRowHeaders[type];\n\n            if (!isObject) {\n              data = defaultData;\n            } else {\n              hasTitle = data.title;\n              data = $.extend({}, defaultData, data);\n            } // Customizing the cell data in the row header\n\n\n            if (data.template && !hasTitle && type !== 'rowNum') {\n              data.title = data.template({\n                className: '',\n                name: '',\n                disabled: '',\n                checked: ''\n              });\n            } // \"checkbox\" and \"radio\" should not exist in duplicate\n\n\n            if (_.findIndex(rowHeadersData, {\n              name: data.name\n            }) === -1) {\n              rowHeadersData.push(data);\n            }\n          }, this);\n\n          return rowHeadersData;\n        },\n\n        /**\n         * Get select type in row headers\n         * @param {array} rowHeaders - Row headers data\n         * @returns {string} Select type\n         * @private\n         */\n        _getSelectType: function _getSelectType(rowHeaders) {\n          var rowHeader = _.findWhere(rowHeaders, {\n            name: '_button'\n          });\n\n          return rowHeader ? rowHeader.type : '';\n        },\n\n        /**\n         * change 이벤트 발생시 핸들러\n         * @param {Object} model change 이벤트가 발생한 model 객체\n         * @private\n         */\n        _onChange: function _onChange(model) {\n          var changed = model.changed;\n          var frozenCount = changed.frozenCount;\n          var columns = changed.columns || this.get('dataColumns');\n          var rowHeaders = changed.rowHeaders || this.get('rowHeaders');\n\n          this._setColumns(rowHeaders, columns, frozenCount);\n        },\n\n        /**\n         * Set 'hidden' property of column model to true or false\n         * @param {Array} columnNames - Column names to set 'hidden' property\n         * @param {boolean} hidden - Hidden flag for setting\n         */\n        setHidden: function setHidden(columnNames, hidden) {\n          var name, names, columnModel, visibleColumns;\n\n          while (columnNames.length) {\n            name = columnNames.shift();\n            columnModel = this.getColumnModel(name);\n\n            if (columnModel) {\n              columnModel.hidden = hidden;\n            } else {\n              names = this.getUnitColumnNamesIfMerged(name);\n              columnNames.push.apply(columnNames, names);\n            }\n          }\n\n          visibleColumns = this._makeVisibleColumns(this.get('rowHeaders'), this.get('dataColumns'));\n          this.set('visibleColumns', visibleColumns, {\n            silent: true\n          });\n          this.trigger('columnModelChange');\n        },\n\n        /**\n         * Get unit column names\n         * @param {string} columnName - columnName\n         * @returns {Array.<string>} Unit column names\n         */\n        getUnitColumnNamesIfMerged: function getUnitColumnNamesIfMerged(columnName) {\n          var complexHeaderColumns = this.get('complexHeaderColumns');\n          var stackForSearch = [];\n          var searchedNames = [];\n          var name, columnModel, complexHeaderColumn;\n          stackForSearch.push(columnName);\n\n          while (stackForSearch.length) {\n            name = stackForSearch.shift();\n            columnModel = this.getColumnModel(name);\n\n            if (columnModel) {\n              searchedNames.push(name);\n            } else {\n              complexHeaderColumn = _.findWhere(complexHeaderColumns, {\n                name: name\n              });\n\n              if (complexHeaderColumn) {\n                stackForSearch.push.apply(stackForSearch, complexHeaderColumn.childNames);\n              }\n            }\n          }\n\n          return _.uniq(searchedNames);\n        },\n\n        /**\n         * Returns the copy option of given column.\n         * @param {string} columnName - column name\n         * @returns {{useFormattedValue: boolean}}\n         */\n        getCopyOptions: function getCopyOptions(columnName) {\n          var columnModel = this.getColumnModel(columnName);\n          return _.extend({}, this.get('copyOptions'), columnModel.copyOptions);\n        },\n\n        /**\n         * Get name of tree column\n         * @returns {string} column name\n         */\n        getTreeColumnName: function getTreeColumnName() {\n          return this.get('treeColumnOptions').name;\n        }\n      });\n      ColumnModel._defaultRowHeaders = defaultRowHeaders;\n      module.exports = ColumnModel;\n      /***/\n    },\n    /* 9 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Base class for Models\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var Backbone = __webpack_require__(5);\n      /**\n       * Base class for Models\n       * @module base/model\n       * @ignore\n       */\n\n\n      var Model = Backbone.Model.extend(\n      /** @lends module:base/model.prototype*/\n      {});\n      module.exports = Model;\n      /***/\n    },\n    /* 10 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n      * @fileoverview Object that conatins constant values\n      * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n      */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var keyCode = {\n        TAB: 9,\n        ENTER: 13,\n        CTRL: 17,\n        ESC: 27,\n        LEFT_ARROW: 37,\n        UP_ARROW: 38,\n        RIGHT_ARROW: 39,\n        DOWN_ARROW: 40,\n        CHAR_A: 65,\n        CHAR_C: 67,\n        CHAR_F: 70,\n        CHAR_R: 82,\n        CHAR_V: 86,\n        LEFT_WINDOW_KEY: 91,\n        F5: 116,\n        BACKSPACE: 8,\n        SPACE: 32,\n        PAGE_UP: 33,\n        PAGE_DOWN: 34,\n        HOME: 36,\n        END: 35,\n        DEL: 46,\n        UNDEFINED: 229\n      };\n      module.exports = {\n        keyCode: keyCode,\n        keyName: _.invert(keyCode),\n        renderState: {\n          LOADING: 'LOADING',\n          DONE: 'DONE',\n          EMPTY: 'EMPTY'\n        },\n        dimension: {\n          CELL_BORDER_WIDTH: 1,\n          TABLE_BORDER_WIDTH: 1,\n          RESIZE_HANDLE_WIDTH: 7,\n          SCROLLBAR_WIDTH: 17,\n          INDENT_WIDTH: 22\n        },\n        frame: {\n          L: 'L',\n          R: 'R'\n        },\n        attrName: {\n          ROW_KEY: 'data-row-key',\n          COLUMN_NAME: 'data-column-name',\n          COLUMN_INDEX: 'data-column-index',\n          EDIT_TYPE: 'data-edit-type',\n          GRID_ID: 'data-grid-id'\n        },\n        themeName: {\n          DEFAULT: 'default',\n          STRIPED: 'striped',\n          CLEAN: 'clean'\n        },\n        selectionType: {\n          CELL: 'CELL',\n          ROW: 'ROW',\n          COLUMN: 'COLUMN'\n        },\n        summaryType: {\n          SUM: 'sum',\n          AVG: 'avg',\n          CNT: 'cnt',\n          MAX: 'max',\n          MIN: 'min'\n        },\n        summaryPosition: {\n          TOP: 'top',\n          BOTTOM: 'bottom'\n        },\n        treeState: {\n          EXPAND: 'EXPAND',\n          COLLAPSE: 'COLLAPSE'\n        },\n        sortingType: {\n          ASC: 'asc',\n          DESC: 'desc'\n        }\n      };\n      /***/\n    },\n    /* 11 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview TreeRowList grid data model implementation\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var util = __webpack_require__(3);\n\n      var RowList = __webpack_require__(12);\n\n      var TreeRow = __webpack_require__(20);\n\n      var TreeRowList;\n      /**\n       * Create empty tree-row data\n       * @returns {object} tree data\n       * @ignore\n       */\n\n      function createEmptyTreeRowData() {\n        return {\n          _treeData: {\n            hasNextSibling: []\n          }\n        };\n      }\n      /**\n       * TreeRowList class implementation\n       * @module model/data/treeModel\n       * @extends module:base/collection\n       * @ignore\n       */\n\n\n      TreeRowList = RowList.extend(\n      /** @lends module:model/data/treeRowList.prototype */\n      {\n        initialize: function initialize() {\n          RowList.prototype.initialize.apply(this, arguments);\n          /**\n           * root row which actually does not exist.\n           * it keeps depth 1 rows as it's children\n           * @type {object}\n           */\n\n          this._rootRow = createEmptyTreeRowData();\n        },\n        model: TreeRow,\n\n        /**\n         * flattened tree row to grid row\n         * process _extraData then set rowSpanData value\n         * this function overrides RowList._formatData to deal with rowKey here\n         *\n         * @param {array|object} data - rowList\n         * @param {object} options - append options\n         * @returns {array} rowList with row\n         * @override\n         * @private\n         */\n        _formatData: function _formatData(data, options) {\n          var rootRow = createEmptyTreeRowData();\n          var flattenedRow = [];\n          var rowList, parentRow, parentRowKey;\n          rowList = _.filter(data, _.isObject);\n          rowList = util.isArray(rowList) ? rowList : [rowList];\n\n          if (options) {\n            // probably an append operation\n            // which requires specific parent row\n            parentRowKey = options.parentRowKey;\n\n            if (_.isNumber(parentRowKey) || _.isString(parentRowKey)) {\n              parentRow = this.get(options.parentRowKey);\n              rootRow._treeData.childrenRowKeys = parentRow.getTreeChildrenRowKeys();\n              rootRow._treeData.hasNextSibling = parentRow.hasTreeNextSibling().slice(0);\n              rootRow.rowKey = options.parentRowKey;\n            } else {\n              // no parent row key means root row\n              rootRow = this._rootRow;\n            }\n          } else {\n            // from setOriginal or setData\n            // which requires to reset root row\n            this._rootRow = rootRow;\n          }\n\n          this._flattenRow(rowList, flattenedRow, [rootRow]);\n\n          if (parentRow) {\n            parentRow.setTreeChildrenRowKeys(rootRow._treeData.childrenRowKeys);\n          }\n\n          _.each(flattenedRow, function (row, i) {\n            if (this.isRowSpanEnable()) {\n              this._setExtraRowSpanData(flattenedRow, i);\n            }\n          }, this);\n\n          return flattenedRow;\n        },\n\n        /**\n         * Flatten nested tree data to 1-depth grid data.\n         * @param {array} treeRows - nested rows having children\n         * @param {array} flattenedRows - flattend rows. you should give an empty array at the initial call of this function\n         * @param {array} ancestors - ancester rows\n         */\n        _flattenRow: function _flattenRow(treeRows, flattenedRows, ancestors) {\n          var parent;\n          var lastSibling = treeRows[treeRows.length - 1];\n          parent = ancestors[ancestors.length - 1];\n          parent._treeData.childrenRowKeys = parent._treeData.childrenRowKeys || [];\n\n          _.each(treeRows, function (row) {\n            // sets rowKey property\n            row = this._baseFormat(row);\n            row._treeData = {\n              parentRowKey: parent.rowKey,\n              hasNextSibling: parent._treeData.hasNextSibling.concat([lastSibling !== row]),\n              childrenRowKeys: row._children ? [] : null\n            };\n\n            parent._treeData.childrenRowKeys.push(row.rowKey);\n\n            flattenedRows.push(row);\n\n            if (util.isArray(row._children)) {\n              this._flattenRow(row._children, flattenedRows, ancestors.concat([row]));\n\n              delete row._children;\n            }\n          }, this);\n        },\n\n        /**\n         * calculate index of given parent row key and offset\n         * @param {number|string} parentRowKey - parent row key\n         * @param {number} offset - offset\n         * @returns {number} - calculated index\n         * @private\n         */\n        _indexOfParentRowKeyAndOffset: function _indexOfParentRowKeyAndOffset(parentRowKey, offset) {\n          var at, parentRow, childrenRowKeys;\n          parentRow = this.get(parentRowKey);\n\n          if (parentRow) {\n            childrenRowKeys = parentRow.getTreeChildrenRowKeys();\n            at = this.indexOf(parentRow);\n          } else {\n            childrenRowKeys = this._rootRow._treeData.childrenRowKeys;\n            at = -1; // root row actually doesn't exist\n          }\n\n          offset = Math.max(0, offset);\n          offset = Math.min(offset, childrenRowKeys.length);\n\n          if (childrenRowKeys.length === 0 || offset === 0) {\n            // first sibling\n            // then the `at` is right after the parent row\n            at = at + 1;\n          } else if (childrenRowKeys.length > offset) {\n            // not the last sibling\n            // right before the next sibling\n            at = this.indexOf(this.get(childrenRowKeys[offset]));\n          } else {\n            // last sibling\n            at = this.indexOf(this.get(childrenRowKeys[childrenRowKeys.length - 1])); // and after all it's descendant rows and itself\n\n            at += this.getTreeDescendantRowKeys(at).length + 1;\n          }\n\n          return at;\n        },\n\n        /**\n         * update hasNextSibling value of previous sibling and of itself\n         * @param {number|string} rowKey - row key\n         * @private\n         */\n        _syncHasTreeNextSiblingData: function _syncHasTreeNextSiblingData(rowKey) {\n          var currentRow = this.get(rowKey);\n          var currentDepth, prevSiblingRow, nextSiblingRow;\n\n          if (!currentRow) {\n            return;\n          }\n\n          currentDepth = currentRow.getTreeDepth();\n          prevSiblingRow = this.get(this.getTreePrevSiblingRowKey(rowKey));\n          nextSiblingRow = this.get(this.getTreeNextSiblingRowKey(rowKey));\n          currentRow.hasTreeNextSibling()[currentDepth - 1] = !!nextSiblingRow;\n\n          if (prevSiblingRow) {\n            prevSiblingRow.hasTreeNextSibling()[currentDepth - 1] = true;\n          }\n        },\n\n        /**\n         * Insert the new row with specified data to the end of table.\n         * @param {array|object} [rowData] - The data for the new row\n         * @param {object} [options] - Options\n         * @param {number|string} [options.parentRowKey] - row key of the parent which appends given rows\n         * @param {number} [options.offset] - offset from first sibling\n         * @param {boolean} [options.focus] - If set to true, move focus to the new row after appending\n         * @returns {Array.<module:model/data/treeTow>} Row model list\n         * @override\n         */\n        appendRow: function appendRow(rowData, options) {\n          var modelList;\n          options = _.extend({\n            at: this._indexOfParentRowKeyAndOffset(options.parentRowKey, options.offset)\n          }, options);\n          modelList = this._appendRow(rowData, options);\n\n          this._syncHasTreeNextSiblingData(modelList[0].get('rowKey'));\n\n          if (modelList.length > 1) {\n            this._syncHasTreeNextSiblingData(modelList[modelList.length - 1].get('rowKey'));\n          }\n\n          this.trigger('add', modelList, options);\n          return modelList;\n        },\n\n        /**\n         * Insert the given data into the very first row of root\n         * @param {array|object} [rowData] - The data for the new row\n         * @param {object} [options] - Options\n         * @param {boolean} [options.focus] - If set to true, move focus to the new row after appending\n         * @returns {Array.<module:model/data/treeTow>} Row model list\n         */\n        prependRow: function prependRow(rowData, options) {\n          options = options || {};\n          options.parentRowKey = null;\n          options.offset = 0;\n          return this.appendRow(rowData, options);\n        },\n        _removeChildFromParent: function _removeChildFromParent(childRowKey) {\n          var parentRowKey = this.get(childRowKey).getTreeParentRowKey();\n          var parentRow = this.get(parentRowKey);\n          var rootTreeData = this._rootRow._treeData;\n\n          if (parentRow) {\n            parentRow.removeTreeChildrenRowKey(childRowKey);\n          } else {\n            rootTreeData.childrenRowKeys = _.filter(rootTreeData.childrenRowKeys, function (rootChildRowKey) {\n              return rootChildRowKey !== childRowKey;\n            }, this);\n          }\n        },\n        _removeRow: function _removeRow(rowKey, options) {\n          this._removeChildFromParent(rowKey);\n\n          RowList.prototype._removeRow.call(this, rowKey, options);\n        },\n\n        /**\n         * remove row of given row key. it will also remove it's descendant\n         * @param {number|string} rowKey - 행 데이터의 고유 키\n         * @param {object} options - 삭제 옵션\n         * @param {boolean} options.removeOriginalData - 원본 데이터도 함께 삭제할 지 여부\n         * @param {boolean} options.keepRowSpanData - rowSpan이 mainRow를 삭제하는 경우 데이터를 유지할지 여부\n         * @override\n         */\n        removeRow: function removeRow(rowKey, options) {\n          var row = this.get(rowKey);\n          var parentRowKey = row.getTreeParentRowKey();\n          var currentIndex = this.indexOf(row);\n          var prevSiblingRowKey = this.getTreePrevSiblingRowKey(rowKey);\n          var descendantRowKeys;\n\n          if (!row) {\n            return;\n          } // remove descendant rows including itself\n\n\n          descendantRowKeys = this.getTreeDescendantRowKeys(rowKey);\n          descendantRowKeys.reverse().push(rowKey);\n\n          _.each(descendantRowKeys, function (descendantRowKey) {\n            this._removeRow(descendantRowKey, options);\n          }, this);\n\n          if (_.isNumber(prevSiblingRowKey) || _.isString(prevSiblingRowKey)) {\n            this._syncHasTreeNextSiblingData(prevSiblingRowKey);\n          }\n\n          if (options && options.removeOriginalData) {\n            this.setOriginalRowList();\n          }\n\n          this.trigger('remove', rowKey, currentIndex, descendantRowKeys, parentRowKey);\n        },\n\n        /**\n         * get row keys of sibling and of itself\n         * @param {number|string} rowKey - row key\n         * @returns {Array.<number|string>} - sibling row keys\n         */\n        getTreeSiblingRowKeys: function getTreeSiblingRowKeys(rowKey) {\n          var parentRow = this.get(this.get(rowKey).getTreeParentRowKey());\n          var childrenRowKeys;\n\n          if (parentRow) {\n            childrenRowKeys = parentRow.getTreeChildrenRowKeys();\n          } else {\n            childrenRowKeys = this._rootRow._treeData.childrenRowKeys.slice(0);\n          }\n\n          return childrenRowKeys;\n        },\n\n        /**\n         * get row key of previous sibling\n         * @param {number|string} rowKey - row key\n         * @returns {number|string} - previous sibling row key\n         */\n        getTreePrevSiblingRowKey: function getTreePrevSiblingRowKey(rowKey) {\n          var siblingRowKeys = this.getTreeSiblingRowKeys(rowKey);\n          var currentIndex = siblingRowKeys.indexOf(rowKey);\n          return currentIndex > 0 ? siblingRowKeys[currentIndex - 1] : null;\n        },\n\n        /**\n         * get row key of next sibling\n         * @param {number|string} rowKey - row key\n         * @returns {number|string} - next sibling row key\n         */\n        getTreeNextSiblingRowKey: function getTreeNextSiblingRowKey(rowKey) {\n          var siblingRowKeys = this.getTreeSiblingRowKeys(rowKey);\n          var currentIndex = siblingRowKeys.indexOf(rowKey);\n          return currentIndex + 1 >= siblingRowKeys.length ? null : siblingRowKeys[currentIndex + 1];\n        },\n\n        /**\n         * get root's child row keys\n         * @returns {Array.<number|string>} - row keys\n         */\n        getRootChildRowKeys: function getRootChildRowKeys() {\n          return this._rootRow._treeData.childrenRowKeys;\n        },\n\n        /**\n         * get tree children of row of given rowKey\n         * @param {number|string} rowKey - row key\n         * @returns {Array.<number|string>} - children of found row\n         */\n        getTreeChildrenRowKeys: function getTreeChildrenRowKeys(rowKey) {\n          var row = this.get(rowKey);\n          return row.getTreeChildrenRowKeys();\n        },\n\n        /**\n         * get tree descendant of row of given rowKey\n         * @param {number|string} rowKey - row key\n         * @returns {Array.<number|string>} - descendant of found row\n         */\n        getTreeDescendantRowKeys: function getTreeDescendantRowKeys(rowKey) {\n          var index = 0;\n          var rowKeys = [rowKey];\n\n          while (index < rowKeys.length) {\n            rowKeys = rowKeys.concat(this.getTreeChildrenRowKeys(rowKeys[index]));\n            index += 1;\n          }\n\n          rowKeys.shift();\n          return rowKeys;\n        },\n\n        /**\n         * expand tree row\n         * @param {number|string} rowKey - row key\n         * @param {boolean} recursive - true for recursively expand all descendant\n         * @returns {Array.<number|string>} - children or descendant of given row\n         */\n        treeExpand: function treeExpand(rowKey, recursive) {\n          var descendantRowKeys = this.getTreeDescendantRowKeys(rowKey);\n          var row = this.get(rowKey);\n          row.setTreeExpanded(true);\n\n          if (recursive) {\n            _.each(descendantRowKeys, function (descendantRowKey) {\n              var descendantRow = this.get(descendantRowKey);\n\n              if (descendantRow.hasTreeChildren()) {\n                descendantRow.setTreeExpanded(true);\n              }\n            }, this);\n          } else {\n            descendantRowKeys = _.filter(descendantRowKeys, function (descendantRowKey) {\n              return this.isTreeVisible(descendantRowKey);\n            }, this);\n          }\n          /**\n           * Occurs when the row having child rows is expanded\n           * @event Grid#expanded\n           * @type {module:event/gridEvent}\n           * @property {number|string} rowKey - rowKey of the expanded row\n           * @property {Array.<number|string>} descendantRowKeys - rowKey list of all descendant rows\n           * @property {Grid} instance - Current grid instance\n           */\n\n\n          this.trigger('expanded', {\n            rowKey: rowKey,\n            descendantRowKeys: descendantRowKeys.slice(0)\n          });\n          return descendantRowKeys;\n        },\n\n        /**\n         * expand all rows\n         */\n        treeExpandAll: function treeExpandAll() {\n          var rootChildRowKeys = this.getRootChildRowKeys();\n          /**\n           * Occurs when all rows having child rows are expanded\n           * @event Grid#expandedAll\n           */\n\n          this.trigger('expandedAll');\n\n          _.each(rootChildRowKeys, function (rootChildRowKey) {\n            this.treeExpand(rootChildRowKey, true, true);\n          }, this);\n        },\n\n        /**\n         * collapse tree row\n         * @param {number|string} rowKey - row key\n         * @param {boolean} recursive - true for recursively expand all descendant\n         * @returns {Array.<number|string>} - children or descendant of given row\n         */\n        treeCollapse: function treeCollapse(rowKey, recursive) {\n          var row = this.get(rowKey);\n          var descendantRowKeys = this.getTreeDescendantRowKeys(rowKey);\n\n          if (recursive) {\n            _.each(descendantRowKeys, function (descendantRowKey) {\n              var descendantRow = this.get(descendantRowKey);\n\n              if (descendantRow.hasTreeChildren()) {\n                descendantRow.setTreeExpanded(false);\n              }\n            }, this);\n          } else {\n            descendantRowKeys = _.filter(descendantRowKeys, function (descendantRowKey) {\n              return this.isTreeVisible(descendantRowKey);\n            }, this);\n          }\n\n          row.setTreeExpanded(false);\n          /**\n           * Occurs when the row having child rows is collapsed\n           * @event Grid#collapsed\n           * @type {module:event/gridEvent}\n           * @property {number|string} rowKey - rowKey of the collapsed row\n           * @property {Array.<number|string>} descendantRowKeys - rowKey list of all descendant rows\n           * @property {Grid} instance - Current grid instance\n           */\n\n          this.trigger('collapsed', {\n            rowKey: rowKey,\n            descendantRowKeys: descendantRowKeys.slice(0)\n          });\n          return descendantRowKeys;\n        },\n\n        /**\n         * collapse all rows\n         */\n        treeCollapseAll: function treeCollapseAll() {\n          var rootChildRowKeys = this.getRootChildRowKeys();\n          /**\n           * Occurs when all rows having child rows are collapsed\n           * @event Grid#collapsedAll\n           */\n\n          this.trigger('collapsedAll');\n\n          _.each(rootChildRowKeys, function (rootChildRowKey) {\n            this.treeCollapse(rootChildRowKey, true);\n          }, this);\n        },\n\n        /**\n         * get the parent of the row which has the given row key\n         * @param {number|string} rowKey - row key\n         * @returns {TreeRow} - the parent row\n         */\n        getTreeParent: function getTreeParent(rowKey) {\n          var row = this.get(rowKey);\n\n          if (!row) {\n            return null;\n          }\n\n          return this.get(row.getTreeParentRowKey());\n        },\n\n        /**\n         * get the ancestors of the row which has the given row key\n         * @param {number|string} rowKey - row key\n         * @returns {Array.<TreeRow>} - the ancestor rows\n         */\n        getTreeAncestors: function getTreeAncestors(rowKey) {\n          var ancestors = [];\n          var row = this.getTreeParent(rowKey);\n\n          while (row) {\n            ancestors.push(row);\n            row = this.getTreeParent(row.get('rowKey'));\n          }\n\n          return ancestors.reverse();\n        },\n\n        /**\n         * get the children of the row which has the given row key\n         * @param {number|string} rowKey - row key\n         * @returns {Array.<TreeRow>} - the children rows\n         */\n        getTreeChildren: function getTreeChildren(rowKey) {\n          var childrenRowKeys = this.getTreeChildrenRowKeys(rowKey);\n          return _.map(childrenRowKeys, function (childRowKey) {\n            return this.get(childRowKey);\n          }, this);\n        },\n\n        /**\n         * get the descendants of the row which has the given row key\n         * @param {number|string} rowKey - row key\n         * @returns {Array.<TreeRow>} - the descendant rows\n         */\n        getTreeDescendants: function getTreeDescendants(rowKey) {\n          var descendantRowKeys = this.getTreeDescendantRowKeys(rowKey);\n          return _.map(descendantRowKeys, function (descendantRowKey) {\n            return this.get(descendantRowKey);\n          }, this);\n        },\n\n        /**\n         * get the depth of the row which has the given row key\n         * @param {number|string} rowKey - row key\n         * @returns {number} - the depth\n         */\n        getTreeDepth: function getTreeDepth(rowKey) {\n          var row = this.get(rowKey);\n          var depth;\n\n          if (row) {\n            return row.getTreeDepth();\n          }\n\n          return depth;\n        },\n\n        /**\n         * test if the row of given key should be visible\n         * @param {string|number} rowKey - row key to test\n         * @returns {boolean} - true if visible\n         */\n        isTreeVisible: function isTreeVisible(rowKey) {\n          var visible = true;\n\n          _.each(this.getTreeAncestors(rowKey), function (ancestor) {\n            visible = visible && ancestor.getTreeExpanded();\n          }, this);\n\n          return visible;\n        },\n\n        /**\n         * Check whether the row is visible or not\n         * @returns {boolean} state\n         * @override\n         * @todo Change the method name from isTreeVisible to isVisibleRow\n         */\n        isVisibleRow: function isVisibleRow(rowKey) {\n          return this.isTreeVisible(rowKey);\n        },\n\n        /**\n         * Check the checkbox input in the row header\n         * @param {number} rowKey - Current row key\n         * @override\n         */\n        check: function check(rowKey) {\n          var selectType = this.columnModel.get('selectType');\n\n          if (selectType === 'radio') {\n            this.uncheckAll();\n          }\n\n          this._setCheckedState(rowKey, true);\n        },\n\n        /**\n         * Uncheck the checkbox input in the row header\n         * @param {number} rowKey - Current row key\n         * @override\n         */\n        uncheck: function uncheck(rowKey) {\n          this._setCheckedState(rowKey, false);\n        },\n\n        /**\n         * Set checked state by using a cascading option\n         * @param {number} rowKey - Current row key\n         * @param {boolean} state - Whether checking the input button or not\n         * @private\n         */\n        _setCheckedState: function _setCheckedState(rowKey, state) {\n          var useCascadingCheckbox = this.columnModel.useCascadingCheckbox();\n          this.setValue(rowKey, '_button', state);\n\n          if (useCascadingCheckbox) {\n            this._updateDecendantsCheckedState(rowKey, state);\n\n            this._updateAncestorsCheckedState(rowKey);\n          }\n        },\n\n        /**\n         * Update checked state of all descendant rows\n         * @param {number} rowKey - Current row key\n         * @param {boolean} state - Whether checking the input button or not\n         * @private\n         */\n        _updateDecendantsCheckedState: function _updateDecendantsCheckedState(rowKey, state) {\n          var descendants = this.getTreeDescendants(rowKey);\n\n          _.each(descendants, function (descendantRowKey) {\n            this.setValue(descendantRowKey, '_button', state);\n          }, this);\n        },\n\n        /**\n         * Update checked state of all ancestor rows\n         * @param {number} rowKey - Current row key\n         * @param {boolean} state - Whether checking the input button or not\n         * @private\n         */\n        _updateAncestorsCheckedState: function _updateAncestorsCheckedState(rowKey) {\n          var parentRowKey = this.get(rowKey).getTreeParentRowKey();\n\n          while (parentRowKey > -1) {\n            this._setCheckedStateToParent(parentRowKey);\n\n            parentRowKey = this.get(parentRowKey).getTreeParentRowKey();\n          }\n        },\n\n        /**\n         * Set checked state of the parent row according to the checked children rows\n         * @param {number} rowKey - Current row key\n         * @private\n         */\n        _setCheckedStateToParent: function _setCheckedStateToParent(rowKey) {\n          var childernRowKeys = this.get(rowKey).getTreeChildrenRowKeys();\n          var checkedChildrenCnt = 0;\n          var checkedState;\n\n          _.each(childernRowKeys, function (childRowKey) {\n            if (this.get(childRowKey).get('_button')) {\n              checkedChildrenCnt += 1;\n            }\n          }, this);\n\n          checkedState = checkedChildrenCnt === childernRowKeys.length;\n          this.setValue(rowKey, '_button', checkedState);\n        }\n      });\n      module.exports = TreeRowList;\n      /***/\n    },\n    /* 12 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Grid 의 Data Source 에 해당하는 Collection 정의\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var Collection = __webpack_require__(13);\n\n      var constMap = __webpack_require__(10);\n\n      var Row = __webpack_require__(14);\n\n      var GridEvent = __webpack_require__(16);\n\n      var sortingType = constMap.sortingType;\n      /**\n       * Raw 데이터 RowList 콜렉션. (DataSource)\n       * Grid.setData 를 사용하여 콜렉션을 설정한다.\n       * @module model/data/rowList\n       * @extends module:base/collection\n       * @param {Array} models - 콜랙션에 추가할 model 리스트\n       * @param {Object} options - 생성자의 option 객체\n       * @ignore\n       */\n\n      var RowList = Collection.extend(\n      /** @lends module:model/data/rowList.prototype */\n      {\n        initialize: function initialize(models, options) {\n          Collection.prototype.initialize.apply(this, arguments);\n\n          _.assign(this, {\n            columnModel: options.columnModel,\n            domState: options.domState,\n            gridId: options.gridId,\n            lastRowKey: -1,\n            originalRows: [],\n            originalRowMap: {},\n            startIndex: options.startIndex || 1,\n            sortOptions: {\n              columnName: 'rowKey',\n              ascending: true,\n              useClient: _.isBoolean(options.useClientSort) ? options.useClientSort : true\n            },\n\n            /**\n             * Whether the all rows are disabled.\n             * This state is not related to individual state of each rows.\n             * @type {Boolean}\n             */\n            disabled: false,\n            publicObject: options.publicObject\n          });\n\n          if (!this.sortOptions.useClient) {\n            this.comparator = null;\n          }\n\n          if (options.domEventBus) {\n            this.listenTo(options.domEventBus, 'click:headerCheck', this._onClickHeaderCheck);\n            this.listenTo(options.domEventBus, 'click:headerSort', this._onClickHeaderSort);\n          }\n        },\n        model: Row,\n\n        /**\n         * Backbone 이 collection 생성 시 내부적으로 parse 를 호출하여 데이터를 포멧에 맞게 파싱한다.\n         * @param {Array} data  원본 데이터\n         * @returns {Array}  파싱하여 가공된 데이터\n         */\n        parse: function parse(data) {\n          data = data && data.contents || data;\n          return this._formatData(data);\n        },\n\n        /**\n         * Event handler for 'click:headerCheck' event on domEventBus\n         * @param {module:event/gridEvent} ev - GridEvent\n         * @private\n         */\n        _onClickHeaderCheck: function _onClickHeaderCheck(ev) {\n          if (ev.checked) {\n            this.checkAll();\n          } else {\n            this.uncheckAll();\n          }\n        },\n\n        /**\n         * Event handler for 'click:headerSort' event on domEventBus\n         * @param {module:event/gridEvent} ev - GridEvent\n         * @private\n         */\n        _onClickHeaderSort: function _onClickHeaderSort(ev) {\n          var asc;\n\n          if (ev.sortingType && this.sortOptions.columnName !== ev.columnName) {\n            asc = ev.sortingType === sortingType.ASC;\n          }\n\n          this.sortByField(ev.columnName, asc);\n        },\n\n        /**\n         * 데이터의 _extraData 를 분석하여, Model 에서 사용할 수 있도록 가공한다.\n         * _extraData 필드에 rowSpanData 를 추가한다.\n         * @param {Array} data  가공할 데이터\n         * @returns {Array} 가공된 데이터\n         * @private\n         */\n        _formatData: function _formatData(data) {\n          var rowList = _.filter(data, _.isObject);\n\n          _.each(rowList, function (row, i) {\n            rowList[i] = this._baseFormat(rowList[i]);\n\n            if (this.isRowSpanEnable()) {\n              this._setExtraRowSpanData(rowList, i);\n            }\n          }, this);\n\n          return rowList;\n        },\n\n        /**\n         * row 를 기본 포멧으로 wrapping 한다.\n         * 추가적으로 rowKey 를 할당하고, rowState 에 따라 checkbox 의 값을 할당한다.\n         *\n         * @param {object} row  대상 row 데이터\n         * @param {number} index    해당 row 의 인덱스 정보. rowKey 를 자동 생성할 경우 사용된다.\n         * @returns {object} 가공된 row 데이터\n         * @private\n         */\n        _baseFormat: function _baseFormat(row) {\n          var defaultExtraData = {\n            rowSpan: null,\n            rowSpanData: null,\n            rowState: null\n          },\n              keyColumnName = this.columnModel.get('keyColumnName'),\n              rowKey = keyColumnName === null ? this._createRowKey() : row[keyColumnName];\n          row._extraData = $.extend(defaultExtraData, row._extraData);\n          row._button = row._extraData.rowState === 'CHECKED';\n          row.rowKey = rowKey;\n          return row;\n        },\n\n        /**\n         * 새로운 rowKey를 생성해서 반환한다.\n         * @returns {number} 생성된 rowKey\n         * @private\n         */\n        _createRowKey: function _createRowKey() {\n          this.lastRowKey += 1;\n          return this.lastRowKey;\n        },\n\n        /**\n         * 랜더링시 사용될 extraData 필드에 rowSpanData 값을 세팅한다.\n         * @param {Array} rowList - 전체 rowList 배열. rowSpan 된 경우 자식 row 의 데이터도 가공해야 하기 때문에 전체 list 를 인자로 넘긴다.\n         * @param {number} index - 해당 배열에서 extraData 를 설정할 배열\n         * @returns {Array} rowList - 가공된 rowList\n         * @private\n         */\n        _setExtraRowSpanData: function _setExtraRowSpanData(rowList, index) {\n          var row = rowList[index],\n              rowSpan = row && row._extraData && row._extraData.rowSpan,\n              rowKey = row && row.rowKey,\n              subCount,\n              childRow,\n              i;\n\n          function hasRowSpanData(row, columnName) {\n            // eslint-disable-line no-shadow, require-jsdoc\n            var extraData = row._extraData;\n            return !!(extraData.rowSpanData && extraData.rowSpanData[columnName]);\n          }\n\n          function setRowSpanData(row, columnName, rowSpanData) {\n            // eslint-disable-line no-shadow, require-jsdoc\n            var extraData = row._extraData;\n            extraData.rowSpanData = extraData && extraData.rowSpanData || {};\n            extraData.rowSpanData[columnName] = rowSpanData;\n            return extraData;\n          }\n\n          if (rowSpan) {\n            _.each(rowSpan, function (count, columnName) {\n              if (!hasRowSpanData(row, columnName)) {\n                setRowSpanData(row, columnName, {\n                  count: count,\n                  isMainRow: true,\n                  mainRowKey: rowKey\n                }); // rowSpan 된 row 의 자식 rowSpanData 를 가공한다.\n\n                subCount = -1;\n\n                for (i = index + 1; i < index + count; i += 1) {\n                  childRow = rowList[i];\n                  childRow[columnName] = row[columnName];\n                  childRow._extraData = childRow._extraData || {};\n                  setRowSpanData(childRow, columnName, {\n                    count: subCount,\n                    isMainRow: false,\n                    mainRowKey: rowKey\n                  });\n                  subCount -= 1;\n                }\n              }\n            });\n          }\n\n          return rowList;\n        },\n\n        /**\n         * originalRows 와 originalRowMap 을 생성한다.\n         * @param {Array} [rowList] rowList 가 없을 시 현재 collection 데이터를 originalRows 로 저장한다.\n         * @returns {Array} format 을 거친 데이터 리스트.\n         */\n        setOriginalRowList: function setOriginalRowList(rowList) {\n          this.originalRows = rowList ? this._formatData(rowList) : this.toJSON();\n          this.originalRowMap = _.indexBy(this.originalRows, 'rowKey');\n          return this.originalRows;\n        },\n\n        /**\n         * 원본 데이터 리스트를 반환한다.\n         * @param {boolean} [isClone=true]  데이터 복제 여부.\n         * @returns {Array}  원본 데이터 리스트 배열.\n         */\n        getOriginalRowList: function getOriginalRowList(isClone) {\n          isClone = _.isUndefined(isClone) ? true : isClone;\n          return isClone ? _.clone(this.originalRows) : this.originalRows;\n        },\n\n        /**\n         * 원본 row 데이터를 반환한다.\n         * @param {(Number|String)} rowKey  데이터의 키값\n         * @returns {Object} 해당 행의 원본 데이터값\n         */\n        getOriginalRow: function getOriginalRow(rowKey) {\n          return _.clone(this.originalRowMap[rowKey]);\n        },\n\n        /**\n         * rowKey 와 columnName 에 해당하는 원본 데이터를 반환한다.\n         * @param {(Number|String)} rowKey  데이터의 키값\n         * @param {String} columnName   컬럼명\n         * @returns {(Number|String)}    rowKey 와 컬럼명에 해당하는 셀의 원본 데이터값\n         */\n        getOriginal: function getOriginal(rowKey, columnName) {\n          return _.clone(this.originalRowMap[rowKey][columnName]);\n        },\n\n        /**\n         * mainRowKey 를 반환한다.\n         * @param {(Number|String)} rowKey  데이터의 키값\n         * @param {String} columnName   컬럼명\n         * @returns {(Number|String)}    rowKey 와 컬럼명에 해당하는 셀의 main row 키값\n         */\n        getMainRowKey: function getMainRowKey(rowKey, columnName) {\n          var row = this.get(rowKey),\n              rowSpanData;\n\n          if (this.isRowSpanEnable()) {\n            rowSpanData = row && row.getRowSpanData(columnName);\n            rowKey = rowSpanData ? rowSpanData.mainRowKey : rowKey;\n          }\n\n          return rowKey;\n        },\n\n        /**\n         * rowKey 에 해당하는 index를 반환한다.\n         * @param {(Number|String)} rowKey 데이터의 키값\n         * @returns {Number} 키값에 해당하는 row의 인덱스\n         */\n        indexOfRowKey: function indexOfRowKey(rowKey) {\n          return this.indexOf(this.get(rowKey));\n        },\n\n        /**\n         * rowSpan 이 적용되어야 하는지 여부를 반환한다.\n         * 랜더링시 사용된다.\n         * - sorted, 혹은 filterd 된 경우 false 를 리턴한다.\n         * @returns {boolean}    랜더링 시 rowSpan 을 해야하는지 여부\n         */\n        isRowSpanEnable: function isRowSpanEnable() {\n          return !this.isSortedByField();\n        },\n\n        /**\n         * 현재 RowKey가 아닌 다른 컬럼에 의해 정렬된 상태인지 여부를 반환한다.\n         * @returns {Boolean}    정렬된 상태인지 여부\n         */\n        isSortedByField: function isSortedByField() {\n          return this.sortOptions.columnName !== 'rowKey';\n        },\n\n        /**\n         * 정렬옵션 객체의 값을 변경하고, 변경된 값이 있을 경우 sortChanged 이벤트를 발생시킨다.\n         * @param {string} columnName 정렬할 컬럼명\n         * @param {boolean} ascending 오름차순 여부\n         * @param {boolean} requireFetch 서버 데이타의 갱신이 필요한지 여부\n         */\n        setSortOptionValues: function setSortOptionValues(columnName, ascending, requireFetch) {\n          var options = this.sortOptions,\n              isChanged = false;\n\n          if (_.isUndefined(columnName)) {\n            columnName = 'rowKey';\n          }\n\n          if (_.isUndefined(ascending)) {\n            ascending = true;\n          }\n\n          if (options.columnName !== columnName || options.ascending !== ascending) {\n            isChanged = true;\n          }\n\n          options.columnName = columnName;\n          options.ascending = ascending;\n\n          if (isChanged) {\n            this.trigger('sortChanged', {\n              columnName: columnName,\n              ascending: ascending,\n              requireFetch: requireFetch\n            });\n          }\n        },\n\n        /**\n         * 주어진 컬럼명을 기준으로 오름/내림차순 정렬한다.\n         * @param {string} columnName 정렬할 컬럼명\n         * @param {boolean} ascending 오름차순 여부\n         */\n        sortByField: function sortByField(columnName, ascending) {\n          var options = this.sortOptions;\n\n          if (_.isUndefined(ascending)) {\n            ascending = options.columnName === columnName ? !options.ascending : true;\n          }\n\n          this.setSortOptionValues(columnName, ascending, !options.useClient);\n\n          if (options.useClient) {\n            this.sort();\n          }\n        },\n\n        /**\n         * rowList 를 반환한다.\n         * @param {boolean} [checkedOnly=false] true 로 설정된 경우 checked 된 데이터 대상으로 비교 후 반환한다.\n         * @param {boolean} [withRawData=false] true 로 설정된 경우 내부 연산용 데이터 제거 필터링을 거치지 않는다.\n         * @returns {Array} Row List\n         */\n        getRows: function getRows(checkedOnly, withRawData) {\n          var rows, checkedRows;\n\n          if (checkedOnly) {\n            checkedRows = this.where({\n              '_button': true\n            });\n            rows = [];\n\n            _.each(checkedRows, function (checkedRow) {\n              rows.push(checkedRow.attributes);\n            }, this);\n          } else {\n            rows = this.toJSON();\n          }\n\n          return withRawData ? rows : this._removePrivateProp(rows);\n        },\n\n        /**\n         * Finds rows by conditions\n         * @param {Object|Function} conditions - object (key: column name, value: column value) or\n         *     function that check the value and returns true/false result to find rows\n         * @returns {Array} Row list\n         */\n        findRows: function findRows(conditions) {\n          var foundRows;\n\n          if (_.isFunction(conditions)) {\n            foundRows = this.filter(function (row) {\n              return conditions(row.toJSON());\n            });\n          } else {\n            foundRows = this.where(conditions);\n          }\n\n          return _.map(foundRows, function (row) {\n            return row.toJSON();\n          });\n        },\n\n        /**\n         * row Data 값에 변경이 발생했을 경우, sorting 되지 않은 경우에만\n         * rowSpan 된 데이터들도 함께 update 한다.\n         *\n         * @param {object} row row 모델\n         * @param {String} columnName   변경이 발생한 컬럼명\n         * @param {(String|Number)} value 변경된 값\n         */\n        syncRowSpannedData: function syncRowSpannedData(row, columnName, value) {\n          var index, rowSpanData, i; // 정렬 되지 않았을 때만 rowSpan 된 데이터들도 함께 update 한다.\n\n          if (this.isRowSpanEnable()) {\n            rowSpanData = row.getRowSpanData(columnName);\n\n            if (!rowSpanData.isMainRow) {\n              this.get(rowSpanData.mainRowKey).set(columnName, value);\n            } else {\n              index = this.indexOfRowKey(row.get('rowKey'));\n\n              for (i = 0; i < rowSpanData.count - 1; i += 1) {\n                this.at(i + 1 + index).set(columnName, value);\n              }\n            }\n          }\n        },\n\n        /* eslint-disable complexity */\n\n        /**\n         * Backbone 에서 sort() 실행시 내부적으로 사용되는 메소드.\n         * @param {Row} a 비교할 앞의 모델\n         * @param {Row} b 비교할 뒤의 모델\n         * @returns {number} a가 b보다 작으면 -1, 같으면 0, 크면 1. 내림차순이면 반대.\n         */\n        comparator: function comparator(a, b) {\n          var columnName = this.sortOptions.columnName;\n          var ascending = this.sortOptions.ascending;\n          var valueA = a.get(columnName);\n          var valueB = b.get(columnName);\n          var isEmptyA = _.isNull(valueA) || _.isUndefined(valueA) || valueA === '';\n          var isEmptyB = _.isNull(valueB) || _.isUndefined(valueB) || valueB === '';\n          var result = 0;\n\n          if (isEmptyA && !isEmptyB) {\n            result = -1;\n          } else if (!isEmptyA && isEmptyB) {\n            result = 1;\n          } else if (valueA < valueB) {\n            result = -1;\n          } else if (valueA > valueB) {\n            result = 1;\n          }\n\n          if (!ascending) {\n            result = -result;\n          }\n\n          return result;\n        },\n\n        /* eslint-enable complexity */\n\n        /**\n         * rowList 에서 내부에서만 사용하는 property 를 제거하고 반환한다.\n         * @param {Array} rowList   내부에 설정된 rowList 배열\n         * @returns {Array}  private 프로퍼티를 제거한 결과값\n         * @private\n         */\n        _removePrivateProp: function _removePrivateProp(rowList) {\n          return _.map(rowList, function (row) {\n            return _.omit(row, Row.privateProperties);\n          });\n        },\n        _removeRow: function _removeRow(rowKey, options) {\n          var row = this.get(rowKey);\n          var rowSpanData, nextRow, removedData, currentIndex;\n\n          if (!row) {\n            return -1;\n          }\n\n          if (options && options.keepRowSpanData) {\n            removedData = _.clone(row.attributes);\n          }\n\n          currentIndex = this.indexOf(row);\n          rowSpanData = _.clone(row.getRowSpanData());\n          nextRow = this.at(currentIndex + 1);\n          this.remove(row, {\n            silent: true\n          });\n\n          this._syncRowSpanDataForRemove(rowSpanData, nextRow, removedData);\n\n          return currentIndex;\n        },\n\n        /**\n         * rowKey 에 해당하는 그리드 데이터를 삭제한다.\n         * @param {(Number|String)} rowKey - 행 데이터의 고유 키\n         * @param {object} options - 삭제 옵션\n         * @param {boolean} options.removeOriginalData - 원본 데이터도 함께 삭제할 지 여부\n         * @param {boolean} options.keepRowSpanData - rowSpan이 mainRow를 삭제하는 경우 데이터를 유지할지 여부\n         */\n        removeRow: function removeRow(rowKey, options) {\n          var currentIndex = this._removeRow(rowKey, options);\n\n          if (options && options.removeOriginalData) {\n            this.setOriginalRowList();\n          }\n\n          this.trigger('remove', rowKey, currentIndex);\n        },\n\n        /**\n         * 삭제된 행에 rowSpan이 적용되어 있었을 때, 관련된 행들의 rowSpan데이터를 갱신한다.\n         * @param {object} rowSpanData - 삭제된 행의 rowSpanData\n         * @param {Row} nextRow - 삭제된 다음 행의 모델\n         * @param {object} [removedData] - 삭제된 행의 데이터 (삭제옵션의 keepRowSpanData가 true인 경우에만 넘겨짐)\n         * @private\n         */\n        _syncRowSpanDataForRemove: function _syncRowSpanDataForRemove(rowSpanData, nextRow, removedData) {\n          if (!rowSpanData) {\n            return;\n          }\n\n          _.each(rowSpanData, function (data, columnName) {\n            var mainRowSpanData = {},\n                mainRow,\n                startOffset,\n                spanCount;\n\n            if (data.isMainRow) {\n              if (data.count === 1) {\n                // if isMainRow is true and count is 1, rowSpanData is meaningless\n                return;\n              }\n\n              mainRow = nextRow;\n              spanCount = data.count - 1;\n              startOffset = 1;\n\n              if (spanCount > 1) {\n                mainRowSpanData.mainRowKey = mainRow.get('rowKey');\n                mainRowSpanData.isMainRow = true;\n              }\n\n              mainRow.set(columnName, removedData ? removedData[columnName] : '', {\n                silent: true\n              });\n            } else {\n              mainRow = this.get(data.mainRowKey);\n              spanCount = mainRow.getRowSpanData(columnName).count - 1;\n              startOffset = -data.count;\n            }\n\n            if (spanCount > 1) {\n              mainRowSpanData.count = spanCount;\n              mainRow.setRowSpanData(columnName, mainRowSpanData);\n\n              this._updateSubRowSpanData(mainRow, columnName, startOffset, spanCount);\n            } else {\n              mainRow.setRowSpanData(columnName, null);\n            }\n          }, this);\n        },\n\n        /**\n         * append, prepend 시 사용할 dummy row를 생성한다.\n         * @returns {Object} 값이 비어있는 더미 row 데이터\n         * @private\n         */\n        _createDummyRow: function _createDummyRow() {\n          var columns = this.columnModel.get('dataColumns');\n          var data = {};\n\n          _.each(columns, function (columnModel) {\n            data[columnModel.name] = '';\n          }, this);\n\n          return data;\n        },\n        _appendRow: function _appendRow(rowData, options) {\n          var modelList = this._createModelList(rowData, options);\n\n          this.add(modelList, {\n            at: options.at,\n            add: true,\n            silent: true\n          });\n\n          this._syncRowSpanDataForAppend(options.at, modelList.length, options.extendPrevRowSpan);\n\n          return modelList;\n        },\n\n        /**\n         * Insert the new row with specified data to the end of table.\n         * @param {(Array|Object)} [rowData] - The data for the new row\n         * @param {Object} [options] - Options\n         * @param {Number} [options.at] - The index at which new row will be inserted\n         * @param {Boolean} [options.extendPrevRowSpan] - If set to true and the previous row at target index\n         *        has a rowspan data, the new row will extend the existing rowspan data.\n         * @param {Boolean} [options.focus] - If set to true, move focus to the new row after appending\n         * @returns {Array.<module:model/data/row>} Row model list\n         */\n        appendRow: function appendRow(rowData, options) {\n          var modelList;\n          options = _.extend({\n            at: this.length\n          }, options);\n          modelList = this._appendRow(rowData, options);\n          this.trigger('add', modelList, options);\n          return modelList;\n        },\n\n        /**\n         * 현재 rowList 에 최상단에 데이터를 append 한다.\n         * @param {Object} rowData  prepend 할 행 데이터\n         * @param {object} [options] - Options\n         * @param {boolean} [options.focus] - If set to true, move focus to the new row after appending\n         * @returns {Array.<module:model/data/row>} Row model list\n         */\n        prependRow: function prependRow(rowData, options) {\n          options = options || {};\n          options.at = 0;\n          return this.appendRow(rowData, options);\n        },\n\n        /**\n         * rowKey에 해당하는 행의 데이터를 리턴한다. isJsonString을 true로 설정하면 결과를 json객체로 변환하여 리턴한다.\n         * @param {(Number|String)} rowKey  행 데이터의 고유 키\n         * @param {Boolean} [isJsonString=false]  true 일 경우 JSON String 으로 반환한다.\n         * @returns {Object} 행 데이터\n         */\n        getRowData: function getRowData(rowKey, isJsonString) {\n          var row = this.get(rowKey),\n              rowData = row ? row.toJSON() : null;\n          return isJsonString ? JSON.stringify(rowData) : rowData;\n        },\n\n        /**\n         * 그리드 전체 데이터 중에서 index에 해당하는 순서의 데이터 객체를 리턴한다.\n         * @param {Number} index 행의 인덱스\n         * @param {Boolean} [isJsonString=false]  true 일 경우 JSON String 으로 반환한다.\n         * @returns {Object} 행 데이터\n         */\n        getRowDataAt: function getRowDataAt(index, isJsonString) {\n          var row = this.at(index),\n              rowData = row ? row.toJSON() : null;\n          return isJsonString ? JSON.stringify(row) : rowData;\n        },\n\n        /**\n         * rowKey 와 columnName 에 해당하는 값을 반환한다.\n         * @param {(Number|String)} rowKey    행 데이터의 고유 키\n         * @param {String} columnName   컬럼 이름\n         * @param {boolean} [isOriginal]  원본 데이터 리턴 여부\n         * @returns {(Number|String|undefined)}    조회한 셀의 값.\n         */\n        getValue: function getValue(rowKey, columnName, isOriginal) {\n          var value, row;\n\n          if (isOriginal) {\n            value = this.getOriginal(rowKey, columnName);\n          } else {\n            row = this.get(rowKey);\n            value = row && row.get(columnName);\n          }\n\n          return value;\n        },\n\n        /**\n         * Sets the vlaue of the cell identified by the specified rowKey and columnName.\n         * @param {(Number|String)} rowKey - rowKey\n         * @param {String} columnName - columnName\n         * @param {(Number|String)} value - value\n         * @param {Boolean} [silent=false] - whether set silently\n         * @returns {Boolean} True if affected row exists\n         */\n        setValue: function setValue(rowKey, columnName, value, silent) {\n          var row = this.get(rowKey);\n\n          if (row) {\n            row.set(columnName, value, {\n              silent: silent\n            });\n            return true;\n          }\n\n          return false;\n        },\n\n        /**\n         * columnName에 해당하는 column data list를 리턴한다.\n         * @param {String} columnName   컬럼명\n         * @param {boolean} [isJsonString=false]  true 일 경우 JSON String 으로 반환한다.\n         * @returns {Array} 컬럼명에 해당하는 셀들의 데이터 리스트\n         */\n        getColumnValues: function getColumnValues(columnName, isJsonString) {\n          var valueList = this.pluck(columnName);\n          return isJsonString ? JSON.stringify(valueList) : valueList;\n        },\n\n        /**\n         * columnName 에 해당하는 값을 전부 변경한다.\n         * @param {String} columnName 컬럼명\n         * @param {(Number|String)} columnValue 변경할 컬럼 값\n         * @param {Boolean} [isCheckCellState=true] 셀의 편집 가능 여부 와 disabled 상태를 체크할지 여부\n         * @param {Boolean} [silent=false] change 이벤트 trigger 할지 여부.\n         */\n        setColumnValues: function setColumnValues(columnName, columnValue, isCheckCellState, silent) {\n          var obj = {},\n              cellState = {\n            disabled: false,\n            editable: true\n          };\n          obj[columnName] = columnValue;\n          isCheckCellState = _.isUndefined(isCheckCellState) ? true : isCheckCellState;\n          this.forEach(function (row) {\n            if (isCheckCellState) {\n              cellState = row.getCellState(columnName);\n            }\n\n            if (!cellState.disabled && cellState.editable) {\n              row.set(obj, {\n                silent: silent\n              });\n            }\n          }, this);\n        },\n\n        /**\n         * rowKey 와 columnName 에 해당하는 Cell 의 rowSpanData 를 반환한다.\n         * @param {(Number|String)} rowKey 행 데이터의 고유 rowKey\n         * @param {String} columnName 컬럼 이름\n         * @returns {object} rowSpanData\n         */\n        getRowSpanData: function getRowSpanData(rowKey, columnName) {\n          var row = this.get(rowKey);\n          return row ? row.getRowSpanData(columnName) : null;\n        },\n\n        /**\n         * Returns true if there are at least one row modified.\n         * @returns {boolean} - True if there are at least one row modified.\n         */\n        isModified: function isModified() {\n          var modifiedRowsArr = _.values(this.getModifiedRows());\n\n          return _.some(modifiedRowsArr, function (modifiedRows) {\n            return modifiedRows.length > 0;\n          });\n        },\n\n        /**\n         * Enables or Disables all rows.\n         * @param  {Boolean} disabled - Whether disabled or not\n         */\n        setDisabled: function setDisabled(disabled) {\n          if (this.disabled !== disabled) {\n            this.disabled = disabled;\n            this.trigger('disabledChanged');\n          }\n        },\n\n        /**\n         * rowKey에 해당하는 행을 활성화시킨다.\n         * @param {(Number|String)} rowKey 행 데이터의 고유 키\n         */\n        enableRow: function enableRow(rowKey) {\n          this.get(rowKey).setRowState('');\n        },\n\n        /**\n         * rowKey에 해당하는 행을 비활성화 시킨다.\n         * @param {(Number|String)} rowKey    행 데이터의 고유 키\n         */\n        disableRow: function disableRow(rowKey) {\n          this.get(rowKey).setRowState('DISABLED');\n        },\n\n        /**\n         * rowKey에 해당하는 행의 메인 체크박스를 체크할 수 있도록 활성화 시킨다.\n         * @param {(Number|String)} rowKey 행 데이터의 고유 키\n         */\n        enableCheck: function enableCheck(rowKey) {\n          this.get(rowKey).setRowState('');\n        },\n\n        /**\n         * rowKey에 해당하는 행의 메인 체크박스를 체크하지 못하도록 비활성화 시킨다.\n         * @param {(Number|String)} rowKey 행 데이터의 고유 키\n         */\n        disableCheck: function disableCheck(rowKey) {\n          this.get(rowKey).setRowState('DISABLED_CHECK');\n        },\n\n        /**\n         * rowKey에 해당하는 행의 체크박스 및 라디오박스를 선택한다.\n         * @param {(Number|String)} rowKey    행 데이터의 고유 키\n         * @param {Boolean} [silent] 이벤트 발생 여부\n         */\n        check: function check(rowKey, silent) {\n          var isDisabledCheck = this.get(rowKey).getRowState().isDisabledCheck;\n          var selectType = this.columnModel.get('selectType');\n\n          if (!isDisabledCheck && selectType) {\n            if (selectType === 'radio') {\n              this.uncheckAll();\n            }\n\n            this.setValue(rowKey, '_button', true, silent);\n          }\n        },\n\n        /**\n         * rowKey 에 해당하는 행의 체크박스 및 라디오박스를 선택한다.\n         * @param {(Number|String)} rowKey    행 데이터의 고유 키\n         * @param {Boolean} [silent] 이벤트 발생 여부\n         */\n        uncheck: function uncheck(rowKey, silent) {\n          this.setValue(rowKey, '_button', false, silent);\n        },\n\n        /**\n         * 전체 행을 선택한다.\n         * TODO: disableCheck 행 처리\n         */\n        checkAll: function checkAll() {\n          this.setColumnValues('_button', true);\n        },\n\n        /**\n         * 모든 행을 선택 해제 한다.\n         */\n        uncheckAll: function uncheckAll() {\n          this.setColumnValues('_button', false);\n        },\n\n        /**\n         * 주어진 데이터로 모델 목록을 생성하여 반환한다.\n         * @param {object|array} rowData - 모델을 생성할 데이터. Array일 경우 여러개를 동시에 생성한다.\n         * @param {object} options - append의 경우 필요한 options\n         * @returns {Row[]} 생성된 모델 목록\n         */\n        _createModelList: function _createModelList(rowData, options) {\n          var modelList = [],\n              rowList;\n          rowData = rowData || this._createDummyRow();\n\n          if (!_.isArray(rowData)) {\n            rowData = [rowData];\n          }\n\n          rowList = this._formatData(rowData, options);\n\n          _.each(rowList, function (row) {\n            var ModelClass = this.model;\n            var model = new ModelClass(row, {\n              collection: this,\n              parse: true\n            });\n            modelList.push(model);\n          }, this);\n\n          return modelList;\n        },\n\n        /**\n         * 새로운 행이 추가되었을 때, 관련된 주변 행들의 rowSpan 데이터를 갱신한다.\n         * @param {number} index - 추가된 행의 인덱스\n         * @param {number} length - 추가된 행의 개수\n         * @param {boolean} extendPrevRowSpan - 이전 행의 rowSpan 데이터가 있는 경우 합칠지 여부\n         */\n        _syncRowSpanDataForAppend: function _syncRowSpanDataForAppend(index, length, extendPrevRowSpan) {\n          var prevRow = this.at(index - 1);\n\n          if (!prevRow) {\n            return;\n          }\n\n          _.each(prevRow.getRowSpanData(), function (data, columnName) {\n            var mainRow, mainRowData, startOffset, spanCount; // count 값은 mainRow인 경우 '전체 rowSpan 개수', 아닌 경우는 'mainRow까지의 거리 (음수)'를 의미한다.\n            // 0이면 rowSpan 되어 있지 않다는 의미이다.\n\n            if (data.count === 0) {\n              return;\n            }\n\n            if (data.isMainRow) {\n              mainRow = prevRow;\n              mainRowData = data;\n              startOffset = 1;\n            } else {\n              mainRow = this.get(data.mainRowKey);\n              mainRowData = mainRow.getRowSpanData()[columnName]; // 루프를 순회할 때 의미를 좀더 명확하게 하기 위해 양수값으로 변경해서 offset 처럼 사용한다.\n\n              startOffset = -data.count + 1;\n            }\n\n            if (mainRowData.count > startOffset || extendPrevRowSpan) {\n              mainRowData.count += length;\n              spanCount = mainRowData.count;\n\n              this._updateSubRowSpanData(mainRow, columnName, startOffset, spanCount);\n            }\n          }, this);\n        },\n\n        /**\n         * 특정 컬럼의 rowSpan 데이터를 주어진 범위만큼 갱신한다.\n         * @param {Row} mainRow - rowSpan의 첫번째 행\n         * @param {string} columnName - 컬럼명\n         * @param {number} startOffset - mainRow로부터 몇번째 떨어진 행부터 갱신할지를 지정하는 값\n         * @param {number} spanCount - span이 적용될 행의 개수\n         */\n        _updateSubRowSpanData: function _updateSubRowSpanData(mainRow, columnName, startOffset, spanCount) {\n          var mainRowIdx = this.indexOf(mainRow),\n              mainRowKey = mainRow.get('rowKey'),\n              row,\n              offset;\n\n          for (offset = startOffset; offset < spanCount; offset += 1) {\n            row = this.at(mainRowIdx + offset);\n            row.set(columnName, mainRow.get(columnName), {\n              silent: true\n            });\n            row.setRowSpanData(columnName, {\n              count: -offset,\n              mainRowKey: mainRowKey,\n              isMainRow: false\n            });\n          }\n        },\n\n        /**\n         * 해당 row가 수정된 Row인지 여부를 반환한다.\n         * @param {Object} row - row 데이터\n         * @param {Object} originalRow - 원본 row 데이터\n         * @param {Array} ignoredColumns - 비교에서 제외할 컬럼명\n         * @returns {boolean} - 수정여부\n         */\n        _isModifiedRow: function _isModifiedRow(row, originalRow, ignoredColumns) {\n          var filtered = _.omit(row, ignoredColumns);\n\n          var result = _.some(filtered, function (value, columnName) {\n            if (typeof value === 'object') {\n              return JSON.stringify(value) !== JSON.stringify(originalRow[columnName]);\n            }\n\n            return value !== originalRow[columnName];\n          }, this);\n\n          return result;\n        },\n\n        /**\n         * 수정된 rowList 를 반환한다.\n         * @param {Object} options 옵션 객체\n         *      @param {boolean} [options.checkedOnly=false] true 로 설정된 경우 checked 된 데이터 대상으로 비교 후 반환한다.\n         *      @param {boolean} [options.withRawData=false] true 로 설정된 경우 내부 연산용 데이터 제거 필터링을 거치지 않는다.\n         *      @param {boolean} [options.rowKeyOnly=false] true 로 설정된 경우 키값만 저장하여 리턴한다.\n         *      @param {Array} [options.ignoredColumns]   행 데이터 중에서 데이터 변경으로 간주하지 않을 컬럼 이름을 배열로 설정한다.\n         * @returns {{createdRows: Array, updatedRows: Array, deletedRows: Array}} options 조건에 해당하는 수정된 rowList 정보\n         */\n        getModifiedRows: function getModifiedRows(options) {\n          var withRawData = options && options.withRawData;\n          var isCheckAvailable = !!this.columnModel.getColumnModel('_button');\n          var checkedOnly = isCheckAvailable && options && options.checkedOnly;\n          var rowKeyOnly = options && options.rowKeyOnly;\n          var original = withRawData ? this.originalRows : this._removePrivateProp(this.originalRows);\n          var current = withRawData ? this.toJSON() : this._removePrivateProp(this.toJSON());\n          var ignoredColumns = options && options.ignoredColumns;\n          var result = {\n            createdRows: [],\n            updatedRows: [],\n            deletedRows: []\n          };\n          original = _.indexBy(original, 'rowKey');\n          current = _.indexBy(current, 'rowKey');\n          ignoredColumns = _.union(ignoredColumns, this.columnModel.getIgnoredColumnNames()); // 추가/ 수정된 행 추출\n\n          _.each(current, function (row, rowKey) {\n            var originalRow = original[rowKey],\n                item = rowKeyOnly ? row.rowKey : _.omit(row, ignoredColumns);\n\n            if (!checkedOnly || checkedOnly && this.get(rowKey).get('_button')) {\n              if (!originalRow) {\n                result.createdRows.push(item);\n              } else if (this._isModifiedRow(row, originalRow, ignoredColumns)) {\n                result.updatedRows.push(item);\n              }\n            }\n          }, this); // 삭제된 행 추출\n\n\n          _.each(original, function (obj, rowKey) {\n            var item = rowKeyOnly ? obj.rowKey : _.omit(obj, ignoredColumns);\n\n            if (!current[rowKey]) {\n              result.deletedRows.push(item);\n            }\n          }, this);\n\n          return result;\n        },\n\n        /**\n         * data 를 설정한다. setData 와 다르게 setOriginalRowList 를 호출하여 원본데이터를 갱신하지 않는다.\n         * @param {Array} data - 설정할 데이터 배열 값\n         * @param {boolean} [parse=true]  backbone 의 parse 로직을 수행할지 여부\n         * @param {Function} [callback] callback function\n         */\n        resetData: function resetData(data, parse, callback) {\n          if (!data) {\n            data = [];\n          }\n\n          if (_.isUndefined(parse)) {\n            parse = true;\n          }\n\n          this.trigger('beforeReset', data.length);\n          this.lastRowKey = -1;\n          this.reset(data, {\n            parse: parse\n          });\n\n          if (_.isFunction(callback)) {\n            callback();\n          }\n        },\n\n        /**\n         * data 를 설정하고, setOriginalRowList 를 호출하여 원본데이터를 갱신한다.\n         * @param {Array} data - 설정할 데이터 배열 값\n         * @param {boolean} [parse=true]  backbone 의 parse 로직을 수행할지 여부\n         * @param {function} [callback] 완료시 호출될 함수\n         */\n        setData: function setData(data, parse, callback) {\n          var wrappedCallback = _.bind(function () {\n            this.setOriginalRowList();\n\n            if (_.isFunction(callback)) {\n              callback();\n            }\n          }, this);\n\n          this.resetData(data, parse, wrappedCallback);\n        },\n\n        /**\n         * setData()를 통해 그리드에 설정된 초기 데이터 상태로 복원한다.\n         * 그리드에서 수정되었던 내용을 초기화하는 용도로 사용한다.\n         */\n        restore: function restore() {\n          var originalRows = this.getOriginalRowList();\n          this.resetData(originalRows, true);\n        },\n\n        /**\n         * rowKey 와 columnName 에 해당하는 text 형태의 셀의 값을 삭제한다.\n         * @param {(Number|String)} rowKey 행 데이터의 고유 키\n         * @param {String} columnName 컬럼 이름\n         * @param {Boolean} [silent=false] 이벤트 발생 여부. true 로 변경할 상황은 거의 없다.\n         */\n        del: function del(rowKey, columnName, silent) {\n          var mainRowKey = this.getMainRowKey(rowKey, columnName),\n              cellState = this.get(mainRowKey).getCellState(columnName),\n              editType = this.columnModel.getEditType(columnName),\n              isDeletableType = _.contains(['text', 'password'], editType);\n\n          if (isDeletableType && cellState.editable && !cellState.disabled) {\n            this.setValue(mainRowKey, columnName, '', silent);\n          }\n        },\n\n        /**\n         * Calls del() method for multiple cells silently, and trigger 'deleteRange' event\n         * @param {{row: Array.<number>, column: Array.<number>}} range - visible indexes\n         */\n        delRange: function delRange(range) {\n          var columnModels = this.columnModel.getVisibleColumns();\n\n          var rowIdxes = _.range(range.row[0], range.row[1] + 1);\n\n          var columnIdxes = _.range(range.column[0], range.column[1] + 1);\n\n          var rowKeys, columnNames;\n          rowKeys = _.map(rowIdxes, function (idx) {\n            return this.at(idx).get('rowKey');\n          }, this);\n          columnNames = _.map(columnIdxes, function (idx) {\n            return columnModels[idx].name;\n          });\n\n          _.each(rowKeys, function (rowKey) {\n            _.each(columnNames, function (columnName) {\n              this.del(rowKey, columnName, true);\n              this.get(rowKey).validateCell(columnName, true);\n            }, this);\n          }, this);\n          /**\n           * Occurs when cells are deleted by 'del' key\n           * @event Grid#deleteRange\n           * @type {module:event/gridEvent}\n           * @property {Array} columnNames - columName list of deleted cell\n           * @property {Array} rowKeys - rowKey list of deleted cell\n           * @property {Grid} instance - Current grid instance\n           */\n\n\n          this.trigger('deleteRange', new GridEvent(null, {\n            rowKeys: rowKeys,\n            columnNames: columnNames\n          }));\n        },\n\n        /**\n         * 2차원 배열로 된 데이터를 받아 현재 Focus된 셀을 기준으로 하여 각각의 인덱스의 해당하는 만큼 우측 아래 방향으로\n         * 이동하며 셀의 값을 변경한다. 완료한 후 적용된 셀 범위에 Selection을 지정한다.\n         * @param {Array[]} data - 2차원 배열 데이터. 내부배열의 사이즈는 모두 동일해야 한다.\n         * @param {{row: number, column: number}} startIdx - 시작점이 될 셀의 인덱스\n         */\n        paste: function paste(data, startIdx) {\n          var endIdx = this._getEndIndexToPaste(data, startIdx);\n\n          _.each(data, function (row, index) {\n            this._setValueForPaste(row, startIdx.row + index, startIdx.column, endIdx.column);\n          }, this);\n\n          this.trigger('paste', {\n            startIdx: startIdx,\n            endIdx: endIdx\n          });\n        },\n\n        /**\n         * Validates all data and returns the result.\n         * Return value is an array which contains only rows which have invalid cell data.\n         * @returns {Array.<Object>} An array of error object\n         * @example\n            [\n                {\n                    rowKey: 1,\n                    errors: [\n                        {\n                            columnName: 'c1',\n                            errorCode: 'REQUIRED'\n                        },\n                        {\n                            columnName: 'c2',\n                            errorCode: 'REQUIRED'\n                        }\n                    ]\n                },\n                {\n                    rowKey: 3,\n                    errors: [\n                        {\n                            columnName: 'c2',\n                            errorCode: 'REQUIRED'\n                        }\n                    ]\n                }\n            ]\n         */\n        validate: function validate() {\n          var errorRows = [];\n\n          var requiredColumnNames = _.chain(this.columnModel.getVisibleColumns()).filter(function (columnModel) {\n            return columnModel.validation && columnModel.validation.required === true;\n          }).pluck('name').value();\n\n          this.each(function (row) {\n            var errorCells = [];\n\n            _.each(requiredColumnNames, function (columnName) {\n              var errorCode = row.validateCell(columnName);\n\n              if (errorCode) {\n                errorCells.push({\n                  columnName: columnName,\n                  errorCode: errorCode\n                });\n              }\n            });\n\n            if (errorCells.length) {\n              errorRows.push({\n                rowKey: row.get('rowKey'),\n                errors: errorCells\n              });\n            }\n          });\n          return errorRows;\n        },\n\n        /**\n         * 붙여넣기를 실행할 때 끝점이 될 셀의 인덱스를 반환한다.\n         * @param  {Array[]} data - 붙여넣기할 데이터\n         * @param  {{row: number, column: number}} startIdx - 시작점이 될 셀의 인덱스\n         * @returns {{row: number, column: number}} 행과 열의 인덱스 정보를 가진 객체\n         */\n        _getEndIndexToPaste: function _getEndIndexToPaste(data, startIdx) {\n          var columns = this.columnModel.getVisibleColumns(),\n              rowIdx = data.length + startIdx.row - 1,\n              columnIdx = Math.min(data[0].length + startIdx.column, columns.length) - 1;\n          return {\n            row: rowIdx,\n            column: columnIdx\n          };\n        },\n\n        /**\n         * 주어진 행 데이터를 지정된 인덱스의 컬럼에 반영한다.\n         * 셀이 수정 가능한 상태일 때만 값을 변경하며, RowSpan이 적용된 셀인 경우 MainRow인 경우에만 값을 변경한다.\n         * @param  {rowData} rowData - 붙여넣을 행 데이터\n         * @param  {number} rowIdx - 행 인덱스\n         * @param  {number} columnStartIdx - 열 시작 인덱스\n         * @param  {number} columnEndIdx - 열 종료 인덱스\n         */\n        _setValueForPaste: function _setValueForPaste(rowData, rowIdx, columnStartIdx, columnEndIdx) {\n          var row = this.at(rowIdx),\n              columnModel = this.columnModel,\n              attributes = {},\n              columnIdx,\n              columnName,\n              cellState,\n              rowSpanData;\n\n          if (!row) {\n            row = this.appendRow({})[0];\n          }\n\n          for (columnIdx = columnStartIdx; columnIdx <= columnEndIdx; columnIdx += 1) {\n            columnName = columnModel.at(columnIdx, true).name;\n            cellState = row.getCellState(columnName);\n            rowSpanData = row.getRowSpanData(columnName);\n\n            if (cellState.editable && !cellState.disabled && (!rowSpanData || rowSpanData.count >= 0)) {\n              attributes[columnName] = rowData[columnIdx - columnStartIdx];\n            }\n          }\n\n          row.set(attributes);\n        },\n\n        /**\n         * rowKey 와 columnName 에 해당하는 td element 를 반환한다.\n         * 내부적으로 자동으로 mainRowKey 를 찾아 반환한다.\n         * @param {(Number|String)} rowKey    행 데이터의 고유 키\n         * @param {String} columnName   컬럼 이름\n         * @returns {jQuery} 해당 jQuery Element\n         */\n        getElement: function getElement(rowKey, columnName) {\n          var mainRowKey = this.getMainRowKey(rowKey, columnName);\n          return this.domState.getElement(mainRowKey, columnName);\n        },\n\n        /**\n         * Returns the count of check-available rows and checked rows.\n         * @returns {{available: number, checked: number}}\n         */\n        getCheckedState: function getCheckedState() {\n          var available = 0;\n          var checked = 0;\n          this.forEach(function (row) {\n            var buttonState = row.getCellState('_button');\n\n            if (!buttonState.disabled && buttonState.editable) {\n              available += 1;\n\n              if (row.get('_button')) {\n                checked += 1;\n              }\n            }\n          });\n          return {\n            available: available,\n            checked: checked\n          };\n        },\n\n        /**\n         * Check whether the row is visible or not\n         * @returns {boolean} state\n         * @abstract\n         */\n        isVisibleRow: function isVisibleRow() {\n          return true;\n        }\n      });\n      module.exports = RowList;\n      /***/\n    },\n    /* 13 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Base class for Collections\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var Backbone = __webpack_require__(5);\n      /**\n       * Base class for Collection\n       * @module base/collection\n       * @ignore\n       */\n\n\n      var Collection = Backbone.Collection.extend(\n      /** @lends module:base/collection.prototype */\n      {\n        /**\n         * collection 내 model 들의 event listener 를 제거하고 메모리에서 해제한다.\n         * @returns {object} this object\n         */\n        clear: function clear() {\n          this.each(function (model) {\n            model.stopListening();\n            model = null;\n          });\n          this.reset([], {\n            silent: true\n          });\n          return this;\n        }\n      });\n      module.exports = Collection;\n      /***/\n    },\n    /* 14 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Grid 의 Data Source 에 해당하는 Model 정의\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var Backbone = __webpack_require__(5);\n\n      var snippet = __webpack_require__(3);\n\n      var Model = __webpack_require__(9);\n\n      var ExtraDataManager = __webpack_require__(15);\n\n      var GridEvent = __webpack_require__(16);\n\n      var util = __webpack_require__(17);\n\n      var clipboardUtil = __webpack_require__(18);\n\n      var classNameConst = __webpack_require__(19); // Propertie names that indicate meta data\n\n\n      var PRIVATE_PROPERTIES = ['_button', '_number', '_extraData']; // Error code for validtaion\n\n      var VALID_ERR_REQUIRED = 'REQUIRED';\n      var VALID_ERR_TYPE_NUMBER = 'TYPE_NUMBER';\n      /**\n       * Data 중 각 행의 데이터 모델 (DataSource)\n       * @module model/data/row\n       * @extends module:base/model\n       * @ignore\n       */\n\n      var Row = Model.extend(\n      /** @lends module:model/data/row.prototype */\n      {\n        initialize: function initialize() {\n          Model.prototype.initialize.apply(this, arguments);\n          this.extraDataManager = new ExtraDataManager(this.get('_extraData'));\n          this.columnModel = this.collection.columnModel;\n          this.validateMap = {};\n          this.on('change', this._onChange, this);\n        },\n        idAttribute: 'rowKey',\n\n        /**\n         * Overrides Backbone's set method for executing onBeforeChange before firing change event.\n         * @override\n         * @param {(Object|string)} key - Model's attribute(s)\n         * @param {*} value - Model's value or options when type of key paramater is object\n         * @param {?Object} options - The value of key or the options object\n         */\n        set: function set(key, value, options) {\n          var isObject = _.isObject(key);\n\n          var changedColumns; // When the \"key\" parameter's type is object,\n          // the \"options\" parameter is replaced by the \"value\" parameter.\n\n          if (isObject) {\n            options = value;\n          } // When calling set method on initialize, the value of columnModel is undefined.\n\n\n          if (this.columnModel && !(options && options.silent)) {\n            if (isObject) {\n              changedColumns = key;\n            } else {\n              changedColumns = {};\n              changedColumns[key] = value;\n            }\n\n            _.each(changedColumns, function (columnValue, columnName) {\n              if (!this._executeOnBeforeChange(columnName, columnValue)) {\n                delete changedColumns[columnName];\n              }\n            }, this);\n\n            Backbone.Model.prototype.set.call(this, changedColumns, options);\n          } else {\n            Backbone.Model.prototype.set.apply(this, arguments);\n          }\n        },\n\n        /**\n         * Overrides Backbone's parse method for extraData not to be null.\n         * @override\n         * @param  {Object} data - initial data\n         * @returns {Object} - parsed data\n         */\n        parse: function parse(data) {\n          if (!data._extraData) {\n            data._extraData = {};\n          }\n\n          return data;\n        },\n\n        /**\n         * Event handler for change event in _extraData.\n         * Reset _extraData value with cloned object to trigger 'change:_extraData' event.\n         * @private\n         */\n        _triggerExtraDataChangeEvent: function _triggerExtraDataChangeEvent() {\n          this.trigger('extraDataChanged', this.get('_extraData'));\n        },\n\n        /**\n         * Event handler for change event in _button (=checkbox)\n         * @param {boolean} checked - Checked state\n         * @private\n         */\n        _triggerCheckboxChangeEvent: function _triggerCheckboxChangeEvent(checked) {\n          var eventObj = {\n            rowKey: this.get('rowKey')\n          };\n\n          if (checked) {\n            /**\n             * Occurs when a checkbox in row header is checked\n             * @event Grid#check\n             * @type {module:event/gridEvent}\n             * @property {number} rowKey - rowKey of the checked row\n             * @property {Grid} instance - Current grid instance\n             */\n            this.trigger('check', eventObj);\n          } else {\n            /**\n             * Occurs when a checkbox in row header is unchecked\n             * @event Grid#uncheck\n             * @type {module:event/gridEvent}\n             * @property {number} rowKey - rowKey of the unchecked row\n             * @property {Grid} instance - Current grid instance\n             */\n            this.trigger('uncheck', eventObj);\n          }\n        },\n\n        /**\n         * Event handler for 'change' event.\n         * Executes callback functions, sync rowspan data, and validate data.\n         * @private\n         */\n        _onChange: function _onChange() {\n          var publicChanged = _.omit(this.changed, this.getPrivateProperties());\n\n          if (_.has(this.changed, '_button')) {\n            this._triggerCheckboxChangeEvent(this.changed._button);\n          }\n\n          if (this.isDuplicatedPublicChanged(publicChanged)) {\n            return;\n          }\n\n          _.each(publicChanged, function (value, columnName) {\n            var columnModel = this.columnModel.getColumnModel(columnName);\n\n            if (!columnModel) {\n              return;\n            }\n\n            this.collection.syncRowSpannedData(this, columnName, value);\n\n            this._executeOnAfterChange(columnName);\n\n            this.validateCell(columnName, true);\n          }, this);\n        },\n\n        /**\n         * Validate the cell data of given columnName and returns the error code.\n         * @param  {Object} columnName - Column name\n         * @returns {String} Error code\n         * @private\n         */\n        _validateCellData: function _validateCellData(columnName) {\n          var validation = this.columnModel.getColumnModel(columnName).validation;\n          var errorCode = '';\n          var value;\n\n          if (validation) {\n            value = this.get(columnName);\n\n            if (validation.required && util.isBlank(value)) {\n              errorCode = VALID_ERR_REQUIRED;\n            } else if (validation.dataType === 'number' && !_.isNumber(value)) {\n              errorCode = VALID_ERR_TYPE_NUMBER;\n            }\n          }\n\n          return errorCode;\n        },\n\n        /**\n         * Validate a cell of given columnName.\n         * If the data is invalid, add 'invalid' class name to the cell.\n         * @param {String} columnName - Target column name\n         * @param {Boolean} isDataChanged - True if data is changed (called by onChange handler)\n         * @returns {String} - Error code\n         */\n        validateCell: function validateCell(columnName, isDataChanged) {\n          var errorCode;\n\n          if (!isDataChanged && columnName in this.validateMap) {\n            return this.validateMap[columnName];\n          }\n\n          errorCode = this._validateCellData(columnName);\n\n          if (errorCode) {\n            this.addCellClassName(columnName, classNameConst.CELL_INVALID);\n          } else {\n            this.removeCellClassName(columnName, classNameConst.CELL_INVALID);\n          }\n\n          this.validateMap[columnName] = errorCode;\n          return errorCode;\n        },\n\n        /**\n         * Create the GridEvent object when executing changeCallback defined on columnModel\n         * @param {String} columnName - Column name\n         * @param {?String} columnValue - Column value\n         * @returns {GridEvent} Event object to be passed to changeCallback\n         * @private\n         */\n        _createChangeCallbackEvent: function _createChangeCallbackEvent(columnName, columnValue) {\n          return new GridEvent(null, {\n            rowKey: this.get('rowKey'),\n            columnName: columnName,\n            value: columnValue,\n            instance: this.collection.publicObject\n          });\n        },\n\n        /**\n         * Executes the onChangeBefore callback function.\n         * @param {String} columnName - Column name\n         * @param {String} columnValue - Column value\n         * @returns {boolean}\n         * @private\n         */\n        _executeOnBeforeChange: function _executeOnBeforeChange(columnName, columnValue) {\n          var columnModel = this.columnModel.getColumnModel(columnName);\n          var changed = this.get(columnName) !== columnValue;\n          var gridEvent;\n\n          if (changed && columnModel && columnModel.onBeforeChange) {\n            gridEvent = this._createChangeCallbackEvent(columnName, columnValue);\n            columnModel.onBeforeChange(gridEvent);\n            return !gridEvent.isStopped();\n          }\n\n          return true;\n        },\n\n        /**\n         * Execuetes the onAfterChange callback function.\n         * @param {String} columnName - Column name\n         * @returns {boolean}\n         * @private\n         */\n        _executeOnAfterChange: function _executeOnAfterChange(columnName) {\n          var columnModel = this.columnModel.getColumnModel(columnName);\n          var columnValue = this.get(columnName);\n          var gridEvent;\n\n          if (columnModel.onAfterChange) {\n            gridEvent = this._createChangeCallbackEvent(columnName, columnValue);\n            columnModel.onAfterChange(gridEvent);\n            return !gridEvent.isStopped();\n          }\n\n          return true;\n        },\n\n        /**\n         * Returns the Array of private property names\n         * @returns {array} An array of private property names\n         */\n        getPrivateProperties: function getPrivateProperties() {\n          return PRIVATE_PROPERTIES;\n        },\n\n        /**\n         * Returns the object that contains rowState info.\n         * @returns {{disabled: boolean, isDisabledCheck: boolean, isChecked: boolean}} rowState 정보\n         */\n        getRowState: function getRowState() {\n          return this.extraDataManager.getRowState();\n        },\n\n        /* eslint-disable complexity */\n\n        /**\n         * Returns an array of all className, related with given columnName.\n         * @param {String} columnName - Column name\n         * @returns {Array.<String>} - An array of classNames\n         */\n        getClassNameList: function getClassNameList(columnName) {\n          var columnModel = this.columnModel.getColumnModel(columnName);\n          var isMetaColumn = util.isMetaColumn(columnName);\n          var classNameList = this.extraDataManager.getClassNameList(columnName);\n          var cellState = this.getCellState(columnName);\n\n          if (columnModel.className) {\n            classNameList.push(columnModel.className);\n          }\n\n          if (columnModel.ellipsis) {\n            classNameList.push(classNameConst.CELL_ELLIPSIS);\n          }\n\n          if (columnModel.validation && columnModel.validation.required) {\n            classNameList.push(classNameConst.CELL_REQUIRED);\n          }\n\n          if (isMetaColumn) {\n            classNameList.push(classNameConst.CELL_ROW_HEAD);\n          } else if (cellState.editable) {\n            classNameList.push(classNameConst.CELL_EDITABLE);\n          }\n\n          if (cellState.disabled) {\n            classNameList.push(classNameConst.CELL_DISABLED);\n          }\n\n          if (snippet.pick(columnModel, 'editOptions', 'useViewMode') === false) {\n            classNameList.push(classNameConst.CELL_HAS_INPUT);\n          }\n\n          return this._makeUniqueStringArray(classNameList);\n        },\n\n        /* eslint-enable complexity */\n\n        /**\n         * Returns a new array, which splits all comma-separated strings in the targetList and removes duplicated item.\n         * @param  {Array} targetArray - Target array\n         * @returns {Array} - New array\n         */\n        _makeUniqueStringArray: function _makeUniqueStringArray(targetArray) {\n          var singleStringArray = _.uniq(targetArray.join(' ').split(' '));\n\n          return _.without(singleStringArray, '');\n        },\n\n        /**\n         * Returns the state of the cell identified by a given column name.\n         * @param {String} columnName - column name\n         * @returns {{editable: boolean, disabled: boolean}}\n         */\n        getCellState: function getCellState(columnName) {\n          var notEditableTypeList = ['_number', 'normal'],\n              columnModel = this.columnModel,\n              disabled = this.collection.disabled,\n              editable = true,\n              editType = columnModel.getEditType(columnName),\n              rowState,\n              relationResult;\n          relationResult = this.executeRelationCallbacksAll(['disabled', 'editable'])[columnName];\n          rowState = this.getRowState();\n\n          if (!disabled) {\n            if (columnName === '_button') {\n              disabled = rowState.disabledCheck;\n            } else {\n              disabled = rowState.disabled;\n            }\n\n            disabled = disabled || !!(relationResult && relationResult.disabled);\n          }\n\n          if (_.contains(notEditableTypeList, editType)) {\n            editable = false;\n          } else {\n            editable = !(relationResult && relationResult.editable === false);\n          }\n\n          return {\n            editable: editable,\n            disabled: disabled\n          };\n        },\n\n        /**\n         * Returns whether the cell identified by a given column name is editable.\n         * @param {String} columnName - column name\n         * @returns {Boolean}\n         */\n        isEditable: function isEditable(columnName) {\n          var cellState = this.getCellState(columnName);\n          return !cellState.disabled && cellState.editable;\n        },\n\n        /**\n         * Returns whether the cell identified by a given column name is disabled.\n         * @param {String} columnName - column name\n         * @returns {Boolean}\n         */\n        isDisabled: function isDisabled(columnName) {\n          var cellState = this.getCellState(columnName);\n          return cellState.disabled;\n        },\n\n        /**\n         * getRowSpanData\n         * rowSpan 설정값을 반환한다.\n         * @param {String} [columnName] 인자가 존재하지 않을 경우, 행 전체의 rowSpanData 를 맵 형태로 반환한다.\n         * @returns {*|{count: number, isMainRow: boolean, mainRowKey: *}}   rowSpan 설정값\n         */\n        getRowSpanData: function getRowSpanData(columnName) {\n          var isRowSpanEnable = this.collection.isRowSpanEnable(),\n              rowKey = this.get('rowKey');\n          return this.extraDataManager.getRowSpanData(columnName, rowKey, isRowSpanEnable);\n        },\n\n        /**\n         * Returns the _extraData.height\n         * @returns {number}\n         */\n        getHeight: function getHeight() {\n          return this.extraDataManager.getHeight();\n        },\n\n        /**\n         * Sets the height of the row\n         * @param {number} height - height\n         */\n        setHeight: function setHeight(height) {\n          this.extraDataManager.setHeight(height);\n\n          this._triggerExtraDataChangeEvent();\n        },\n\n        /**\n         * rowSpanData를 설정한다.\n         * @param {string} columnName - 컬럼명\n         * @param {Object} data - rowSpan 정보를 가진 객체\n         */\n        setRowSpanData: function setRowSpanData(columnName, data) {\n          this.extraDataManager.setRowSpanData(columnName, data);\n\n          this._triggerExtraDataChangeEvent();\n        },\n\n        /**\n         * rowState 를 설정한다.\n         * @param {string} rowState 해당 행의 상태값. 'DISABLED|DISABLED_CHECK|CHECKED' 중 하나를 설정한다.\n         * @param {boolean} silent 내부 change 이벤트 발생 여부\n         */\n        setRowState: function setRowState(rowState, silent) {\n          this.extraDataManager.setRowState(rowState);\n\n          if (!silent) {\n            this._triggerExtraDataChangeEvent();\n          }\n        },\n\n        /**\n         * rowKey 와 columnName 에 해당하는 Cell 에 CSS className 을 설정한다.\n         * @param {String} columnName 컬럼 이름\n         * @param {String} className 지정할 디자인 클래스명\n         */\n        addCellClassName: function addCellClassName(columnName, className) {\n          this.extraDataManager.addCellClassName(columnName, className);\n\n          this._triggerExtraDataChangeEvent();\n        },\n\n        /**\n         * rowKey에 해당하는 행 전체에 CSS className 을 설정한다.\n         * @param {String} className 지정할 디자인 클래스명\n         */\n        addClassName: function addClassName(className) {\n          this.extraDataManager.addClassName(className);\n\n          this._triggerExtraDataChangeEvent();\n        },\n\n        /**\n         * rowKey 와 columnName 에 해당하는 Cell 에 CSS className 을 제거한다.\n         * @param {String} columnName 컬럼 이름\n         * @param {String} className 지정할 디자인 클래스명\n         */\n        removeCellClassName: function removeCellClassName(columnName, className) {\n          this.extraDataManager.removeCellClassName(columnName, className);\n\n          this._triggerExtraDataChangeEvent();\n        },\n\n        /**\n         * rowKey 에 해당하는 행 전체에 CSS className 을 제거한다.\n         * @param {String} className 지정할 디자인 클래스명\n         */\n        removeClassName: function removeClassName(className) {\n          this.extraDataManager.removeClassName(className);\n\n          this._triggerExtraDataChangeEvent();\n        },\n\n        /**\n         * ctrl + c 로 복사 기능을 사용할 때 list 형태(select, button, checkbox)의 cell 의 경우, 해당 value 에 부합하는 text로 가공한다.\n         * List type 의 경우 데이터 값과 editOptions.listItems 의 text 값이 다르기 때문에\n         * text 로 전환해서 반환할 때 처리를 하여 변환한다.\n         *\n         * @param {string} columnName - Column name\n         * @param {boolean} useText - Whether returns concatenated text or values\n         * @returns {string} Concatenated text or values of \"listItems\" option\n         * @private\n         */\n        _getStringOfListItems: function _getStringOfListItems(columnName, useText) {\n          var value = this.get(columnName);\n          var columnModel = this.columnModel.getColumnModel(columnName);\n          var resultListItems, editOptionList, typeExpected, valueList, hasListItems;\n\n          if (snippet.isExisty(snippet.pick(columnModel, 'editOptions', 'listItems'))) {\n            resultListItems = this.executeRelationCallbacksAll(['listItems'])[columnName];\n            hasListItems = resultListItems && resultListItems.listItems;\n            editOptionList = hasListItems ? resultListItems.listItems : columnModel.editOptions.listItems;\n            typeExpected = typeof editOptionList[0].value;\n            valueList = util.toString(value).split(',');\n\n            if (typeExpected !== typeof valueList[0]) {\n              valueList = _.map(valueList, function (val) {\n                return util.convertValueType(val, typeExpected);\n              });\n            }\n\n            _.each(valueList, function (val, index) {\n              var item = _.findWhere(editOptionList, {\n                value: val\n              });\n\n              var str = item && (useText ? item.text : item.value) || '';\n              valueList[index] = str;\n            }, this);\n\n            return valueList.join(',');\n          }\n\n          return '';\n        },\n\n        /**\n         * Returns whether the given edit type is list type.\n         * @param {String} editType - edit type\n         * @returns {Boolean}\n         * @private\n         */\n        _isListType: function _isListType(editType) {\n          return _.contains(['select', 'radio', 'checkbox'], editType);\n        },\n\n        /**\n         * change 이벤트 발생시 동일한 changed 객체의 public 프라퍼티가 동일한 경우 중복 처리를 막기 위해 사용한다.\n         * 10ms 내에 같은 객체로 함수 호출이 일어나면 true를 반환한다.\n         * @param {Object} publicChanged 비교할 객체\n         * @returns {boolean} 중복이면 true, 아니면 false\n         */\n        isDuplicatedPublicChanged: function isDuplicatedPublicChanged(publicChanged) {\n          if (this._timeoutIdForChanged && _.isEqual(this._lastPublicChanged, publicChanged)) {\n            return true;\n          }\n\n          clearTimeout(this._timeoutIdForChanged);\n          this._timeoutIdForChanged = setTimeout(_.bind(function () {\n            this._timeoutIdForChanged = null;\n          }, this), 10); // eslint-disable-line no-magic-numbers\n\n          this._lastPublicChanged = publicChanged;\n          return false;\n        },\n\n        /**\n         * Returns the text string to be used when copying the cell value to clipboard.\n         * @param {string} columnName - column name\n         * @returns {string}\n         */\n        getValueString: function getValueString(columnName) {\n          var columnModel = this.columnModel;\n          var copyText = columnModel.copyVisibleTextOfEditingColumn(columnName);\n          var editType = columnModel.getEditType(columnName);\n          var column = columnModel.getColumnModel(columnName);\n          var value = this.get(columnName);\n\n          if (this._isListType(editType)) {\n            if (snippet.isExisty(snippet.pick(column, 'editOptions', 'listItems', 0, 'value'))) {\n              value = this._getStringOfListItems(columnName, copyText);\n            } else {\n              throw new Error('Check \"' + columnName + '\"\\'s editOptions.listItems property out in your ColumnModel.');\n            }\n          } else if (editType === 'password') {\n            value = '';\n          }\n\n          value = util.toString(value); // When the value is indcluding newline text,\n          // adding one more quotation mark and putting quotation marks on both sides.\n\n          value = clipboardUtil.addDoubleQuotes(value);\n          return value;\n        },\n\n        /**\n         * 컬럼모델에 정의된 relation 들을 수행한 결과를 반환한다. (기존 affectOption)\n         * @param {Array} attrNames 반환값의 결과를 확인할 대상 callbackList.\n         *        (default : ['listItems', 'disabled', 'editable'])\n         * @returns {{}|{columnName: {attribute: *}}} row 의 columnName 에 적용될 속성값.\n         */\n        executeRelationCallbacksAll: function executeRelationCallbacksAll(attrNames) {\n          var rowData = this.attributes;\n          var relationsMap = this.columnModel.get('relationsMap');\n          var result = {};\n\n          if (_.isEmpty(attrNames)) {\n            attrNames = ['listItems', 'disabled', 'editable'];\n          }\n\n          _.each(relationsMap, function (relations, columnName) {\n            var value = rowData[columnName];\n\n            _.each(relations, function (relation) {\n              this._executeRelationCallback(relation, attrNames, value, rowData, result);\n            }, this);\n          }, this);\n\n          return result;\n        },\n\n        /**\n         * Executes relation callback\n         * @param {Object} relation - relation object\n         *   @param {array} relation.targetNames - target column list\n         *   @param {function} [relation.disabled] - callback function for disabled attribute\n         *   @param {function} [relation.editable] - callback function for disabled attribute\n         *   @param {function} [relation.listItems] - callback function for changing option list\n         * @param {array} attrNames - an array of callback names\n         * @param {(string|number)} value - cell value\n         * @param {Object} rowData - all value of the row\n         * @param {Object} result - object to store the result of callback functions\n         * @private\n         */\n        _executeRelationCallback: function _executeRelationCallback(relation, attrNames, value, rowData, result) {\n          var rowState = this.getRowState();\n          var targetNames = relation.targetNames;\n\n          _.each(attrNames, function (attrName) {\n            var callback;\n\n            if (!rowState.disabled || attrName !== 'disabled') {\n              callback = relation[attrName];\n\n              if (typeof callback === 'function') {\n                _.each(targetNames, function (targetName) {\n                  result[targetName] = result[targetName] || {};\n                  result[targetName][attrName] = callback(value, rowData);\n                }, this);\n              }\n            }\n          }, this);\n        }\n      }, {\n        privateProperties: PRIVATE_PROPERTIES\n      });\n      module.exports = Row;\n      /***/\n    },\n    /* 15 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Grid 의 Data Source 에 해당하는 Model 정의\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n      /**\n       * Data 중 각 행의 데이터 모델 (DataSource)\n       * @module data/row\n       * @param {Object} data - Data object\n       * @extends module:base/model\n       * @ignore\n       */\n\n\n      var ExtraDataManager = snippet.defineClass(\n      /** @lends module:model/data/extraData.prototype */\n      {\n        init: function init(data) {\n          this.data = data || {};\n        },\n\n        /**\n         * Returns rowSpan data\n         * @param  {string} columnName - column name\n         * @param  {(number|string)} rowKey - rowKey\n         * @param  {boolean} isRowSpanEnable - Boolean value whether row span is enable.\n         * @returns {*|{count: number, isMainRow: boolean, mainRowKey: *}} rowSpan data\n         */\n        getRowSpanData: function getRowSpanData(columnName, rowKey, isRowSpanEnable) {\n          var rowSpanData = null;\n\n          if (isRowSpanEnable) {\n            rowSpanData = this.data.rowSpanData;\n\n            if (columnName && rowSpanData) {\n              rowSpanData = rowSpanData[columnName];\n            }\n          }\n\n          if (!rowSpanData && columnName) {\n            rowSpanData = {\n              count: 0,\n              isMainRow: true,\n              mainRowKey: rowKey\n            };\n          }\n\n          return rowSpanData;\n        },\n\n        /**\n         * Returns the object that contains rowState info.\n         * @returns {{disabled: boolean, disabledCheck: boolean, checked: boolean}} rowState 정보\n         */\n        getRowState: function getRowState() {\n          var result = {\n            disabledCheck: false,\n            disabled: false,\n            checked: false\n          };\n\n          switch (this.data.rowState) {\n            case 'DISABLED':\n              result.disabled = true;\n            // intentional no break\n\n            case 'DISABLED_CHECK':\n              // eslint-disable-line no-fallthrough\n              result.disabledCheck = true;\n              break;\n\n            case 'CHECKED':\n              result.checked = true;\n\n            default: // eslint-disable-line no-fallthrough\n\n          }\n\n          return result;\n        },\n\n        /**\n         * Sets the rowSate.\n         * @param {string} rowState - 'DISABLED' | 'DISABLED_CHECK' | 'CHECKED'\n         */\n        setRowState: function setRowState(rowState) {\n          this.data.rowState = rowState;\n        },\n\n        /**\n         * Sets the rowSpanData.\n         * @param {string} columnName - Column name\n         * @param {object} data - Data\n         */\n        setRowSpanData: function setRowSpanData(columnName, data) {\n          var rowSpanData = _.assign({}, this.data.rowSpanData);\n\n          if (!columnName) {\n            return;\n          }\n\n          if (!data) {\n            if (rowSpanData[columnName]) {\n              delete rowSpanData[columnName];\n            }\n          } else {\n            rowSpanData[columnName] = data;\n          }\n\n          this.data.rowSpanData = rowSpanData;\n        },\n\n        /**\n         * Adds className to the cell\n         * @param {String} columnName - Column name\n         * @param {String} className - Class name\n         */\n        addCellClassName: function addCellClassName(columnName, className) {\n          var classNameData, classNameList;\n          classNameData = this.data.className || {};\n          classNameData.column = classNameData.column || {};\n          classNameList = classNameData.column[columnName] || [];\n\n          if (!_.contains(classNameList, className)) {\n            classNameList.push(className);\n            classNameData.column[columnName] = classNameList;\n            this.data.className = classNameData;\n          }\n        },\n\n        /**\n         * Adds className to the row\n         * @param {String} className - Class name\n         */\n        addClassName: function addClassName(className) {\n          var classNameData, classNameList;\n          classNameData = this.data.className || {};\n          classNameList = classNameData.row || [];\n\n          if (snippet.inArray(className, classNameList) === -1) {\n            classNameList.push(className);\n            classNameData.row = classNameList;\n            this.data.className = classNameData;\n          }\n        },\n\n        /**\n         * Returns the list of className.\n         * @param {String} [columnName] - If specified, the result will only conatins class names of cell.\n         * @returns {Array} - The array of class names.\n         */\n        getClassNameList: function getClassNameList(columnName) {\n          var classNameData = this.data.className,\n              arrayPush = Array.prototype.push,\n              classNameList = [];\n\n          if (classNameData) {\n            if (classNameData.row) {\n              arrayPush.apply(classNameList, classNameData.row);\n            }\n\n            if (columnName && classNameData.column && classNameData.column[columnName]) {\n              arrayPush.apply(classNameList, classNameData.column[columnName]);\n            }\n          }\n\n          return classNameList;\n        },\n\n        /**\n         * className 이 담긴 배열로부터 특정 className 을 제거하여 반환한다.\n         * @param {Array} classNameList 디자인 클래스명 리스트\n         * @param {String} className    제거할 클래스명\n         * @returns {Array}  제거된 디자인 클래스명 리스트\n         * @private\n         */\n        _removeClassNameFromArray: function _removeClassNameFromArray(classNameList, className) {\n          // 배열 요소가 'class1 class2' 와 같이 두개 이상의 className을 포함할 수 있어, join & split 함.\n          var singleNameList = classNameList.join(' ').split(' ');\n          return _.without(singleNameList, className);\n        },\n\n        /**\n         * rowKey 와 columnName 에 해당하는 Cell 에 CSS className 을 제거한다.\n         * @param {String} columnName 컬럼 이름\n         * @param {String} className 지정할 디자인 클래스명\n         */\n        removeCellClassName: function removeCellClassName(columnName, className) {\n          var classNameData = this.data.className;\n\n          if (snippet.pick(classNameData, 'column', columnName)) {\n            classNameData.column[columnName] = this._removeClassNameFromArray(classNameData.column[columnName], className);\n            this.data.className = classNameData;\n          }\n        },\n\n        /**\n         * rowKey 에 해당하는 행 전체에 CSS className 을 제거한다.\n         * @param {String} className 지정할 디자인 클래스명\n         */\n        removeClassName: function removeClassName(className) {\n          var classNameData = this.data.className;\n\n          if (classNameData && classNameData.row) {\n            classNameData.row = this._removeClassNameFromArray(classNameData.row, className);\n            this.className = classNameData;\n          }\n        },\n\n        /**\n         * Sets the height of the row\n         * @param {number} value - value\n         */\n        setHeight: function setHeight(value) {\n          this.data.height = value;\n        },\n\n        /**\n         * Returns the height of the row\n         * @returns {number}\n         */\n        getHeight: function getHeight() {\n          return this.data.height;\n        },\n\n        /**\n         * set tree state EXPAND/COLLAPSE\n         * @param {String} state - tree state EXPAND/COLLAPSE\n         */\n        setTreeState: function setTreeState(state) {\n          this.data.treeState = state;\n        },\n\n        /**\n         * get tree state EXPAND/COLLAPSE\n         * @returns {String} - tree state EXPAND/COLLAPSE\n         */\n        getTreeState: function getTreeState() {\n          return this.data.treeState;\n        }\n      });\n      module.exports = ExtraDataManager;\n      /***/\n    },\n    /* 16 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Event class for public event of Grid\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var util = __webpack_require__(17);\n\n      var attrNameConst = __webpack_require__(10).attrName;\n\n      var targetTypeConst = {\n        ROW_HEAD: 'rowHead',\n        COLUMN_HEAD: 'columnHead',\n        DUMMY: 'dummy',\n        CELL: 'cell',\n        ETC: 'etc'\n      };\n      /**\n       * Event class for public event of Grid\n       * @module event/gridEvent\n       * @param {Object} data - Event data for handler\n       */\n\n      var GridEvent = snippet.defineClass(\n      /** @lends module:event/gridEvent.prototype */\n      {\n        init: function init(nativeEvent, data) {\n          this._stopped = false;\n\n          if (nativeEvent) {\n            this.nativeEvent = nativeEvent;\n          }\n\n          if (data) {\n            this.setData(data);\n          }\n        },\n\n        /**\n         * Sets data\n         * @param {Object} data - data\n         * @ignore\n         */\n        setData: function setData(data) {\n          _.extend(this, data);\n        },\n\n        /**\n         * Stops propogation of this event.\n         */\n        stop: function stop() {\n          this._stopped = true;\n        },\n\n        /**\n         * Returns whether this event is stopped.\n         * @returns {Boolean}\n         * @ignore\n         */\n        isStopped: function isStopped() {\n          return this._stopped;\n        }\n      });\n      /**\n       * Returns the information of event target\n       * @param {jQuery} $target - event target\n       * @returns {{targetType: string, rowKey: (number|string), columnName: string}}\n       * @ignore\n       */\n\n      GridEvent.getTargetInfo = function ($target) {\n        var $cell = $target.closest('td');\n        var targetType = targetTypeConst.ETC;\n        var rowKey, columnName;\n\n        if ($cell.length === 1) {\n          rowKey = $cell.attr(attrNameConst.ROW_KEY);\n          columnName = $cell.attr(attrNameConst.COLUMN_NAME);\n\n          if (rowKey && columnName) {\n            if (util.isMetaColumn(columnName)) {\n              targetType = targetTypeConst.ROW_HEAD;\n            } else {\n              targetType = targetTypeConst.CELL;\n            }\n          } else {\n            targetType = targetTypeConst.DUMMY;\n          }\n        } else {\n          $cell = $target.closest('th');\n\n          if ($cell.length === 1) {\n            columnName = $cell.attr(attrNameConst.COLUMN_NAME);\n            targetType = targetTypeConst.COLUMN_HEAD;\n          }\n        }\n\n        return util.pruneObject({\n          targetType: targetType,\n          rowKey: util.strToNumber(rowKey),\n          columnName: columnName\n        });\n      };\n\n      GridEvent.targetTypeConst = targetTypeConst;\n      module.exports = GridEvent;\n      /***/\n    },\n    /* 17 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n      * @fileoverview 유틸리티 메서드 모음\n      * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n      */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var CELL_BORDER_WIDTH = __webpack_require__(10).dimension.CELL_BORDER_WIDTH;\n\n      var util;\n      /**\n       * Decode URI\n       * @param {string} uri - URI\n       * @param {boolean} mod - Whether maintaining \"%25\" or not\n       * @returns {string} Decoded URI\n       * @ignore\n       */\n\n      function decodeURIComponentSafe(uri, mod) {\n        var decodedURI = '';\n        var i = 0;\n        var length, arr, tempDecodedURI;\n        mod = !!mod;\n        arr = uri.split(/(%(?:d0|d1)%.{2})/);\n\n        for (length = arr.length; i < length; i += 1) {\n          try {\n            tempDecodedURI = decodeURIComponent(arr[i]);\n          } catch (e) {\n            tempDecodedURI = mod ? arr[i].replace(/%(?!\\d+)/g, '%25') : arr[i];\n          }\n\n          decodedURI += tempDecodedURI;\n        }\n\n        return decodedURI;\n      }\n      /**\n      * util 모듈\n      * @module util\n      * @ignore\n      */\n\n\n      util = {\n        uniqueId: 0,\n\n        /**\n         * HTML Attribute 설정 시 필요한 문자열을 가공한다.\n         * @memberof module:util\n         * @param {{key:value}} attributes  문자열로 가공할 attribute 데이터\n         * @returns {string} html 마크업에 포함될 문자열\n         * @example\n         var str = util.getAttributesString({\n                'class': 'focused disabled',\n                'width': '100',\n                'height': '200'\n          });\n          =>\n         class=\"focused disabled\" width=\"100\" height=\"200\"\n         */\n        getAttributesString: function getAttributesString(attributes) {\n          var str = '';\n\n          _.each(attributes, function (value, key) {\n            str += ' ' + key + '=\"' + value + '\"';\n          }, this);\n\n          return str;\n        },\n\n        /**\n         * 배열의 합을 반환한다.\n         * @memberof module:util\n         * @param {number[]} list   총 합을 구할 number 타입 배열\n         * @returns {number} 합산한 결과값\n         */\n        sum: function sum(list) {\n          return _.reduce(list, function (memo, value) {\n            memo += value;\n            return memo;\n          }, 0);\n        },\n\n        /**\n         * Returns the minimum value and the maximum value of the values in array.\n         * @param {Array} arr - Target array\n         * @returns {{min: number, max: number}} Min and Max\n         * @see {@link http://jsperf.com/getminmax}\n         */\n        getMinMax: function getMinMax(arr) {\n          return {\n            min: Math.min.apply(null, arr),\n            max: Math.max.apply(null, arr)\n          };\n        },\n\n        /**\n         * Convert a string value to number.\n         * If the value cannot be converted to number, returns original value.\n         * @param {string} str - string value\n         * @returns {number|string}\n         */\n        strToNumber: function strToNumber(str) {\n          var converted = Number(str);\n          return isNaN(converted) ? str : converted;\n        },\n\n        /**\n         * Omits all undefined or null properties of given object.\n         * @param {Object} obj - object\n         * @returns {Object}\n         */\n        pruneObject: function pruneObject(obj) {\n          var pruned = {};\n\n          _.each(obj, function (value, key) {\n            if (!_.isUndefined(value) && !_.isNull(value)) {\n              pruned[key] = value;\n            }\n          });\n\n          return pruned;\n        },\n\n        /**\n         * Returns the table height including height of rows and borders.\n         * @memberof module:util\n         * @param {number} rowCount - row count\n         * @param {number} rowHeight - row height\n         * @returns {number}\n         */\n        getHeight: function getHeight(rowCount, rowHeight) {\n          return rowCount === 0 ? rowCount : rowCount * (rowHeight + CELL_BORDER_WIDTH);\n        },\n\n        /**\n         * Returns the total number of rows by using the table height and row height.\n         * @memberof module:util\n         * @param {number} tableHeight - table height\n         * @param {number} rowHeight - individual row height\n         * @returns {number}\n         */\n        getDisplayRowCount: function getDisplayRowCount(tableHeight, rowHeight) {\n          return Math.ceil(tableHeight / (rowHeight + CELL_BORDER_WIDTH));\n        },\n\n        /**\n         * Returns the individual height of a row bsaed on the total number of rows and table height.\n         * @memberof module:util\n         * @param {number} rowCount - row count\n         * @param {number} tableHeight - table height\n         * @returns {number} 한 행당 높이값\n         */\n        getRowHeight: function getRowHeight(rowCount, tableHeight) {\n          return rowCount === 0 ? 0 : Math.floor((tableHeight - CELL_BORDER_WIDTH) / rowCount);\n        },\n\n        /**\n         * Returns whether the column of a given name is meta-column.\n         * @param {String} columnName - column name\n         * @returns {Boolean}\n         */\n        isMetaColumn: function isMetaColumn(columnName) {\n          return _.contains(['_button', '_number'], columnName);\n        },\n\n        /**\n         * target 과 dist 의 값을 비교하여 같은지 여부를 확인하는 메서드\n         * === 비교 연산자를 사용하므로, object 의 경우 1depth 까지만 지원함.\n         * @memberof module:util\n         * @param {*} target    동등 비교할 target\n         * @param {*} dist      동등 비교할 dist\n         * @returns {boolean}    동일한지 여부\n         */\n        isEqual: function isEqual(target, dist) {\n          // eslint-disable-line complexity\n          var compareObject = function compareObject(targetObj, distObj) {\n            var result = false;\n            snippet.forEach(targetObj, function (item, key) {\n              result = item === distObj[key];\n              return result;\n            });\n            return result;\n          };\n\n          var result = true;\n          var isDiff;\n\n          if (typeof target !== typeof dist) {\n            result = false;\n          } else if (_.isArray(target) && target.length !== dist.length) {\n            result = false;\n          } else if (_.isObject(target)) {\n            isDiff = !compareObject(target, dist) || !compareObject(dist, target);\n            result = !isDiff;\n          } else if (target !== dist) {\n            result = false;\n          }\n\n          return result;\n        },\n\n        /**\n         * Returns whether the string blank.\n         * @memberof module:util\n         * @param {*} target - target object\n         * @returns {boolean} True if target is undefined or null or ''\n         */\n        isBlank: function isBlank(target) {\n          if (_.isString(target)) {\n            return !target.length;\n          }\n\n          return _.isUndefined(target) || _.isNull(target);\n        },\n\n        /**\n         * Grid 에서 필요한 형태로 HTML tag 를 제거한다.\n         * @memberof module:util\n         * @param {string} htmlString   html 마크업 문자열\n         * @returns {String} HTML tag 에 해당하는 부분을 제거한 문자열\n         */\n        stripTags: function stripTags(htmlString) {\n          var matchResult;\n          htmlString = htmlString.replace(/[\\n\\r\\t]/g, '');\n\n          if (snippet.hasEncodableString(htmlString)) {\n            if (/<img/i.test(htmlString)) {\n              matchResult = htmlString.match(/<img[^>]*\\ssrc=[\"']?([^>\"']+)[\"']?[^>]*>/i);\n              htmlString = matchResult ? matchResult[1] : '';\n            } else {\n              htmlString = htmlString.replace(/<button.*?<\\/button>/gi, '');\n            }\n\n            htmlString = $.trim(snippet.decodeHTMLEntity(htmlString.replace(/<\\/?(?:h[1-5]|[a-z]+(?::[a-z]+)?)[^>]*>/ig, '')));\n          }\n\n          return htmlString;\n        },\n\n        /**\n         * Converts the given value to String and returns it.\n         * If the value is undefined or null, returns the empty string.\n         * @param {*} value - value\n         * @returns {String}\n         */\n        toString: function toString(value) {\n          if (_.isUndefined(value) || _.isNull(value)) {\n            return '';\n          }\n\n          return String(value);\n        },\n\n        /**\n         * Create unique key\n         * @memberof module:util\n         * @returns {number} unique key 를 반환한다.\n         */\n        getUniqueKey: function getUniqueKey() {\n          this.uniqueId += 1;\n          return this.uniqueId;\n        },\n\n        /**\n         * object 를 query string 으로 변경한다.\n         * @memberof module:util\n         * @param {object} dataObj  쿼리 문자열으로 반환할 객체\n         * @returns {string} 변환된 쿼리 문자열\n         */\n        toQueryString: function toQueryString(dataObj) {\n          var queryList = [];\n\n          _.each(dataObj, function (value, name) {\n            if (!_.isString(value) && !_.isNumber(value)) {\n              value = JSON.stringify(value);\n            }\n\n            value = encodeURIComponent(unescape(value));\n\n            if (value) {\n              queryList.push(name + '=' + value);\n            }\n          });\n\n          return queryList.join('&');\n        },\n\n        /**\n         * queryString 을 object 형태로 변형한다.\n         * @memberof module:util\n         * @param {String} queryString 쿼리 문자열\n         * @returns {Object} 변환한 Object\n         */\n        toQueryObject: function toQueryObject(queryString) {\n          var queryList = queryString.split('&'),\n              obj = {};\n\n          _.each(queryList, function (query) {\n            var tmp = query.split('='),\n                key,\n                value;\n            key = tmp[0];\n            value = decodeURIComponentSafe(tmp[1]);\n\n            try {\n              value = JSON.parse(value);\n            } catch (e) {} // eslint-disable-line\n\n\n            if (!_.isNull(value)) {\n              obj[key] = value;\n            }\n          });\n\n          return obj;\n        },\n\n        /**\n         * type 인자에 맞게 value type 을 convert 한다.\n         * Data.Row 의 List 형태에서 editOptions.listItems 에서 검색을 위해,\n         * value type 해당 type 에 맞게 변환한다.\n         * @memberof module:util\n         * @param {*} value 컨버팅할 value\n         * @param {String} type 컨버팅 될 타입\n         * @returns {*}  타입 컨버팅된 value\n         */\n        convertValueType: function convertValueType(value, type) {\n          var result = value;\n\n          if (type === 'string') {\n            result = String(value);\n          } else if (type === 'number') {\n            result = Number(value);\n          } else if (type === 'boolean') {\n            result = Boolean(value);\n          }\n\n          return result;\n        },\n\n        /**\n         * Capitalize first character of the target string.\n         * @param  {string} string Target string\n         * @returns {string} Converted new string\n         */\n        toUpperCaseFirstLetter: function toUpperCaseFirstLetter(string) {\n          return string.charAt(0).toUpperCase() + string.slice(1);\n        },\n\n        /**\n         * Returns a number whose value is limited to the given range.\n         * @param {Number} value - A number to force within given min-max range\n         * @param {Number} min - The lower boundary of the output range\n         * @param {Number} max - The upper boundary of the output range\n         * @returns {number} A number in the range [min, max]\n         * @Example\n         *      // limit the output of this computation to between 0 and 255\n         *      value = clamp(value, 0, 255);\n         */\n        clamp: function clamp(value, min, max) {\n          var temp;\n\n          if (min > max) {\n            // swap\n            temp = min;\n            min = max;\n            max = temp;\n          }\n\n          return Math.max(min, Math.min(value, max));\n        },\n\n        /**\n         * Returns whether the given option is enabled. (Only for values the type of which can be Boolean or Object)\n         * @param {*} option - option value\n         * @returns {Boolean}\n         */\n        isOptionEnabled: function isOptionEnabled(option) {\n          return _.isObject(option) || option === true;\n        },\n\n        /**\n         * create style element and append it into the head element.\n         * @param {String} id - element id\n         * @param {String} cssString - css string\n         */\n        appendStyleElement: function appendStyleElement(id, cssString) {\n          var style = document.createElement('style');\n          style.type = 'text/css';\n          style.id = id;\n\n          if (style.styleSheet) {\n            style.styleSheet.cssText = cssString;\n          } else {\n            style.appendChild(document.createTextNode(cssString));\n          }\n\n          document.getElementsByTagName('head')[0].appendChild(style);\n        },\n\n        /**\n         * Outputs a warning message to the web console.\n         * @param {string} message - message\n         */\n        warning: function warning(message) {\n          /* eslint-disable no-console */\n          if (console && console.warn) {\n            console.warn(message);\n          }\n          /* eslint-enable no-console */\n\n        },\n\n        /**\n         * Replace text\n         * @param {string} text - Text including handlebar expression\n         * @param {Object} values - Replaced values\n         * @returns {string} Replaced text\n         */\n        replaceText: function replaceText(text, values) {\n          return text.replace(/\\{\\{(\\w*)\\}\\}/g, function (value, prop) {\n            return values.hasOwnProperty(prop) ? values[prop] : '';\n          });\n        },\n\n        /**\n         * Detect right button by mouse event\n         * @param {object} ev - Mouse event\n         * @returns {boolean} State\n         */\n        isRightClickEvent: function isRightClickEvent(ev) {\n          var rightClick;\n          ev = ev || window.event;\n\n          if (ev.which) {\n            rightClick = ev.which === 3;\n          } else if (ev.button) {\n            rightClick = ev.button === 2;\n          }\n\n          return rightClick;\n        },\n\n        /**\n         * Detect mobile browser\n         * @returns {boolean} Whether using Mobile browser\n         */\n        isMobile: function isMobile() {\n          return /Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(navigator.userAgent);\n        }\n      };\n      module.exports = util;\n      /***/\n    },\n    /* 18 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Utilities for clipboard data\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var CUSTOM_LF_SUBCHAR = '___tui_grid_lf___';\n      var CUSTOM_CR_SUBCHAR = '___tui_grid_cr___';\n      var CUSTOM_LF_REGEXP = new RegExp(CUSTOM_LF_SUBCHAR, 'g');\n      var CUSTOM_CR_REGEXP = new RegExp(CUSTOM_CR_SUBCHAR, 'g');\n      var LF = '\\n';\n      var CR = '\\r';\n      var clipboardUtil;\n      /**\n       * Set to the data matrix as colspan & rowspan range\n       * @param {string} value - Text from getting td element\n       * @param {array} data - Data matrix to set value\n       * @param {array} colspanRange - colspan range (ex: [start,Index endIndex])\n       * @param {array} rowspanRange - rowspan range (ex: [start,Index endIndex])\n       * @private\n       */\n\n      function setDataInSpanRange(value, data, colspanRange, rowspanRange) {\n        var startColspan = colspanRange[0];\n        var endColspan = colspanRange[1];\n        var startRowspan = rowspanRange[0];\n        var endRowspan = rowspanRange[1];\n        var cIndex, rIndex;\n\n        for (rIndex = startRowspan; rIndex < endRowspan; rIndex += 1) {\n          for (cIndex = startColspan; cIndex < endColspan; cIndex += 1) {\n            data[rIndex][cIndex] = startRowspan === rIndex && startColspan === cIndex ? value : ' ';\n          }\n        }\n      }\n      /**\n       * @module clipboardUtil\n       * @ignore\n       */\n\n\n      clipboardUtil = {\n        /**\n         * Convert cell data of table to clipboard data\n         * @param {HTMLElement} table - Table element\n         * @returns {array} clipboard data (2*2 matrix)\n         */\n        convertTableToData: function convertTableToData(table) {\n          var data = [];\n          var rows = table.rows;\n          var index = 0;\n          var length = rows.length;\n          var columnIndex, colspanRange, rowspanRange; // Step 1: Init the data matrix\n\n          for (; index < length; index += 1) {\n            data[index] = [];\n          } // Step 2: Traverse the table\n\n\n          _.each(rows, function (tr, rowIndex) {\n            columnIndex = 0;\n\n            _.each(tr.cells, function (td) {\n              var text = td.textContent || td.innerText;\n\n              while (data[rowIndex][columnIndex]) {\n                columnIndex += 1;\n              }\n\n              colspanRange = [columnIndex, columnIndex + (td.colSpan || 1)];\n              rowspanRange = [rowIndex, rowIndex + (td.rowSpan || 1)]; // Step 3: Set the value of td element to the data matrix as colspan and rowspan ranges\n\n              setDataInSpanRange(text, data, colspanRange, rowspanRange);\n              columnIndex = colspanRange[1];\n            });\n          });\n\n          return data;\n        },\n\n        /**\n         * Convert plain text to clipboard data\n         * @param {string} text - Copied plain text\n         * @returns {array} clipboard data (2*2 matrix)\n         */\n        convertTextToData: function convertTextToData(text) {\n          // Each newline cell data is wrapping double quotes in the text and\n          // newline characters should be replaced with substitution characters temporarily\n          // before spliting the text by newline characters.\n          text = clipboardUtil.replaceNewlineToSubchar(text);\n          return _.map(text.split(/\\r?\\n/), function (row) {\n            return _.map(row.split('\\t'), function (column) {\n              column = clipboardUtil.removeDoubleQuotes(column);\n              return column.replace(CUSTOM_LF_REGEXP, LF).replace(CUSTOM_CR_REGEXP, CR);\n            });\n          });\n        },\n\n        /**\n         * Add double quotes on text when including newline characters\n         * @param {string} text - Original text\n         * @returns {string} Replaced text\n         */\n        addDoubleQuotes: function addDoubleQuotes(text) {\n          if (text.match(/\\r?\\n/g)) {\n            text = '\"' + text.replace(/\"/g, '\"\"') + '\"';\n          }\n\n          return text;\n        },\n\n        /**\n         * Remove double quetes on text when including substitution characters\n         * @param {string} text - Original text\n         * @returns {string} Replaced text\n         */\n        removeDoubleQuotes: function removeDoubleQuotes(text) {\n          if (text.match(CUSTOM_LF_REGEXP)) {\n            text = text.substring(1, text.length - 1).replace(/\"\"/g, '\"');\n          }\n\n          return text;\n        },\n\n        /**\n         * Replace newline characters to substitution characters\n         * @param {string} text - Original text\n         * @returns {string} Replaced text\n         */\n        replaceNewlineToSubchar: function replaceNewlineToSubchar(text) {\n          return text.replace(/\"([^\"]|\"\")*\"/g, function (value) {\n            return value.replace(LF, CUSTOM_LF_SUBCHAR).replace(CR, CUSTOM_CR_SUBCHAR);\n          });\n        }\n      };\n      clipboardUtil.CUSTOM_LF_SUBCHAR = CUSTOM_LF_SUBCHAR;\n      clipboardUtil.CUSTOM_CR_SUBCHAR = CUSTOM_CR_SUBCHAR;\n      module.exports = clipboardUtil;\n      /***/\n    },\n    /* 19 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n      * @fileoverview class name constants.\n      * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n      */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var PREFIX = 'tui-grid-';\n      var classNames = {\n        CONTAINER: 'container',\n        CLIPBOARD: 'clipboard',\n        // common\n        NO_SCROLL_X: 'no-scroll-x',\n        NO_SCROLL_Y: 'no-scroll-y',\n        HAS_SUMMARY_TOP: 'has-summary-top',\n        HAS_SUMMARY_BOTTOM: 'has-summary-bottom',\n        SHOW_LSIDE_AREA: 'show-lside-area',\n        // layer\n        LAYER_STATE: 'layer-state',\n        LAYER_STATE_CONTENT: 'layer-state-content',\n        LAYER_STATE_LOADING: 'layer-state-loading',\n        LAYER_EDITING: 'layer-editing',\n        LAYER_FOCUS: 'layer-focus',\n        LAYER_FOCUS_BORDER: 'layer-focus-border',\n        LAYER_FOCUS_DEACTIVE: 'layer-focus-deactive',\n        LAYER_SELECTION: 'layer-selection',\n        LAYER_DATE_PICKER: 'layer-datepicker',\n        // border line\n        BORDER_LINE: 'border-line',\n        BORDER_TOP: 'border-line-top',\n        BORDER_LEFT: 'border-line-left',\n        BORDER_RIGHT: 'border-line-right',\n        BORDER_BOTTOM: 'border-line-bottom',\n        // layout (area)\n        CONTENT_AREA: 'content-area',\n        LSIDE_AREA: 'lside-area',\n        RSIDE_AREA: 'rside-area',\n        HEAD_AREA: 'head-area',\n        BODY_AREA: 'body-area',\n        SUMMARY_AREA: 'summary-area',\n        FROZEN_BORDER: 'frozen-border',\n        FROZEN_BORDER_TOP: 'frozen-border-top',\n        FROZEN_BORDER_BOTTOM: 'frozen-border-bottom',\n        // header\n        COLUMN_RESIZE_CONTAINER: 'column-resize-container',\n        COLUMN_RESIZE_HANDLE: 'column-resize-handle',\n        COLUMN_RESIZE_HANDLE_LAST: 'column-resize-handle-last',\n        // body\n        BODY_CONTAINER: 'body-container',\n        BODY_TABLE_CONTAINER: 'table-container',\n        // scrollbar\n        SCROLLBAR_RIGHT_TOP: 'scrollbar-right-top',\n        SCROLLBAR_Y_INNER_BORDER: 'scrollbar-y-inner-border',\n        SCROLLBAR_Y_OUTER_BORDER: 'scrollbar-y-outer-border',\n        SCROLLBAR_FROZEN_BORDER: 'scrollbar-frozen-border',\n        SCROLLBAR_RIGHT_BOTTOM: 'scrollbar-right-bottom',\n        SCROLLBAR_LEFT_BOTTOM: 'scrollbar-left-bottom',\n        // pagination\n        PAGINATION: 'pagination',\n        // table\n        TABLE: 'table',\n        // row style\n        ROW_ODD: 'row-odd',\n        ROW_EVEN: 'row-even',\n        // cell style\n        CELL: 'cell',\n        CELL_HEAD: 'cell-head',\n        CELL_ROW_HEAD: 'cell-row-head',\n        CELL_SUMMARY: 'cell-summary',\n        CELL_ROW_ODD: 'cell-row-odd',\n        CELL_ROW_EVEN: 'cell-row-even',\n        CELL_EDITABLE: 'cell-editable',\n        CELL_DUMMY: 'cell-dummy',\n        CELL_REQUIRED: 'cell-required',\n        CELL_DISABLED: 'cell-disabled',\n        CELL_SELECTED: 'cell-selected',\n        CELL_INVALID: 'cell-invalid',\n        CELL_ELLIPSIS: 'cell-ellipsis',\n        CELL_CURRENT_ROW: 'cell-current-row',\n        CELL_MAIN_BUTTON: 'cell-main-button',\n        CELL_HAS_INPUT: 'cell-has-input',\n        CELL_HAS_TREE: 'cell-has-tree',\n        // cell content\n        CELL_CONTENT: 'cell-content',\n        CELL_CONTENT_BEFORE: 'content-before',\n        CELL_CONTENT_AFTER: 'content-after',\n        CELL_CONTENT_INPUT: 'content-input',\n        CELL_CONTENT_TEXT: 'content-text',\n        // buttons\n        BTN_TEXT: 'btn-text',\n        BTN_SORT: 'btn-sorting',\n        BTN_SORT_UP: 'btn-sorting-up',\n        BTN_SORT_DOWN: 'btn-sorting-down',\n        BTN_EXCEL: 'btn-excel-download',\n        BTN_EXCEL_ICON: 'btn-excel-icon',\n        BTN_EXCEL_PAGE: 'btn-excel-page',\n        BTN_EXCEL_ALL: 'btn-excel-all',\n        BTN_TREE: 'btn-tree',\n        // height resize handle\n        HEIGHT_RESIZE_BAR: 'height-resize-bar',\n        HEIGHT_RESIZE_HANDLE: 'height-resize-handle',\n        // tree column\n        TREE_WARPPER_RELATIVE: 'tree-wrapper-relative',\n        TREE_WARPPER_VALIGN_CENTER: 'tree-wrapper-valign-center',\n        TREE_EXTRA_CONTENT: 'tree-extra-content',\n        TREE_DEPTH: 'tree-depth',\n        TREE_BUTTON_EXPAND: 'tree-button-expand',\n        TREE_BUTTON_COLLAPSE: 'tree-button-collapse',\n        TREE_ICON: 'tree-icon'\n      };\n\n      var exports = _.mapObject(classNames, function (className) {\n        return PREFIX + className;\n      });\n\n      exports.PREFIX = PREFIX;\n      module.exports = exports;\n      /***/\n    },\n    /* 20 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview TreeRow data model implementation\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var Row = __webpack_require__(14);\n\n      var treeState = __webpack_require__(10).treeState;\n\n      var PRIVATE_PROPERTIES = ['_button', '_number', '_extraData', '_treeData', '_children'];\n      /**\n       * TreeRow class implementation\n       * @module model/data/columnModel\n       * @extends module:base/model\n       * @ignore\n       */\n\n      var TreeRow = Row.extend(\n      /** @lends module:model/data/treeRow.prototype */\n      {\n        /**\n         * Returns the Array of private property names\n         * @returns {array} An array of private property names\n         */\n        getPrivateProperties: function getPrivateProperties() {\n          return PRIVATE_PROPERTIES;\n        },\n\n        /**\n         * set tree state\n         * @param {boolean} state - true if expanded\n         */\n        setTreeExpanded: function setTreeExpanded(state) {\n          var prevState = this.getTreeExpanded();\n          this.extraDataManager.setTreeState(state ? treeState.EXPAND : treeState.COLLAPSE);\n\n          if (state !== prevState) {\n            this._triggerExtraDataChangeEvent();\n          }\n        },\n\n        /**\n         * get tree state\n         * @returns {boolean} - true if expanded\n         */\n        getTreeExpanded: function getTreeExpanded() {\n          return this.extraDataManager.getTreeState() === treeState.EXPAND;\n        },\n\n        /**\n         * get tree data\n         * @returns {Object} - tree data\n         * @private\n         */\n        _getTreeData: function _getTreeData() {\n          return this.get('_treeData');\n        },\n\n        /**\n         * get tree depth of this row\n         * @returns {number} - depth of this row\n         */\n        getTreeDepth: function getTreeDepth() {\n          return this.hasTreeNextSibling().length;\n        },\n\n        /**\n         * check whether this row has one or more children\n         * @returns {boolean} - true if it has children\n         */\n        hasTreeChildren: function hasTreeChildren() {\n          var childrenRowKeys = this._getTreeData().childrenRowKeys;\n\n          var hasChildren = _.isArray(childrenRowKeys) && !!childrenRowKeys.length;\n\n          if (this.get('_children')) {\n            hasChildren = true;\n          }\n\n          return hasChildren;\n        },\n\n        /**\n         * gets children row keys\n         * @returns {Array.<number|string>} - array of children row keys\n         */\n        getTreeChildrenRowKeys: function getTreeChildrenRowKeys() {\n          return this._getTreeData().childrenRowKeys || [];\n        },\n\n        /**\n         * sets children row keys\n         * @param {Array.<number|string>} rowKeys - array of children row keys\n         */\n        setTreeChildrenRowKeys: function setTreeChildrenRowKeys(rowKeys) {\n          this._getTreeData().childrenRowKeys = rowKeys;\n        },\n\n        /**\n         * remove a child key from children row keys\n         * @param {Array.<number|string>} rowKey - the key of the row to be removed\n         */\n        removeTreeChildrenRowKey: function removeTreeChildrenRowKey(rowKey) {\n          var treeData = this._getTreeData();\n\n          treeData.childrenRowKeys = _.filter(treeData.childrenRowKeys, function (childRowKey) {\n            return childRowKey !== rowKey;\n          }, this);\n        },\n\n        /**\n         * check whether this row has one or more next sibling\n         * @returns {boolean} - true if this row has siblings\n         */\n        hasTreeNextSibling: function hasTreeNextSibling() {\n          return this._getTreeData().hasNextSibling;\n        },\n\n        /**\n         * gets parent row key\n         * @returns {number|string} - parent row key\n         */\n        getTreeParentRowKey: function getTreeParentRowKey() {\n          return this._getTreeData().parentRowKey;\n        }\n      }, {\n        privateProperties: PRIVATE_PROPERTIES,\n        treeState: treeState\n      });\n      module.exports = TreeRow;\n      /***/\n    },\n    /* 21 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview module:model/dimension\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var Model = __webpack_require__(9);\n\n      var constMap = __webpack_require__(10);\n\n      var dimensionConstMap = constMap.dimension;\n      var summaryPositionConst = constMap.summaryPosition;\n      var TABLE_BORDER_WIDTH = dimensionConstMap.TABLE_BORDER_WIDTH;\n      var CELL_BORDER_WIDTH = dimensionConstMap.CELL_BORDER_WIDTH;\n      /**\n       * Manage values about dimension (layout)\n       * @module model/dimension\n       * @param {Object} attrs - Attributes\n       * @param {Object} options - Options\n       * @extends module:base/model\n       * @ignore\n       */\n\n      var Dimension = Model.extend(\n      /** @lends module:model/dimension.prototype */\n      {\n        initialize: function initialize(attrs, options) {\n          Model.prototype.initialize.apply(this, arguments);\n          this.columnModel = options.columnModel;\n          this.dataModel = options.dataModel;\n          this.domState = options.domState;\n          this.on('change:fixedHeight', this._resetSyncHeightHandler);\n\n          if (options.domEventBus) {\n            this.listenTo(options.domEventBus, 'windowResize', this._onResizeWindow);\n            this.listenTo(options.domEventBus, 'dragmove:resizeHeight', _.debounce(_.bind(this._onDragMoveForHeight, this)));\n          }\n\n          this._resetSyncHeightHandler();\n        },\n        defaults: {\n          offsetLeft: 0,\n          offsetTop: 0,\n          width: 0,\n          headerHeight: 0,\n          bodyHeight: 0,\n          summaryHeight: 0,\n          summaryPosition: null,\n          resizeHandleHeight: 0,\n          paginationHeight: 0,\n          rowHeight: 0,\n          totalRowHeight: 0,\n          fixedRowHeight: true,\n          rsideWidth: 0,\n          lsideWidth: 0,\n          minimumColumnWidth: 0,\n          scrollBarSize: 17,\n          scrollX: true,\n          scrollY: true,\n          fitToParentHeight: false,\n          fixedHeight: false,\n          minRowHeight: 0,\n          minBodyHeight: 0,\n          frozenBorderWidth: 0\n        },\n\n        /**\n         * Event handler for 'windowResize' event on domEventBus\n         * @private\n         */\n        _onResizeWindow: function _onResizeWindow() {\n          this.refreshLayout();\n        },\n\n        /**\n         * Event handler for 'dragmmove:resizeHgith' event on domEventBus\n         * @param {module:event/gridEvent} ev - GridEvent\n         * @private\n         */\n        _onDragMoveForHeight: function _onDragMoveForHeight(ev) {\n          var height = ev.pageY - this.get('offsetTop') - ev.startData.mouseOffsetY;\n          this.setHeight(height);\n        },\n\n        /**\n         * Attach/Detach event handler of change:totalRowHeight event based on the fixedHeight.\n         * @private\n         */\n        _resetSyncHeightHandler: function _resetSyncHeightHandler() {\n          if (this.get('fixedHeight')) {\n            this.off('change:totalRowHeight');\n          } else {\n            this.on('change:totalRowHeight', this._syncBodyHeightWithTotalRowHeight);\n          }\n        },\n\n        /**\n         * Sets the bodyHeight value based on the totalRowHeight value.\n         * @private\n         */\n        _syncBodyHeightWithTotalRowHeight: function _syncBodyHeightWithTotalRowHeight() {\n          var realBodyHeight = this.get('totalRowHeight') + this.getScrollXHeight();\n          var minBodyHeight = this.get('minBodyHeight');\n          var bodyHeight = Math.max(minBodyHeight, realBodyHeight);\n          this.set('bodyHeight', bodyHeight);\n        },\n\n        /**\n         * Returns whether division border (between meta column and data column) is doubled or not.\n         * Division border should be doubled only if visible fixed data column exists.\n         * @returns {Boolean}\n         */\n        isDivisionBorderDoubled: function isDivisionBorderDoubled() {\n          return this.columnModel.getVisibleFrozenCount() > 0;\n        },\n\n        /**\n         * 전체 넓이에서 스크롤바, border등의 넓이를 제외하고 실제 셀의 넓이에 사용되는 값만 반환한다.\n         * @param {number} columnLength - 컬럼의 개수\n         * @returns {number} 사용가능한 전체 셀의 넓이\n         * @private\n         */\n        getAvailableTotalWidth: function getAvailableTotalWidth(columnLength) {\n          var totalWidth = this.get('width');\n          var borderCount = columnLength + 1 + (this.isDivisionBorderDoubled() ? 1 : 0);\n          var totalBorderWidth = borderCount * CELL_BORDER_WIDTH;\n          return totalWidth - this.getScrollYWidth() - totalBorderWidth - this.get('frozenBorderWidth');\n        },\n\n        /**\n         * Calc body size of grid except scrollBar\n         * @returns {{height: number, totalWidth: number, rsideWidth: number}} Body size\n         */\n        getBodySize: function getBodySize() {\n          var lsideWidth = this.get('lsideWidth'),\n              rsideWidth = this.get('rsideWidth') - this.getScrollYWidth(),\n              height = this.get('bodyHeight') - this.getScrollXHeight();\n          return {\n            height: height,\n            rsideWidth: rsideWidth,\n            totalWidth: lsideWidth + rsideWidth\n          };\n        },\n\n        /**\n         * Calc and get overflow values from container position\n         * @param {Number} pageX - Mouse X-position based on page\n         * @param {Number} pageY - Mouse Y-position based on page\n         * @returns {{x: number, y: number}} Mouse-overflow\n         */\n        getOverflowFromMousePosition: function getOverflowFromMousePosition(pageX, pageY) {\n          var containerPos = this.getPositionFromBodyArea(pageX, pageY);\n          var bodySize = this.getBodySize();\n          return this._judgeOverflow(containerPos, bodySize);\n        },\n\n        /**\n         * Judge overflow\n         * @param {{x: number, y: number}} containerPosition - Position values based on container\n         * @param {{height: number, totalWidth: number, rsideWidth: number}} bodySize - Real body size\n         * @returns {{x: number, y: number}} Overflow values\n         * @private\n         */\n        _judgeOverflow: function _judgeOverflow(containerPosition, bodySize) {\n          var containerX = containerPosition.x;\n          var containerY = containerPosition.y;\n          var overflowY = 0;\n          var overflowX = 0;\n\n          if (containerY < 0) {\n            overflowY = -1;\n          } else if (containerY > bodySize.height) {\n            overflowY = 1;\n          }\n\n          if (containerX < 0) {\n            overflowX = -1;\n          } else if (containerX > bodySize.totalWidth) {\n            overflowX = 1;\n          }\n\n          return {\n            x: overflowX,\n            y: overflowY\n          };\n        },\n\n        /**\n         * Return height of X-scrollBar.\n         * If no X-scrollBar, return 0\n         * @returns {number} Height of X-scrollBar\n         */\n        getScrollXHeight: function getScrollXHeight() {\n          return this.get('scrollX') ? this.get('scrollBarSize') : 0;\n        },\n\n        /**\n         * Return width of Y-scrollBar.\n         * If no Y-scrollBar, return 0\n         * @returns {number} Width of Y-scrollBar\n         */\n        getScrollYWidth: function getScrollYWidth() {\n          return this.get('scrollY') ? this.get('scrollBarSize') : 0;\n        },\n\n        /**\n         * Returns the height of table body.\n         * @param  {number} height - The height of the dimension\n         * @returns {number} The height of the table body\n         * @private\n         */\n        _calcRealBodyHeight: function _calcRealBodyHeight(height) {\n          var extraHeight = this.get('headerHeight') + this.get('summaryHeight') + TABLE_BORDER_WIDTH;\n          return height - extraHeight;\n        },\n\n        /**\n         * Returns the minimum height of table body.\n         * @returns {number} The minimum height of table body\n         * @private\n         */\n        _getMinBodyHeight: function _getMinBodyHeight() {\n          return this.get('minBodyHeight') + CELL_BORDER_WIDTH * 2 + this.getScrollXHeight();\n        },\n\n        /**\n         * 열 고정 영역의 minimum width 값을 구한다.\n         * @returns {number} 열고정 영역의 최소 너비값.\n         * @private\n         */\n        _getMinLeftSideWidth: function _getMinLeftSideWidth() {\n          var minimumColumnWidth = this.get('minimumColumnWidth');\n          var columnFrozenCount = this.columnModel.getVisibleFrozenCount(true);\n          var minWidth = 0;\n          var borderWidth;\n\n          if (columnFrozenCount) {\n            borderWidth = (columnFrozenCount + 1) * CELL_BORDER_WIDTH;\n            minWidth = borderWidth + minimumColumnWidth * columnFrozenCount;\n          }\n\n          return minWidth;\n        },\n\n        /**\n         * 열 고정 영역의 maximum width 값을 구한다.\n         * @returns {number} 열고정 영역의 최대 너비값.\n         * @private\n         */\n        getMaxLeftSideWidth: function getMaxLeftSideWidth() {\n          var maxWidth = Math.ceil(this.get('width') * 0.9); // eslint-disable-line no-magic-number\n\n          if (maxWidth) {\n            maxWidth = Math.max(maxWidth, this._getMinLeftSideWidth());\n          }\n\n          return maxWidth;\n        },\n\n        /**\n         * Set the width of the dimension.\n         * @param {number} width - Width\n         */\n        setWidth: function setWidth(width) {\n          if (width > 0) {\n            this.set('width', width);\n            this.trigger('setWidth', width);\n          }\n        },\n\n        /**\n         * Sets the height of the dimension.\n         * (Resets the bodyHeight relative to the dimension height)\n         * @param  {number} height - The height of the dimension\n         * @private\n         */\n        setHeight: function setHeight(height) {\n          if (height > 0) {\n            this.set('bodyHeight', Math.max(this._calcRealBodyHeight(height), this._getMinBodyHeight()));\n          }\n        },\n\n        /**\n         * Returns the height of the dimension.\n         * @returns {Number} Height\n         */\n        getHeight: function getHeight() {\n          return this.get('bodyHeight') + this.get('headerHeight');\n        },\n\n        /**\n         * layout 에 필요한 크기 및 위치 데이터를 갱신한다.\n         */\n        refreshLayout: function refreshLayout() {\n          var domState = this.domState;\n          var offset = domState.getOffset();\n          this.set({\n            offsetTop: offset.top,\n            offsetLeft: offset.left,\n            width: domState.getWidth()\n          });\n\n          if (this.get('fitToParentHeight')) {\n            this.setHeight(domState.getParentHeight());\n          }\n        },\n\n        /**\n         * Returns the offset.top of body\n         * @returns    {number}\n         */\n        getBodyOffsetTop: function getBodyOffsetTop() {\n          var offsetTop = this.domState.getOffset().top;\n          var summaryHeight = this.get('summaryPosition') === summaryPositionConst.TOP ? this.get('summaryHeight') : 0;\n          return offsetTop + this.get('headerHeight') + summaryHeight + CELL_BORDER_WIDTH + TABLE_BORDER_WIDTH;\n        },\n\n        /**\n         * Returns the position relative to the body-area.\n         * @param {Number} pageX - x-pos relative to document\n         * @param {Number} pageY - y-pos relative to document\n         * @returns {{x: number, y: number}}\n         * @private\n         */\n        getPositionFromBodyArea: function getPositionFromBodyArea(pageX, pageY) {\n          var bodyOffsetX = this.domState.getOffset().left;\n          var bodyOffsetY = this.getBodyOffsetTop();\n          return {\n            x: pageX - bodyOffsetX,\n            y: pageY - bodyOffsetY\n          };\n        }\n      });\n      module.exports = Dimension;\n      /***/\n    },\n    /* 22 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Manage coordinates of rows\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var util = __webpack_require__(17);\n\n      var Model = __webpack_require__(9);\n\n      var CELL_BORDER_WIDTH = __webpack_require__(10).dimension.CELL_BORDER_WIDTH;\n      /**\n       * @module model/coordRow\n       * @param {Object} attrs - Attributes\n       * @param {Object} options - Options\n       * @extends module:base/model\n       * @ignore\n       */\n\n\n      var CoordRow = Model.extend(\n      /** @lends module:model/coordRow.prototype */\n      {\n        initialize: function initialize(attrs, options) {\n          this.dataModel = options.dataModel;\n          this.dimensionModel = options.dimensionModel;\n          this.domState = options.domState;\n          /**\n           * Height of each rows\n           * @type {Array}\n           */\n\n          this.rowHeights = [];\n          /**\n           * Offset of each rows\n           * @type {Array}\n           */\n\n          this.rowOffsets = []; // Sync height and offest data when dataModel is changed only if the fixedRowHeight is true.\n          // If the fixedRowHeight is false, as the height of each row should be synced with DOM,\n          // syncWithDom() method is called instead at the end of rendering process.\n\n          if (this.dimensionModel.get('fixedRowHeight')) {\n            this.listenTo(this.dataModel, 'add remove reset sort', this.syncWithDataModel).listenTo(this.dataModel, 'expanded', this._onExpanded).listenTo(this.dataModel, 'collapsed', this._onCollapsed);\n          }\n        },\n\n        /**\n         * Event handler for 'expanded' event on dataModel using tree\n         * @param {object} ev - Event object\n         * @private\n         */\n        _onExpanded: function _onExpanded(ev) {\n          var rowKeys = ev.descendantRowKeys;\n\n          _.each(rowKeys, function (rowKey) {\n            var index = this.dataModel.indexOfRowKey(rowKey);\n            var row = this.dataModel.at(index);\n            this.rowHeights[index] = this._getRowHeight(row);\n          }, this);\n\n          this._resetOffsets();\n\n          this._setTotalRowHeight();\n        },\n\n        /**\n         * Event handler for 'collapsed' event on dataModel using tree\n         * @param {object} ev - Event object\n         * @private\n         */\n        _onCollapsed: function _onCollapsed(ev) {\n          var rowKeys = ev.descendantRowKeys;\n\n          _.each(rowKeys, function (rowKey) {\n            var index = this.dataModel.indexOfRowKey(rowKey);\n            this.rowHeights[index] = 0;\n          }, this);\n\n          this._resetOffsets();\n\n          this._setTotalRowHeight();\n        },\n\n        /**\n         * Get row height by value of data model or dimension model\n         * @param {module:model/data/row} row - data model\n         * @returns {nubmer} row height\n         * @private\n         */\n        _getRowHeight: function _getRowHeight(row) {\n          var defHeight = this.dimensionModel.get('rowHeight');\n          var height = row.getHeight();\n          return _.isNumber(height) ? height : defHeight;\n        },\n\n        /**\n         * Returns the height of rows from dataModel as an array\n         * @returns {Array.<number>}\n         * @private\n         */\n        _getHeightFromData: function _getHeightFromData() {\n          var rowHeights = [];\n          var height;\n          this.dataModel.each(function (row, index) {\n            height = this._getRowHeight(row);\n\n            if (!this.dataModel.isVisibleRow(row.get('rowKey'))) {\n              height = 0;\n            }\n\n            rowHeights[index] = height;\n          }, this);\n          return rowHeights;\n        },\n\n        /**\n         * Get offset of previous visible row by index\n         * @param {number} index - index of base row\n         * @returns {number} offset value\n         * @private\n         */\n        _getPreviousVisbleRowOffsetByIndex: function _getPreviousVisbleRowOffsetByIndex(index) {\n          var heights = this.rowHeights;\n          var len = 0;\n          var offset = -1;\n\n          for (; index >= len; index -= 1) {\n            if (heights[index]) {\n              break;\n            }\n\n            offset -= 1;\n          }\n\n          return offset;\n        },\n\n        /**\n         * Get offset of next visible row by index\n         * @param {number} index - index of base row\n         * @returns {number} offset value\n         * @private\n         */\n        _getNextVisibleRowOffsetByIndex: function _getNextVisibleRowOffsetByIndex(index) {\n          var heights = this.rowHeights;\n          var len = heights.length;\n          var offset = 1;\n\n          for (; index < len; index += 1) {\n            if (heights[index]) {\n              break;\n            }\n\n            offset += 1;\n          }\n\n          return offset;\n        },\n\n        /**\n         * Reset the list of offset via the list of each row's height\n         * @private\n         */\n        _resetOffsets: function _resetOffsets() {\n          var rowHeights = this.rowHeights;\n          var rowOffsets = [];\n          var prevIdx = 0;\n          var prevHeight, rowOffset;\n\n          _.each(rowHeights, function (height, index) {\n            if (height) {\n              prevHeight = index ? rowHeights[prevIdx] : rowHeights[0];\n              rowOffset = index ? prevHeight + rowOffsets[prevIdx] + CELL_BORDER_WIDTH : 0;\n              prevIdx = index;\n            } else {\n              rowOffset = -1;\n            }\n\n            rowOffsets[index] = rowOffset;\n          });\n\n          this.rowOffsets = rowOffsets;\n        },\n\n        /**\n         * Set the height value of total row height via heights and offsets\n         * @private\n         */\n        _setTotalRowHeight: function _setTotalRowHeight() {\n          var totalRowHeight = 0;\n          var rowHeights = this.rowHeights;\n          var rowOffsets = this.rowOffsets;\n          var rowHeightsLen = rowHeights.length;\n          var offset, visibleLastItemIdx;\n\n          if (rowHeightsLen) {\n            offset = this._getPreviousVisbleRowOffsetByIndex(rowHeightsLen - 1);\n            visibleLastItemIdx = rowHeightsLen + offset;\n            totalRowHeight = rowOffsets[visibleLastItemIdx] + rowHeights[visibleLastItemIdx] + CELL_BORDER_WIDTH;\n          }\n\n          this.dimensionModel.set('totalRowHeight', totalRowHeight);\n        },\n\n        /**\n         * Initialize the values of rowHeights and rowOffsets\n         * @param {Array.<number>} rowHeights - array of row height\n         * @private\n         */\n        _reset: function _reset(rowHeights) {\n          this.rowHeights = rowHeights;\n\n          this._resetOffsets();\n\n          this._setTotalRowHeight();\n\n          this.trigger('reset');\n        },\n\n        /**\n         * Refresh coordinate data with real DOM height of cells\n         */\n        syncWithDom: function syncWithDom() {\n          var domRowHeights, dataRowHeights, rowHeights;\n          var domHeightIdx = 0;\n          var i, len;\n\n          if (this.dimensionModel.get('fixedRowHeight')) {\n            return;\n          }\n\n          domRowHeights = this.domState.getRowHeights();\n          dataRowHeights = this._getHeightFromData();\n          rowHeights = [];\n\n          for (i = 0, len = dataRowHeights.length; i < len; i += 1) {\n            if (dataRowHeights[i]) {\n              rowHeights[i] = Math.max(domRowHeights[domHeightIdx], dataRowHeights[i]);\n              domHeightIdx += 1;\n            } else {\n              rowHeights[i] = 0;\n            }\n          }\n\n          this._reset(rowHeights);\n        },\n\n        /**\n         * Refresh coordinate data with extraData.height\n         */\n        syncWithDataModel: function syncWithDataModel() {\n          this._reset(this._getHeightFromData());\n        },\n\n        /**\n         * Returns the height of the row of given index\n         * @param {number} index - row index\n         * @returns {number}\n         */\n        getHeightAt: function getHeightAt(index) {\n          return this.rowHeights[index];\n        },\n\n        /**\n         * Returns the offset of the row of given index\n         * @param {number} index - row index\n         * @returns {number}\n         */\n        getOffsetAt: function getOffsetAt(index) {\n          return this.rowOffsets[index];\n        },\n\n        /**\n         * Returns the height of the row of the given rowKey\n         * @param {number} rowKey - rowKey\n         * @returns {number}\n         */\n        getHeight: function getHeight(rowKey) {\n          var index = this.dataModel.indexOfRowKey(rowKey);\n          return this.getHeightAt(index);\n        },\n\n        /**\n         * Returns the offset of the row of the given rowKey\n         * @param {number} rowKey - rowKey\n         * @returns {number}\n         */\n        getOffset: function getOffset(rowKey) {\n          var index = this.dataModel.indexOfRowKey(rowKey);\n          return this.getOffsetAt(index);\n        },\n\n        /**\n         * Returns the index of the row which contains given position\n         * @param {number} position - target position\n         * @returns {number}\n         */\n        indexOf: function indexOf(position) {\n          var rowOffsets = this.rowOffsets;\n          var idx = 0;\n          var hiddenRowsCnt = 0;\n          position += CELL_BORDER_WIDTH * 2;\n\n          while (rowOffsets[idx] - CELL_BORDER_WIDTH <= position) {\n            if (rowOffsets[idx] > -1) {\n              hiddenRowsCnt = 0;\n            } else {\n              hiddenRowsCnt += 1;\n            }\n\n            idx += 1;\n          }\n\n          return idx - hiddenRowsCnt - 1;\n        },\n\n        /**\n         * Returns the row index moved by body height from given row.\n         * @param {number} rowIdx - current row index\n         * @param {Boolean} isDownDir - true: down, false: up\n         * @returns {number}\n         */\n        getPageMovedIndex: function getPageMovedIndex(rowIdx, isDownDir) {\n          var curOffset = this.getOffsetAt(rowIdx);\n          var distance = this.dimensionModel.get('bodyHeight');\n          var movedIdx;\n\n          if (!isDownDir) {\n            distance = -distance;\n          }\n\n          movedIdx = this.indexOf(curOffset + distance);\n          return util.clamp(movedIdx, 0, this.dataModel.length - 1);\n        },\n\n        /**\n         * Get previous moved index by row heights\n         * @param {sring|number} rowKey - focused row key\n         * @returns {number} offset value of previous focusing row\n         */\n        getPreviousOffset: function getPreviousOffset(rowKey) {\n          var startIdx = this.dataModel.indexOfRowKey(rowKey);\n          var index = startIdx - 1;\n          return this._getPreviousVisbleRowOffsetByIndex(index);\n        },\n\n        /**\n         * Get next moved index by row heights\n         * @param {sring|number} rowKey - focused row key\n         * @returns {number} offset value of next focusing row\n         */\n        getNextOffset: function getNextOffset(rowKey) {\n          var startIdx = this.dataModel.indexOfRowKey(rowKey);\n          var index = startIdx + 1;\n          return this._getNextVisibleRowOffsetByIndex(index);\n        }\n      });\n      module.exports = CoordRow;\n      /***/\n    },\n    /* 23 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Manage coordinates of rows\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var Model = __webpack_require__(9);\n\n      var util = __webpack_require__(17);\n\n      var constMap = __webpack_require__(10);\n\n      var dimensionConst = constMap.dimension;\n      var frameConst = constMap.frame;\n      var CELL_BORDER_WIDTH = dimensionConst.CELL_BORDER_WIDTH;\n      /**\n       * @module model/coordColumn\n       * @param {Object} attrs - Attributes\n       * @param {Object} options - Options\n       * @extends module:base/model\n       * @ignore\n       */\n\n      var CoordColumn = Model.extend(\n      /** @lends module:model/coordColumn.prototype */\n      {\n        initialize: function initialize(attrs, options) {\n          this.dimensionModel = options.dimensionModel;\n          this.columnModel = options.columnModel;\n          /**\n           * An array of the fixed flags of the columns\n           * @private\n           * @type {boolean[]}\n           */\n\n          this._fixedWidthFlags = null;\n          /**\n           * An array of the minimum width of the columns\n           * @private\n           * @type {number[]}\n           */\n\n          this._minWidths = null;\n          /**\n           * Whether the column width is modified by user.\n           * @type {boolean}\n           */\n\n          this._isModified = false;\n          this.listenTo(this.columnModel, 'columnModelChange', this.resetColumnWidths);\n          this.listenTo(this.dimensionModel, 'change:width', this._onDimensionWidthChange);\n\n          if (options.domEventBus) {\n            this.listenTo(options.domEventBus, 'dragmove:resizeColumn', this._onDragResize);\n            this.listenTo(options.domEventBus, 'dblclick:resizeColumn', this._onDblClick);\n          }\n\n          this.resetColumnWidths();\n        },\n        defaults: {\n          widths: [],\n          resizable: true\n        },\n\n        /**\n         * Reset the width of each column by using initial setting of column models.\n         */\n        resetColumnWidths: function resetColumnWidths() {\n          var columns = this.columnModel.getVisibleColumns(null, true);\n          var commonMinWidth = this.dimensionModel.get('minimumColumnWidth');\n          var widths = [];\n          var fixedFlags = [];\n          var minWidths = [];\n\n          _.each(columns, function (columnModel) {\n            var columnWidth = columnModel.width || 'auto';\n            var fixedWidth = !isNaN(columnWidth);\n            var width, minWidth; // Meta columns are not affected by common 'minimumColumnWidth' value\n\n            if (util.isMetaColumn(columnModel.name)) {\n              minWidth = width;\n            } else {\n              minWidth = columnModel.minWidth || commonMinWidth;\n            }\n\n            width = fixedWidth ? columnWidth : minWidth;\n\n            if (width < minWidth) {\n              width = minWidth;\n            } // If the width is not assigned (in other words, the width is not positive number),\n            // set it to zero (no need to worry about minimum width at this point)\n            // so that #_fillEmptyWidth() can detect which one is empty.\n            // After then, minimum width will be applied by #_applyMinimumWidth().\n\n\n            widths.push(width);\n            minWidths.push(minWidth);\n            fixedFlags.push(fixedWidth);\n          }, this);\n\n          this._fixedWidthFlags = fixedFlags;\n          this._minWidths = minWidths;\n\n          this._setColumnWidthVariables(this._calculateColumnWidth(widths), true);\n        },\n\n        /**\n         * Event handler for dragmove event on domEventBus\n         * @param {module:event/gridEvent} ev - GridEvent\n         * @private\n         */\n        _onDragResize: function _onDragResize(ev) {\n          this.setColumnWidth(ev.columnIndex, ev.width);\n        },\n\n        /**\n         * Event handler for dblclick event on domEventBus\n         * @param {module:event/gridEventd} ev - GridEvent\n         * @private\n         */\n        _onDblClick: function _onDblClick(ev) {\n          this.restoreColumnWidth(ev.columnIndex);\n        },\n\n        /**\n         * widths 로 부터, lside 와 rside 의 전체 너비를 계산하여 저장한다.\n         * @param {array} widths - 컬럼 넓이값 배열\n         * @param {boolean} [saveWidths] - 저장 여부. true이면 넓이값 배열을 originalWidths로 저장한다.\n         * @private\n         */\n        _setColumnWidthVariables: function _setColumnWidthVariables(widths, saveWidths) {\n          var totalWidth = this.dimensionModel.get('width');\n          var frozenBorderWidth = this.dimensionModel.get('frozenBorderWidth');\n          var maxLeftSideWidth = this.dimensionModel.getMaxLeftSideWidth();\n          var frozenCount = this.columnModel.getVisibleFrozenCount(true);\n          var rsideWidth, lsideWidth, lsideWidths, rsideWidths;\n          lsideWidths = widths.slice(0, frozenCount);\n          rsideWidths = widths.slice(frozenCount);\n          lsideWidth = this._getFrameWidth(lsideWidths);\n\n          if (maxLeftSideWidth && maxLeftSideWidth < lsideWidth) {\n            lsideWidths = this._adjustLeftSideWidths(lsideWidths, maxLeftSideWidth);\n            lsideWidth = this._getFrameWidth(lsideWidths);\n            widths = lsideWidths.concat(rsideWidths);\n          }\n\n          rsideWidth = totalWidth - lsideWidth;\n          this.set({\n            widths: widths\n          });\n          this.dimensionModel.set({\n            rsideWidth: rsideWidth,\n            lsideWidth: lsideWidth - frozenBorderWidth\n          });\n\n          if (saveWidths) {\n            this.set('originalWidths', _.clone(widths));\n          }\n\n          this.trigger('columnWidthChanged');\n        },\n\n        /**\n         * columnFrozenCount 가 적용되었을 때, window resize 시 left side 의 너비를 조정한다.\n         * @param {Array} lsideWidths    열고정 영역의 너비 리스트 배열\n         * @param {Number} totalWidth   grid 전체 너비\n         * @returns {Array} 열고정 영역의 너비 리스트\n         * @private\n         */\n        _adjustLeftSideWidths: function _adjustLeftSideWidths(lsideWidths, totalWidth) {\n          var i = lsideWidths.length - 1;\n          var minimumColumnWidth = this.dimensionModel.get('minimumColumnWidth');\n\n          var currentWidth = this._getFrameWidth(lsideWidths);\n\n          var diff = currentWidth - totalWidth;\n          var changedWidth;\n\n          if (diff > 0) {\n            while (i >= 0 && diff > 0) {\n              changedWidth = Math.max(minimumColumnWidth, lsideWidths[i] - diff);\n              diff -= lsideWidths[i] - changedWidth;\n              lsideWidths[i] = changedWidth;\n              i -= 1;\n            }\n          } else if (diff < 0) {\n            lsideWidths[i] += Math.abs(diff);\n          }\n\n          return lsideWidths;\n        },\n\n        /**\n         * calculate column width list\n         * @param {Array.<Number>} widths - widths\n         * @returns {Array.<Number>}\n         * @private\n         */\n        _calculateColumnWidth: function _calculateColumnWidth(widths) {\n          widths = this._fillEmptyWidth(widths);\n          widths = this._applyMinimumWidth(widths);\n          widths = this._adjustWidths(widths);\n          return widths;\n        },\n\n        /**\n         * Sets the width of columns whose width is not assigned by distributing extra width to them equally.\n         * @param {number[]} widths - An array of column widths\n         * @returns {number[]} - A new array of column widths\n         * @private\n         */\n        _fillEmptyWidth: function _fillEmptyWidth(widths) {\n          var totalWidth = this.dimensionModel.getAvailableTotalWidth(widths.length);\n          var remainTotalWidth = totalWidth - util.sum(widths);\n          var emptyIndexes = [];\n\n          _.each(widths, function (width, index) {\n            if (!width) {\n              emptyIndexes.push(index);\n            }\n          });\n\n          return this._distributeExtraWidthEqually(widths, remainTotalWidth, emptyIndexes);\n        },\n\n        /**\n         * widths 로부터 보더 값을 포함하여 계산한 frameWidth 를 구한다.\n         * @param {Array} widths 너비 리스트 배열\n         * @returns {Number} 계산된 frame 너비값\n         * @private\n         */\n        _getFrameWidth: function _getFrameWidth(widths) {\n          var frameWidth = 0;\n\n          if (widths.length) {\n            frameWidth = util.sum(widths) + (widths.length + 1) * CELL_BORDER_WIDTH;\n          }\n\n          return frameWidth;\n        },\n\n        /**\n         * Adds extra widths of the column equally.\n         * @param {number[]} widths - An array of column widths\n         * @param {number} totalExtraWidth - Total extra width\n         * @returns {number[]} - A new array of column widths\n         * @private\n         */\n        _addExtraColumnWidth: function _addExtraColumnWidth(widths, totalExtraWidth) {\n          var fixedFlags = this._fixedWidthFlags;\n          var columnIndexes = [];\n\n          _.each(fixedFlags, function (flag, index) {\n            if (!flag) {\n              columnIndexes.push(index);\n            }\n          });\n\n          return this._distributeExtraWidthEqually(widths, totalExtraWidth, columnIndexes);\n        },\n\n        /**\n         * Reduces excess widths of the column equally.\n         * @param {number[]} widths - An array of column widths\n         * @param {number} totalExcessWidth - Total excess width (negative number)\n         * @returns {number[]} - A new array of column widths\n         * @private\n         */\n        _reduceExcessColumnWidth: function _reduceExcessColumnWidth(widths, totalExcessWidth) {\n          var minWidths = this._minWidths;\n          var fixedFlags = this._fixedWidthFlags;\n          var availableList = [];\n\n          _.each(widths, function (width, index) {\n            if (!fixedFlags[index]) {\n              availableList.push({\n                index: index,\n                width: width - minWidths[index]\n              });\n            }\n          });\n\n          return this._reduceExcessColumnWidthSub(_.clone(widths), totalExcessWidth, availableList);\n        },\n\n        /**\n         * Reduce the (remaining) excess widths of the column.\n         * This method will be called recursively by _reduceExcessColumnWidth.\n         * @param {number[]} widths - An array of column Width\n         * @param {number} totalRemainWidth - Remaining excess width (negative number)\n         * @param {object[]} availableList - An array of infos about available column.\n         *                                 Each item of the array has {index:number, width:number}.\n         * @returns {number[]} - A new array of column widths\n         * @private\n         */\n        _reduceExcessColumnWidthSub: function _reduceExcessColumnWidthSub(widths, totalRemainWidth, availableList) {\n          var avgValue = Math.round(totalRemainWidth / availableList.length);\n          var newAvailableList = [];\n          var columnIndexes;\n\n          _.each(availableList, function (available) {\n            // note that totalRemainWidth and avgValue are negative number.\n            if (available.width < Math.abs(avgValue)) {\n              totalRemainWidth += available.width;\n              widths[available.index] -= available.width;\n            } else {\n              newAvailableList.push(available);\n            }\n          }); // call recursively until all available width are less than average\n\n\n          if (availableList.length > newAvailableList.length) {\n            return this._reduceExcessColumnWidthSub(widths, totalRemainWidth, newAvailableList);\n          }\n\n          columnIndexes = _.pluck(availableList, 'index');\n          return this._distributeExtraWidthEqually(widths, totalRemainWidth, columnIndexes);\n        },\n\n        /**\n         * Distributes the extra width equally to each column at specified indexes.\n         * @param {number[]} widths - An array of column width\n         * @param {number} extraWidth - Extra width\n         * @param {number[]} columnIndexes - An array of indexes of target columns\n         * @returns {number[]} - A new array of column widths\n         * @private\n         */\n        _distributeExtraWidthEqually: function _distributeExtraWidthEqually(widths, extraWidth, columnIndexes) {\n          var length = columnIndexes.length;\n          var avgValue = Math.round(extraWidth / length);\n          var errorValue = avgValue * length - extraWidth; // to correct total width\n\n          var resultList = _.clone(widths);\n\n          _.each(columnIndexes, function (columnIndex) {\n            resultList[columnIndex] += avgValue;\n          });\n\n          if (columnIndexes.length) {\n            resultList[_.last(columnIndexes)] -= errorValue;\n          }\n\n          return resultList;\n        },\n\n        /**\n         * Makes all width of columns not less than minimumColumnWidth.\n         * @param {number[]} widths - 컬럼 넓이값 배열\n         * @returns {number[]} - 수정된 새로운 넓이값 배열\n         * @private\n         */\n        _applyMinimumWidth: function _applyMinimumWidth(widths) {\n          var minWidths = this._minWidths;\n\n          var appliedList = _.clone(widths);\n\n          _.each(appliedList, function (width, index) {\n            var minWidth = minWidths[index];\n\n            if (width < minWidth) {\n              appliedList[index] = minWidth;\n            }\n          });\n\n          return appliedList;\n        },\n\n        /**\n         * Adjust the column widths to make them fit into the dimension.\n         * @param {number[]} widths - An array of column width\n         * @param {boolean} [fitToReducedTotal] - If set to true and the total width is smaller than dimension(width),\n         *                                    the column widths will be reduced.\n         * @returns {number[]} - A new array of column widths\n         * @private\n         */\n        _adjustWidths: function _adjustWidths(widths, fitToReducedTotal) {\n          var columnLength = widths.length;\n          var availableWidth = this.dimensionModel.getAvailableTotalWidth(columnLength);\n          var totalExtraWidth = availableWidth - util.sum(widths);\n\n          var fixedCount = _.filter(this._fixedWidthFlags).length;\n\n          var adjustedWidths;\n\n          if (totalExtraWidth > 0 && columnLength > fixedCount) {\n            adjustedWidths = this._addExtraColumnWidth(widths, totalExtraWidth);\n          } else if (fitToReducedTotal && totalExtraWidth < 0) {\n            adjustedWidths = this._reduceExcessColumnWidth(widths, totalExtraWidth);\n          } else {\n            adjustedWidths = widths;\n          }\n\n          return adjustedWidths;\n        },\n\n        /**\n         * width 값 변경시 각 column 별 너비를 계산한다.\n         * @private\n         */\n        _onDimensionWidthChange: function _onDimensionWidthChange() {\n          var widths = this.get('widths');\n\n          if (!this._isModified) {\n            widths = this._adjustWidths(widths, true);\n          }\n\n          this._setColumnWidthVariables(widths);\n        },\n\n        /**\n         * L side 와 R side 에 따른 widths 를 반환한다.\n         * @param {String} [whichSide] 어느 영역인지 여부. L,R 중 하나를 인자로 넘긴다. 생략시 전체 columnList 반환\n         * @returns {Array}  조회한 영역의 widths\n         */\n        getWidths: function getWidths(whichSide) {\n          var columnFrozenCount = this.columnModel.getVisibleFrozenCount(true);\n          var widths = [];\n\n          switch (whichSide) {\n            case frameConst.L:\n              widths = this.get('widths').slice(0, columnFrozenCount);\n              break;\n\n            case frameConst.R:\n              widths = this.get('widths').slice(columnFrozenCount);\n              break;\n\n            default:\n              widths = this.get('widths');\n              break;\n          }\n\n          return widths;\n        },\n\n        /**\n         * L, R 중 하나를 입력받아 frame 의 너비를 구한다.\n         * @param {String} [whichSide]  지정하지 않을 경우 전체 너비.\n         * @returns {Number} 해당 frame 의 너비\n         */\n        getFrameWidth: function getFrameWidth(whichSide) {\n          var columnFrozenCount = this.columnModel.getVisibleFrozenCount(true);\n          var widths = this.getWidths(whichSide);\n\n          var frameWidth = this._getFrameWidth(widths);\n\n          if (_.isUndefined(whichSide) && columnFrozenCount > 0) {\n            frameWidth += CELL_BORDER_WIDTH;\n          }\n\n          return frameWidth;\n        },\n\n        /**\n         * columnResize 발생 시 index 에 해당하는 컬럼의 width 를 변경하여 반영한다.\n         * @param {Number} index    너비를 변경할 컬럼의 인덱스\n         * @param {Number} width    변경할 너비 pixel값\n         */\n        setColumnWidth: function setColumnWidth(index, width) {\n          var widths = this.get('widths');\n          var minWidth = this._minWidths[index];\n\n          if (widths[index]) {\n            widths[index] = Math.max(width, minWidth);\n\n            this._setColumnWidthVariables(widths);\n\n            this._isModified = true;\n          }\n        },\n\n        /**\n         * Returns column index from X-position relative to the body-area\n         * @param {number} posX - X-position relative to the body-area\n         * @param {boolean} withMeta - Whether the meta columns go with this calculation\n         * @returns {number} Column index\n         * @private\n         */\n        indexOf: function indexOf(posX, withMeta) {\n          var widths = this.getWidths();\n          var totalColumnWidth = this.getFrameWidth();\n          var adjustableIndex = withMeta ? 0 : this.columnModel.getVisibleMetaColumnCount();\n          var columnIndex = 0;\n\n          if (posX >= totalColumnWidth) {\n            columnIndex = widths.length - 1;\n          } else {\n            snippet.forEachArray(widths, function (width, index) {\n              // eslint-disable-line consistent-return\n              width += CELL_BORDER_WIDTH;\n              columnIndex = index;\n\n              if (posX > width) {\n                posX -= width;\n              } else {\n                return false;\n              }\n            });\n          }\n\n          return Math.max(0, columnIndex - adjustableIndex);\n        },\n\n        /**\n         * Restore a column to the default width.\n         * @param {Number} index - target column index\n         */\n        restoreColumnWidth: function restoreColumnWidth(index) {\n          var orgWidth = this.get('originalWidths')[index];\n          this.setColumnWidth(index, orgWidth);\n        }\n      });\n      module.exports = CoordColumn;\n      /***/\n    },\n    /* 24 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Converts coordinates to index of rows and columns\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var snippet = __webpack_require__(3);\n\n      var Model = __webpack_require__(9);\n\n      var dimensionConstMap = __webpack_require__(10).dimension;\n\n      var TABLE_BORDER_WIDTH = dimensionConstMap.TABLE_BORDER_WIDTH;\n      var CELL_BORDER_WIDTH = dimensionConstMap.CELL_BORDER_WIDTH;\n      /**\n       * @module model/coordConverter\n       * @param {Object} attrs - Attributes\n       * @param {Object} options - Options\n       * @extends module:base/model\n       * @ignore\n       */\n\n      var CoordConverter = Model.extend(\n      /** @lends module:model/coordConverter.prototype */\n      {\n        initialize: function initialize(attrs, options) {\n          this.dataModel = options.dataModel;\n          this.columnModel = options.columnModel;\n          this.focusModel = options.focusModel;\n          this.dimensionModel = options.dimensionModel;\n          this.renderModel = options.renderModel;\n          this.coordRowModel = options.coordRowModel;\n          this.coordColumnModel = options.coordColumnModel;\n          this.listenTo(this.focusModel, 'focus', this._onFocus);\n        },\n\n        /**\n         * Get cell index from mouse position\n         * @param {Number} pageX - Mouse X-position based on page\n         * @param {Number} pageY - Mouse Y-position based on page\n         * @param {boolean} [withMeta] - Whether the meta columns go with this calculation\n         * @returns {{row: number, column: number}} Cell index\n         */\n        getIndexFromMousePosition: function getIndexFromMousePosition(pageX, pageY, withMeta) {\n          var position = this.dimensionModel.getPositionFromBodyArea(pageX, pageY);\n\n          var posWithScroll = this._getScrolledPosition(position);\n\n          return {\n            row: this.coordRowModel.indexOf(posWithScroll.y),\n            column: this.coordColumnModel.indexOf(posWithScroll.x, withMeta)\n          };\n        },\n\n        /**\n         * Returns the scrolled position in addition to given position\n         * @param {{x: number, y: number}} position - position\n         * @returns {{x: number, y: number}}\n         * @private\n         */\n        _getScrolledPosition: function _getScrolledPosition(position) {\n          var renderModel = this.renderModel;\n          var isRside = position.x > this.dimensionModel.get('lsideWidth');\n          var scrollLeft = isRside ? renderModel.get('scrollLeft') : 0;\n          var scrollTop = renderModel.get('scrollTop');\n          return {\n            x: position.x + scrollLeft,\n            y: position.y + scrollTop\n          };\n        },\n\n        /**\n         * Returns the count of rowspan of given cell\n         * @param {Number} rowKey - row key\n         * @param {String} columnName - column name\n         * @returns {Number}\n         * @private\n         */\n        _getRowSpanCount: function _getRowSpanCount(rowKey, columnName) {\n          var rowSpanData = this.dataModel.get(rowKey).getRowSpanData(columnName);\n\n          if (!rowSpanData.isMainRow) {\n            rowKey = rowSpanData.mainRowKey;\n            rowSpanData = this.dataModel.get(rowKey).getRowSpanData(columnName);\n          }\n\n          return rowSpanData.count || 1;\n        },\n\n        /**\n         * Returns the vertical position of the given row\n         * @param {Number} rowKey - row key\n         * @param {Number} rowSpanCount - the count of rowspan\n         * @returns {{top: Number, bottom: Number}}\n         * @private\n         */\n        _getCellVerticalPosition: function _getCellVerticalPosition(rowKey, rowSpanCount) {\n          var firstIdx, lastIdx, top, bottom;\n          var coordRowModel = this.coordRowModel;\n          firstIdx = this.dataModel.indexOfRowKey(rowKey);\n          lastIdx = firstIdx + rowSpanCount - 1;\n          top = coordRowModel.getOffsetAt(firstIdx);\n          bottom = coordRowModel.getOffsetAt(lastIdx) + coordRowModel.getHeightAt(lastIdx) + CELL_BORDER_WIDTH;\n          return {\n            top: top,\n            bottom: bottom\n          };\n        },\n\n        /**\n         * Returns the horizontal position of the given column\n         * @param {String} columnName - column name\n         * @returns {{left: Number, right: Number}}\n         * @private\n         */\n        _getCellHorizontalPosition: function _getCellHorizontalPosition(columnName) {\n          var columnModel = this.columnModel;\n          var metaColumnCount = columnModel.getVisibleMetaColumnCount();\n          var widths = this.coordColumnModel.get('widths');\n          var leftColumnCount = columnModel.getVisibleFrozenCount() + metaColumnCount;\n          var targetIdx = columnModel.indexOfColumnName(columnName, true) + metaColumnCount;\n          var idx = leftColumnCount > targetIdx ? 0 : leftColumnCount;\n          var left = 0;\n\n          for (; idx < targetIdx; idx += 1) {\n            left += widths[idx] + CELL_BORDER_WIDTH;\n          }\n\n          return {\n            left: left,\n            right: left + widths[targetIdx] + CELL_BORDER_WIDTH\n          };\n        },\n\n        /**\n         * Returns the bounds of the cell identified by given address\n         * @param {Number|String} rowKey - row key\n         * @param {String} columnName - column name\n         * @returns {{top: number, left: number, right: number, bottom: number}}\n         * @todo TC\n         */\n        getCellPosition: function getCellPosition(rowKey, columnName) {\n          var rowSpanCount, vPos, hPos;\n          rowKey = this.dataModel.getMainRowKey(rowKey, columnName);\n\n          if (!this.dataModel.get(rowKey)) {\n            return {};\n          }\n\n          rowSpanCount = this._getRowSpanCount(rowKey, columnName);\n          vPos = this._getCellVerticalPosition(rowKey, rowSpanCount);\n          hPos = this._getCellHorizontalPosition(columnName);\n          return {\n            top: vPos.top,\n            bottom: vPos.bottom,\n            left: hPos.left,\n            right: hPos.right\n          };\n        },\n\n        /**\n         * Judge scroll direction.\n         * @param {{top: number, bottom: number, left: number, right: number}} targetPosition - Position of target element\n         * @param {boolean} isRsideColumn - Whether the target cell is in rside\n         * @param {{height: number, rsideWidth: number}} bodySize - Using cached bodySize\n         * @returns {{isUp: boolean, isDown: boolean, isLeft: boolean, isRight: boolean}} Direction\n         * @private\n         */\n        _judgeScrollDirection: function _judgeScrollDirection(targetPosition, isRsideColumn, bodySize) {\n          var renderModel = this.renderModel;\n          var currentTop = renderModel.get('scrollTop');\n          var currentLeft = renderModel.get('scrollLeft');\n          var isUp, isDown, isLeft, isRight;\n          isUp = targetPosition.top < currentTop;\n          isDown = !isUp && targetPosition.bottom > currentTop + bodySize.height;\n\n          if (isRsideColumn) {\n            isLeft = targetPosition.left < currentLeft;\n            isRight = !isLeft && targetPosition.right > currentLeft + bodySize.rsideWidth - 1;\n          } else {\n            isLeft = isRight = false;\n          }\n\n          return {\n            isUp: isUp,\n            isDown: isDown,\n            isLeft: isLeft,\n            isRight: isRight\n          };\n        },\n\n        /**\n         * Scroll to focus\n         * @param {number} rowKey - row key\n         * @param {string} columnName - column name\n         * @param {boolean} shouldScroll - whether scroll to the target cell\n         * @private\n         */\n        _onFocus: function _onFocus(rowKey, columnName, shouldScroll) {\n          var scrollPosition;\n\n          if (!shouldScroll) {\n            return;\n          }\n\n          scrollPosition = this.getScrollPosition(rowKey, columnName);\n\n          if (!snippet.isEmpty(scrollPosition)) {\n            this.renderModel.set(scrollPosition);\n          }\n        },\n\n        /**\n         * Make scroll position\n         * @param {{isUp: boolean, isDown: boolean, isLeft: boolean, isRight: boolean}} scrollDirection - Direction\n         * @param {{top: number, bottom: number, left: number, right: number}} targetPosition - Position of target element\n         * @param {{height: number, rsideWidth: number}} bodySize - Using cached bodySize\n         * @returns {{scrollLeft: ?Number, scrollTop: ?Number}} Position to scroll\n         * @private\n         */\n        _makeScrollPosition: function _makeScrollPosition(scrollDirection, targetPosition, bodySize) {\n          var pos = {};\n\n          if (scrollDirection.isUp) {\n            pos.scrollTop = targetPosition.top;\n          } else if (scrollDirection.isDown) {\n            pos.scrollTop = targetPosition.bottom - bodySize.height;\n          }\n\n          if (scrollDirection.isLeft) {\n            pos.scrollLeft = targetPosition.left;\n          } else if (scrollDirection.isRight) {\n            pos.scrollLeft = targetPosition.right - bodySize.rsideWidth + TABLE_BORDER_WIDTH;\n          }\n\n          return pos;\n        },\n\n        /**\n         * Return scroll position from the received index\n         * @param {Number|String} rowKey - Row-key of target cell\n         * @param {String} columnName - Column name of target cell\n         * @returns {{scrollLeft: ?Number, scrollTop: ?Number}} Position to scroll\n         */\n        getScrollPosition: function getScrollPosition(rowKey, columnName) {\n          var isRsideColumn = !this.columnModel.isLside(columnName);\n          var targetPosition = this.getCellPosition(rowKey, columnName);\n          var bodySize = this.dimensionModel.getBodySize();\n\n          var scrollDirection = this._judgeScrollDirection(targetPosition, isRsideColumn, bodySize);\n\n          return this._makeScrollPosition(scrollDirection, targetPosition, bodySize);\n        }\n      });\n      module.exports = CoordConverter;\n      /***/\n    },\n    /* 25 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Focus Model\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var Model = __webpack_require__(9);\n\n      var util = __webpack_require__(17);\n\n      var GridEvent = __webpack_require__(16);\n      /**\n       * whether using mobile browser\n       * @type {boolean}\n       * @private\n       */\n\n\n      var _isMobile = util.isMobile();\n      /**\n       * Focus model\n       * @param {Object} attrs - Attributes\n       * @param {Object} options - Options\n       * @module model/focus\n       * @extends module:base/model\n       * @ignore\n       */\n\n\n      var Focus = Model.extend(\n      /** @lends module:model/focus.prototype */\n      {\n        initialize: function initialize(attrs, options) {\n          var editEventName = options.editingEvent + ':cell';\n          var domEventBus;\n          Model.prototype.initialize.apply(this, arguments);\n\n          _.assign(this, {\n            dataModel: options.dataModel,\n            columnModel: options.columnModel,\n            coordRowModel: options.coordRowModel,\n            domEventBus: options.domEventBus,\n            domState: options.domState\n          });\n\n          this.listenTo(this.dataModel, 'reset', this._onResetData);\n          this.listenTo(this.dataModel, 'add', this._onAddDataModel);\n\n          if (this.domEventBus) {\n            domEventBus = this.domEventBus;\n            this.listenTo(domEventBus, editEventName, this._onMouseClickEdit);\n            this.listenTo(domEventBus, 'mousedown:focus', this._onMouseDownFocus);\n            this.listenTo(domEventBus, 'key:move', this._onKeyMove);\n            this.listenTo(domEventBus, 'key:edit', this._onKeyEdit);\n          }\n        },\n        defaults: {\n          /**\n           * row key of the current cell\n           * @type {String|Number}\n           */\n          rowKey: null,\n\n          /**\n           * column name of the current cell\n           * @type {String}\n           */\n          columnName: null,\n\n          /**\n           * row key of the previously focused cell\n           * @type {String|Number}\n           */\n          prevRowKey: null,\n\n          /**\n           * column name of the previously focused cell\n           * @type {String}\n           */\n          prevColumnName: '',\n\n          /**\n           * address of the editing cell\n           * @type {{rowKey:(String|Number), columnName:String}}\n           */\n          editingAddress: null,\n\n          /**\n           * Whether focus state is active or not\n           * @type {Boolean}\n           */\n          active: false\n        },\n\n        /**\n         * Event handler for 'reset' event on dataModel.\n         * @private\n         */\n        _onResetData: function _onResetData() {\n          this.blur();\n        },\n\n        /**\n         * Event handler for 'add' event on dataModel.\n         * @param  {module:model/data/rowList} dataModel - data model\n         * @param  {Object} options - options for appending. See {@link module:model/data/rowList#append}\n         * @private\n         */\n        _onAddDataModel: function _onAddDataModel(dataModel, options) {\n          if (options.focus) {\n            this.focusAt(options.at, 0);\n          }\n        },\n\n        /**\n         * Event handler for 'click:cell' or 'dblclick:cell' event on domEventBus\n         * @param {module:event/gridEvent} ev - event data\n         * @private\n         */\n        _onMouseClickEdit: function _onMouseClickEdit(ev) {\n          this.focusIn(ev.rowKey, ev.columnName);\n        },\n\n        /* eslint-disable complexity */\n\n        /**\n         * Event handler for key:move event\n         * @param {module:event/gridEvent} ev - GridEvent\n         * @private\n         */\n        _onKeyMove: function _onKeyMove(ev) {\n          var rowKey, columnName;\n\n          switch (ev.command) {\n            case 'up':\n              rowKey = this.prevRowKey();\n              break;\n\n            case 'down':\n              rowKey = this.nextRowKey();\n              break;\n\n            case 'left':\n              columnName = this.prevColumnName();\n              break;\n\n            case 'right':\n              columnName = this.nextColumnName();\n              break;\n\n            case 'pageUp':\n              rowKey = this._getPageMovedRowKey(false);\n              break;\n\n            case 'pageDown':\n              rowKey = this._getPageMovedRowKey(true);\n              break;\n\n            case 'firstColumn':\n              columnName = this.firstColumnName();\n              break;\n\n            case 'lastColumn':\n              columnName = this.lastColumnName();\n              break;\n\n            case 'firstCell':\n              rowKey = this.firstRowKey();\n              columnName = this.firstColumnName();\n              break;\n\n            case 'lastCell':\n              rowKey = this.lastRowKey();\n              columnName = this.lastColumnName();\n              break;\n\n            default:\n          }\n\n          rowKey = _.isUndefined(rowKey) ? this.get('rowKey') : rowKey;\n          columnName = columnName || this.get('columnName');\n          this.focus(rowKey, columnName, true);\n        },\n\n        /* eslint-enable complexity */\n\n        /**\n         * Event handler for key:edit event\n         * @param {module:event/gridEvent} ev - GridEvent\n         * @private\n         */\n        _onKeyEdit: function _onKeyEdit(ev) {\n          var address;\n\n          switch (ev.command) {\n            case 'currentCell':\n              address = this.which();\n              break;\n\n            case 'nextCell':\n              address = this.nextAddress();\n              break;\n\n            case 'prevCell':\n              address = this.prevAddress();\n              break;\n\n            default:\n          }\n\n          if (address) {\n            this.focusIn(address.rowKey, address.columnName, true);\n          }\n        },\n\n        /**\n         * Returns the moved rowKey by page unit from current position\n         * @param {boolean} isDownDir - true: down, false: up\n         * @returns {number}\n         * @private\n         */\n        _getPageMovedRowKey: function _getPageMovedRowKey(isDownDir) {\n          var rowIndex = this.dataModel.indexOfRowKey(this.get('rowKey'));\n          var prevPageRowIndex = this.coordRowModel.getPageMovedIndex(rowIndex, isDownDir);\n          var rowKey;\n\n          if (isDownDir) {\n            rowKey = this.nextRowKey(prevPageRowIndex - rowIndex);\n          } else {\n            rowKey = this.prevRowKey(rowIndex - prevPageRowIndex);\n          }\n\n          return rowKey;\n        },\n\n        /**\n         * Event handler for 'mousedown' event on domEventBus\n         * @private\n         */\n        _onMouseDownFocus: function _onMouseDownFocus() {\n          this.focusClipboard();\n        },\n\n        /**\n         * Saves previous data.\n         * @private\n         */\n        _savePrevious: function _savePrevious() {\n          if (this.get('rowKey') !== null) {\n            this.set('prevRowKey', this.get('rowKey'));\n          }\n\n          if (this.get('columnName')) {\n            this.set('prevColumnName', this.get('columnName'));\n          }\n        },\n\n        /**\n         * Returns whether given rowKey and columnName is equal to current value\n         * @param {(Number|String)} rowKey - row key\n         * @param {String} columnName - column name\n         * @param {Boolean} isMainRowKey - true if the target row key is main row\n         * @returns {Boolean} - True if equal\n         */\n        isCurrentCell: function isCurrentCell(rowKey, columnName, isMainRowKey) {\n          var curColumnName = this.get('columnName');\n          var curRowKey = this.get('rowKey');\n\n          if (isMainRowKey) {\n            curRowKey = this.dataModel.getMainRowKey(curRowKey, curColumnName);\n          }\n\n          return String(curRowKey) === String(rowKey) && curColumnName === columnName;\n        },\n\n        /* eslint-disable complexity */\n\n        /**\n         * Focus to the cell identified by given rowKey and columnName.\n         * @param {Number|String} rowKey - rowKey\n         * @param {String} columnName - columnName\n         * @param {Boolean} isScrollable - if set to true, move scroll position to focused position\n         * @returns {Boolean} true if focused cell is changed\n         */\n        focus: function focus(rowKey, columnName, isScrollable) {\n          if (!this.get('active')) {\n            this.set('active', true);\n          }\n\n          if (!this._isValidCell(rowKey, columnName) || util.isMetaColumn(columnName) || this.isCurrentCell(rowKey, columnName)) {\n            return true;\n          }\n\n          if (!this._triggerFocusChangeEvent(rowKey, columnName)) {\n            return false;\n          }\n\n          this.blur();\n          this.set({\n            rowKey: rowKey,\n            columnName: columnName\n          });\n          this.trigger('focus', rowKey, columnName, isScrollable);\n\n          if (this.columnModel.get('selectType') === 'radio') {\n            this.dataModel.check(rowKey);\n          }\n\n          return true;\n        },\n\n        /* eslint-enable complexity */\n\n        /**\n         * Trigger 'focusChange' event and returns the result\n         * @param {(number|string)} rowKey - rowKey\n         * @param {stringd} columnName - columnName\n         * @returns {boolean}\n         * @private\n         */\n        _triggerFocusChangeEvent: function _triggerFocusChangeEvent(rowKey, columnName) {\n          var gridEvent = new GridEvent(null, {\n            rowKey: rowKey,\n            prevRowKey: this.get('rowKey'),\n            columnName: columnName,\n            prevColumnName: this.get('columnName')\n          });\n          /**\n           * Occurs when focused cell is about to change\n           * @api\n           * @event Grid#focusChange\n           * @type {module:event/gridEvent}\n           * @property {number} rowKey - rowKey of the target cell\n           * @property {number} columnName - columnName of the target cell\n           * @property {number} prevRowKey - rowKey of the currently focused cell\n           * @property {number} prevColumnName - columnName of the currently focused cell\n           * @property {Grid} instance - Current grid instance\n           */\n\n          this.trigger('focusChange', gridEvent);\n          return !gridEvent.isStopped();\n        },\n\n        /**\n         * Focus to the cell identified by given rowIndex and columnIndex.\n         * @param {(Number|String)} rowIndex - rowIndex\n         * @param {String} columnIndex - columnIndex\n         * @param {boolean} [isScrollable=false] - if set to true, scroll to focused cell\n         * @returns {Boolean} true if success\n         */\n        focusAt: function focusAt(rowIndex, columnIndex, isScrollable) {\n          var row = this.dataModel.at(rowIndex);\n          var column = this.columnModel.at(columnIndex, true);\n          var result = false;\n\n          if (row && column) {\n            result = this.focus(row.get('rowKey'), column.name, isScrollable);\n          }\n\n          return result;\n        },\n\n        /**\n         * Focus to the cell identified by given rowKey and columnName and change it to edit-mode if editable.\n         * @param {(Number|String)} rowKey - rowKey\n         * @param {String} columnName - columnName\n         * @param {boolean} [isScrollable=false] - if set to true, scroll to focused cell\n         * @returns {Boolean} true if success\n         */\n        focusIn: function focusIn(rowKey, columnName, isScrollable) {\n          var result = this.focus(rowKey, columnName, isScrollable);\n\n          if (result) {\n            rowKey = this.dataModel.getMainRowKey(rowKey, columnName);\n\n            if (this.dataModel.get(rowKey).isEditable(columnName)) {\n              this.finishEditing();\n              this.startEditing(rowKey, columnName);\n            } else {\n              this.focusClipboard();\n            }\n          }\n\n          return result;\n        },\n\n        /**\n         * Focus to the cell identified by given rowIndex and columnIndex and change it to edit-mode if editable.\n         * @param {(Number|String)} rowIndex - rowIndex\n         * @param {String} columnIndex - columnIndex\n         * @param {Boolean} [isScrollable=false] - if set to true, scroll to focused cell\n         * @returns {Boolean} true if success\n         */\n        focusInAt: function focusInAt(rowIndex, columnIndex, isScrollable) {\n          var row = this.dataModel.at(rowIndex);\n          var column = this.columnModel.at(columnIndex, true);\n          var result = false;\n\n          if (row && column) {\n            result = this.focusIn(row.get('rowKey'), column.name, isScrollable);\n          }\n\n          return result;\n        },\n\n        /**\n         * clipboard 에 focus 한다.\n         */\n        focusClipboard: function focusClipboard() {\n          if (!_isMobile) {\n            this.trigger('focusClipboard');\n          }\n        },\n\n        /**\n         * If the grid has an element which has a focus, make sure that focusModel has a valid data,\n         * Otherwise change the focus state.\n         */\n        refreshState: function refreshState() {\n          var restored;\n\n          if (!this.domState.hasFocusedElement()) {\n            this.set('active', false);\n          } else if (!this.has()) {\n            restored = this.restore();\n\n            if (!restored) {\n              this.focusAt(0, 0);\n            }\n          }\n        },\n\n        /**\n         * Apply blur state on cell\n         * @returns {Model.Focus} This object\n         */\n        blur: function blur() {\n          if (!this.has()) {\n            return this;\n          }\n\n          if (this.has(true)) {\n            this._savePrevious();\n          }\n\n          this.trigger('blur', this.get('rowKey'), this.get('columnName'));\n          this.set({\n            rowKey: null,\n            columnName: null\n          });\n          return this;\n        },\n\n        /**\n         * 현재 focus 정보를 반환한다.\n         * @returns {{rowKey: (number|string), columnName: string}} 현재 focus 정보에 해당하는 rowKey, columnName\n         */\n        which: function which() {\n          return {\n            rowKey: this.get('rowKey'),\n            columnName: this.get('columnName')\n          };\n        },\n\n        /**\n         * 현재 focus 정보를 index 기준으로 반환한다.\n         * @param {boolean} isPrevious 이전 focus 정보를 반환할지 여부\n         * @returns {{row: number, column: number}} The object that contains index info\n         */\n        indexOf: function indexOf(isPrevious) {\n          var rowKey = isPrevious ? this.get('prevRowKey') : this.get('rowKey');\n          var columnName = isPrevious ? this.get('prevColumnName') : this.get('columnName');\n          return {\n            row: this.dataModel.indexOfRowKey(rowKey),\n            column: this.columnModel.indexOfColumnName(columnName, true)\n          };\n        },\n\n        /**\n         * Returns whether has focus.\n         * @param {boolean} checkValid - if set to true, check whether the current cell is valid.\n         * @returns {boolean} True if has focus.\n         */\n        has: function has(checkValid) {\n          var rowKey = this.get('rowKey');\n          var columnName = this.get('columnName');\n\n          if (checkValid) {\n            return this._isValidCell(rowKey, columnName);\n          }\n\n          return !util.isBlank(rowKey) && !util.isBlank(columnName);\n        },\n\n        /**\n         * Restore previous focus data.\n         * @returns {boolean} True if restored\n         */\n        restore: function restore() {\n          var prevRowKey = this.get('prevRowKey');\n          var prevColumnName = this.get('prevColumnName');\n          var restored = false;\n\n          if (this._isValidCell(prevRowKey, prevColumnName)) {\n            this.focus(prevRowKey, prevColumnName);\n            this.set({\n              prevRowKey: null,\n              prevColumnName: null\n            });\n            restored = true;\n          }\n\n          return restored;\n        },\n\n        /**\n         * Returns whether the cell identified by given rowKey and columnName is editing now.\n         * @param {Number} rowKey - row key\n         * @param {String} columnName - column name\n         * @returns {Boolean}\n         */\n        isEditingCell: function isEditingCell(rowKey, columnName) {\n          var address = this.get('editingAddress');\n          return address && String(address.rowKey) === String(rowKey) && address.columnName === columnName;\n        },\n\n        /**\n         * Starts editing a cell identified by given rowKey and columnName, and returns the result.\n         * @param {(String|Number)} rowKey - row key\n         * @param {String} columnName - column name\n         * @returns {Boolean} true if succeeded, false otherwise.\n         */\n        startEditing: function startEditing(rowKey, columnName) {\n          if (this.get('editingAddress')) {\n            return false;\n          }\n\n          if (_.isUndefined(rowKey) && _.isUndefined(columnName)) {\n            rowKey = this.get('rowKey');\n            columnName = this.get('columnName');\n          } else if (!this.isCurrentCell(rowKey, columnName, true)) {\n            return false;\n          }\n\n          rowKey = this.dataModel.getMainRowKey(rowKey, columnName);\n\n          if (!this.dataModel.get(rowKey).isEditable(columnName)) {\n            return false;\n          }\n\n          this.set('editingAddress', {\n            rowKey: rowKey,\n            columnName: columnName\n          });\n          return true;\n        },\n\n        /**\n         * Finishes editing the current cell, and returns the result.\n         * @returns {Boolean} - true if an editing cell exist, false otherwise.\n         */\n        finishEditing: function finishEditing() {\n          if (!this.get('editingAddress')) {\n            return false;\n          }\n\n          this.set('editingAddress', null);\n          return true;\n        },\n\n        /**\n         * Returns whether the specified cell is exist\n         * @param {String|Number} rowKey - Rowkey\n         * @param {String} columnName - ColumnName\n         * @returns {boolean} True if exist\n         * @private\n         */\n        _isValidCell: function _isValidCell(rowKey, columnName) {\n          var isValidRowKey = !util.isBlank(rowKey) && !!this.dataModel.get(rowKey);\n          var isValidColumnName = !util.isBlank(columnName) && !!this.columnModel.getColumnModel(columnName);\n          return isValidRowKey && isValidColumnName;\n        },\n\n        /**\n         * 현재 focus 된 row 기준으로 offset 만큼 이동한 rowKey 를 반환한다.\n         * @param {Number} offset   이동할 offset\n         * @returns {?Number|String} rowKey   offset 만큼 이동한 위치의 rowKey\n         * @private\n         */\n        _findRowKey: function _findRowKey(offset) {\n          var dataModel = this.dataModel;\n          var rowKey = null;\n          var index, row;\n\n          if (this.has(true)) {\n            index = Math.max(Math.min(dataModel.indexOfRowKey(this.get('rowKey')) + offset, this.dataModel.length - 1), 0);\n            row = dataModel.at(index);\n\n            if (row) {\n              rowKey = row.get('rowKey');\n            }\n          }\n\n          return rowKey;\n        },\n\n        /**\n         * 현재 focus 된 column 기준으로 offset 만큼 이동한 columnName 을 반환한다.\n         * @param {Number} offset   이동할 offset\n         * @returns {?String} columnName  offset 만큼 이동한 위치의 columnName\n         * @private\n         */\n        _findColumnName: function _findColumnName(offset) {\n          var columnModel = this.columnModel;\n          var columns = columnModel.getVisibleColumns();\n          var columnIndex = columnModel.indexOfColumnName(this.get('columnName'), true);\n          var columnName = null;\n          var index;\n\n          if (this.has(true)) {\n            index = Math.max(Math.min(columnIndex + offset, columns.length - 1), 0);\n            columnName = columns[index] && columns[index].name;\n          }\n\n          return columnName;\n        },\n\n        /**\n         * Returns data of rowSpan\n         * @param {Number|String} rowKey - Row key\n         * @param {String} columnName - Column name\n         * @returns {boolean|{count: number, isMainRow: boolean, mainRowKey: *}} rowSpanData - Data of rowSpan\n         * @private\n         */\n        _getRowSpanData: function _getRowSpanData(rowKey, columnName) {\n          if (rowKey && columnName) {\n            return this.dataModel.get(rowKey).getRowSpanData(columnName);\n          }\n\n          return false;\n        },\n\n        /**\n         * 다음 컬럼의 인덱스를 반환한다.\n         * @returns {Number} 다음 컬럼의 index\n         */\n        nextColumnIndex: function nextColumnIndex() {\n          var columnName = this.nextColumnName();\n          return this.columnModel.indexOfColumnName(columnName, true);\n        },\n\n        /**\n         * 이전 컬럼의 인덱스를 반환한다.\n         * @returns {Number} 이전 컬럼의 인덱스\n         */\n        prevColumnIndex: function prevColumnIndex() {\n          var columnName = this.prevColumnName();\n          return this.columnModel.indexOfColumnName(columnName, true);\n        },\n\n        /**\n         * keyEvent 발생 시 호출될 메서드로,\n         * rowSpan 정보 까지 계산된 다음 rowKey 를 반환한다.\n         * @param {number}  offset 이동할 offset\n         * @returns {Number|String} offset 만큼 이동한 위치의 rowKey\n         */\n        nextRowKey: function nextRowKey(offset) {\n          var focused = this.which();\n          var rowKey = focused.rowKey;\n          var count, rowSpanData;\n          offset = typeof offset === 'number' ? offset : 1;\n\n          if (offset > 1) {\n            rowKey = this._findRowKey(offset);\n            rowSpanData = this._getRowSpanData(rowKey, focused.columnName);\n\n            if (rowSpanData && !rowSpanData.isMainRow) {\n              rowKey = this._findRowKey(rowSpanData.count + offset);\n            }\n          } else {\n            rowSpanData = this._getRowSpanData(rowKey, focused.columnName);\n\n            if (rowSpanData.isMainRow && rowSpanData.count > 0) {\n              rowKey = this._findRowKey(rowSpanData.count);\n            } else if (rowSpanData && !rowSpanData.isMainRow) {\n              count = rowSpanData.count;\n              rowSpanData = this._getRowSpanData(rowSpanData.mainRowKey, focused.columnName);\n              rowKey = this._findRowKey(rowSpanData.count + count);\n            } else {\n              offset = this.coordRowModel.getNextOffset(rowKey);\n              rowKey = this._findRowKey(offset);\n            }\n          }\n\n          return rowKey;\n        },\n\n        /**\n         * keyEvent 발생 시 호출될 메서드로,\n         * rowSpan 정보 까지 계산된 이전 rowKey 를 반환한다.\n         * @param {number}  offset 이동할 offset\n         * @returns {Number|String} offset 만큼 이동한 위치의 rowKey\n         */\n        prevRowKey: function prevRowKey(offset) {\n          var focused = this.which();\n          var rowKey = focused.rowKey;\n          var rowSpanData;\n          offset = typeof offset === 'number' ? offset : 1;\n          offset *= -1;\n\n          if (offset < -1) {\n            rowKey = this._findRowKey(offset);\n            rowSpanData = this._getRowSpanData(rowKey, focused.columnName);\n\n            if (rowSpanData && !rowSpanData.isMainRow) {\n              rowKey = this._findRowKey(rowSpanData.count + offset);\n            }\n          } else {\n            rowSpanData = this._getRowSpanData(rowKey, focused.columnName);\n\n            if (rowSpanData && !rowSpanData.isMainRow) {\n              rowKey = this._findRowKey(rowSpanData.count - 1);\n            } else {\n              offset = this.coordRowModel.getPreviousOffset(rowKey);\n              rowKey = this._findRowKey(offset);\n            }\n          }\n\n          return rowKey;\n        },\n\n        /**\n         * keyEvent 발생 시 호출될 메서드로, 다음 columnName 을 반환한다.\n         * @returns {String} 다음 컬럼명\n         */\n        nextColumnName: function nextColumnName() {\n          return this._findColumnName(1);\n        },\n\n        /**\n         * keyEvent 발생 시 호출될 메서드로, 이전 columnName 을 반환한다.\n         * @returns {String} 이전 컬럼명\n         */\n        prevColumnName: function prevColumnName() {\n          return this._findColumnName(-1);\n        },\n\n        /**\n         * 첫번째 row 의 key 를 반환한다.\n         * @returns {(string|number)} 첫번째 row 의 키값\n         */\n        firstRowKey: function firstRowKey() {\n          return this.dataModel.at(0).get('rowKey');\n        },\n\n        /**\n         * 마지막 row의 key 를 반환한다.\n         * @returns {(string|number)} 마지막 row 의 키값\n         */\n        lastRowKey: function lastRowKey() {\n          return this.dataModel.at(this.dataModel.length - 1).get('rowKey');\n        },\n\n        /**\n         * 첫번째 columnName 을 반환한다.\n         * @returns {string} 첫번째 컬럼명\n         */\n        firstColumnName: function firstColumnName() {\n          var columns = this.columnModel.getVisibleColumns();\n          return columns[0].name;\n        },\n\n        /**\n         * 마지막 columnName 을 반환한다.\n         * @returns {string} 마지막 컬럼명\n         */\n        lastColumnName: function lastColumnName() {\n          var columns = this.columnModel.getVisibleColumns();\n          var lastIndex = columns.length - 1;\n          return columns[lastIndex].name;\n        },\n\n        /**\n         * Returns the address of previous cell.\n         * @returns {{rowKey: number, columnName: string}}\n         */\n        prevAddress: function prevAddress() {\n          var rowKey = this.get('rowKey');\n          var columnName = this.get('columnName');\n          var isFirstColumn = columnName === this.firstColumnName();\n          var isFirstRow = rowKey === this.firstRowKey();\n          var prevRowKey, prevColumnName;\n\n          if (isFirstRow && isFirstColumn) {\n            prevRowKey = rowKey;\n            prevColumnName = columnName;\n          } else if (isFirstColumn) {\n            prevRowKey = this.prevRowKey();\n            prevColumnName = this.lastColumnName();\n          } else {\n            prevRowKey = rowKey;\n            prevColumnName = this.prevColumnName();\n          }\n\n          return {\n            rowKey: prevRowKey,\n            columnName: prevColumnName\n          };\n        },\n\n        /**\n         * Returns the address of next cell.\n         * @returns {{rowKey: number, columnName: string}}\n         */\n        nextAddress: function nextAddress() {\n          var rowKey = this.get('rowKey');\n          var columnName = this.get('columnName');\n          var isLastColumn = columnName === this.lastColumnName();\n          var isLastRow = rowKey === this.lastRowKey();\n          var nextRowKey, nextColumnName;\n\n          if (isLastRow && isLastColumn) {\n            nextRowKey = rowKey;\n            nextColumnName = columnName;\n          } else if (isLastColumn) {\n            nextRowKey = this.nextRowKey();\n            nextColumnName = this.firstColumnName();\n          } else {\n            nextRowKey = rowKey;\n            nextColumnName = this.nextColumnName();\n          }\n\n          return {\n            rowKey: nextRowKey,\n            columnName: nextColumnName\n          };\n        }\n      });\n      module.exports = Focus;\n      /***/\n    },\n    /* 26 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Rendering 모델\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var Model = __webpack_require__(9);\n\n      var Row = __webpack_require__(27);\n\n      var RowList = __webpack_require__(28);\n\n      var renderStateMap = __webpack_require__(10).renderState;\n\n      var CELL_BORDER_WIDTH = __webpack_require__(10).dimension.CELL_BORDER_WIDTH;\n\n      var DATA_LENGTH_FOR_LOADING = 1000;\n      /**\n       * View 에서 Rendering 시 사용할 객체\n       * @module model/renderer\n       * @extends module:base/model\n       * @param {Object} attrs - Attributes\n       * @param {Object} options - Options\n       * @ignore\n       */\n\n      var Renderer = Model.extend(\n      /** @lends module:model/renderer.prototype */\n      {\n        initialize: function initialize(attrs, options) {\n          var rowListOptions;\n          var partialLside, partialRside;\n\n          _.assign(this, {\n            dataModel: options.dataModel,\n            columnModel: options.columnModel,\n            focusModel: options.focusModel,\n            dimensionModel: options.dimensionModel,\n            coordRowModel: options.coordRowModel,\n            coordColumnModel: options.coordColumnModel\n          });\n\n          rowListOptions = {\n            dataModel: this.dataModel,\n            columnModel: this.columnModel,\n            focusModel: this.focusModel\n          };\n          partialLside = new RowList([], rowListOptions);\n          partialRside = new RowList([], rowListOptions);\n          this.set({\n            lside: [],\n            rside: [],\n            partialLside: partialLside,\n            partialRside: partialRside\n          });\n          this.listenTo(this.columnModel, 'columnModelChange change', this._onColumnModelChange).listenTo(this.dataModel, 'reset', this._initializeScrollValues).listenTo(this.dataModel, 'sort reset', this._onDataModelChange).listenTo(this.dataModel, 'deleteRange', this._onRangeDataModelChange).listenTo(this.dataModel, 'add', this._onAddDataModelChange).listenTo(this.dataModel, 'remove', this._onRemoveDataModelChange).listenTo(this.dataModel, 'beforeReset', this._onBeforeResetData).listenTo(this.dataModel, 'expanded ', this._onExpanded).listenTo(this.dataModel, 'collapsed ', this._onCollapsed).listenTo(this.focusModel, 'change:editingAddress', this._onEditingAddressChange).listenTo(partialLside, 'valueChange', this._executeRelation).listenTo(partialRside, 'valueChange', this._executeRelation).listenTo(this.coordRowModel, 'reset', this._onChangeRowHeights).listenTo(this.dimensionModel, 'columnWidthChanged', this.finishEditing).listenTo(this.dimensionModel, 'change:width', this._updateMaxScrollLeft).listenTo(this.dimensionModel, 'change:totalRowHeight change:scrollBarSize change:bodyHeight', this._updateMaxScrollTop);\n\n          if (this.get('showDummyRows')) {\n            this.listenTo(this.dimensionModel, 'change:bodyHeight change:totalRowHeight', this._resetDummyRowCount);\n            this.on('change:dummyRowCount', this._resetDummyRows);\n          }\n\n          this.on('change', this._onChangeIndex, this);\n          this._onChangeLayoutBound = _.bind(this._onChangeLayout, this);\n        },\n        defaults: {\n          top: 0,\n          bottom: 0,\n          scrollTop: 0,\n          scrollLeft: 0,\n          maxScrollLeft: 0,\n          maxScrollTop: 0,\n          startIndex: -1,\n          endIndex: -1,\n          startNumber: 1,\n          lside: null,\n          rside: null,\n          partialLside: null,\n          partialRside: null,\n          showDummyRows: false,\n          dummyRowCount: 0,\n          // text that will be shown if no data to render (custom value set by user)\n          emptyMessage: null,\n          // constMap.renderState\n          state: renderStateMap.DONE\n        },\n\n        /**\n         * Event handler for 'expanded' event on dataModel using tree\n         * @param {object} ev - Event object\n         * @private\n         */\n        _onExpanded: function _onExpanded(ev) {\n          var rowKeys = ev.descendantRowKeys;\n          var dataModel = this.dataModel;\n\n          var columnNamesMap = this._getColumnNamesOfEachSide();\n\n          var height, viewData, rowNum, viewModel, index, row;\n\n          _.each(rowKeys, function (rowKey) {\n            index = dataModel.indexOfRowKey(rowKey);\n            row = dataModel.at(index);\n            height = this.coordRowModel.getHeightAt(index);\n\n            _.each(['lside', 'rside'], function (attrName) {\n              rowNum = index + 1;\n              viewData = this._createViewDataFromDataModel(row, columnNamesMap[attrName], height, rowNum);\n              viewModel = this._createRowModel(viewData, true);\n              this.get(attrName)[index] = viewModel;\n            }, this);\n          }, this);\n\n          this._setRenderingRange();\n\n          this.refresh({\n            type: 'add',\n            dataListChanged: true\n          });\n        },\n\n        /**\n         * Event handler for 'collapsed' event on dataModel using tree\n         * @param {object} ev - Event object\n         * @private\n         */\n        _onCollapsed: function _onCollapsed(ev) {\n          var rowKeys = ev.descendantRowKeys;\n\n          _.each(rowKeys, function (rowKey) {\n            var index = this.dataModel.indexOfRowKey(rowKey);\n\n            _.each(['lside', 'rside'], function (attrName) {\n              delete this.get(attrName)[index];\n            }, this);\n          }, this);\n\n          this._setRenderingRange();\n\n          this.refresh({\n            type: 'deleteRange',\n            dataListChanged: true\n          });\n        },\n\n        /**\n         * Event handler for change:scrollTop and change:scrollLeft.\n         * @private\n         */\n        _onChangeLayout: function _onChangeLayout() {\n          this.focusModel.finishEditing();\n          this.focusModel.focusClipboard();\n        },\n\n        /**\n         * Event handler for changing startIndex or endIndex.\n         * @param {Object} model - Renderer model fired event\n         * @private\n         */\n        _onChangeIndex: function _onChangeIndex(model) {\n          var changedData = model.changed;\n\n          var changedStartIndex = _.has(changedData, 'startIndex');\n\n          var changedEndIndex = _.has(changedData, 'endIndex');\n\n          if (changedStartIndex || changedEndIndex) {\n            this.refresh();\n          }\n        },\n\n        /**\n         * Event handler for 'reset' event on coordRowModel\n         * @private\n         */\n        _onChangeRowHeights: function _onChangeRowHeights() {\n          var lside = this.get('partialLside');\n          var rside = this.get('partialRside');\n          var i = 0;\n          var len = lside.length;\n          var rowKey, height;\n\n          for (; i < len; i += 1) {\n            rowKey = lside.at(i).get('rowKey');\n            height = this.coordRowModel.getHeight(rowKey);\n            lside.at(i).set('height', height);\n            rside.at(i).set('height', height);\n          }\n        },\n\n        /**\n         * Event handler for 'change:width' event on Dimension.\n         * @private\n         */\n        _updateMaxScrollLeft: function _updateMaxScrollLeft() {\n          var dimension = this.dimensionModel;\n          var maxScrollLeft = this.coordColumnModel.getFrameWidth('R') - dimension.get('rsideWidth') + dimension.getScrollYWidth();\n          this.set('maxScrollLeft', maxScrollLeft);\n        },\n\n        /**\n         * Event handler to reset 'maxScrollTop' attribute.\n         * @private\n         */\n        _updateMaxScrollTop: function _updateMaxScrollTop() {\n          var dimension = this.dimensionModel;\n          var maxScrollTop = dimension.get('totalRowHeight') - dimension.get('bodyHeight') + dimension.getScrollXHeight();\n          this.set('maxScrollTop', maxScrollTop);\n        },\n\n        /**\n         * Event handler for 'beforeReset' event on dataModel\n         * @param {number} dataLength - the length of data\n         * @private\n         */\n        _onBeforeResetData: function _onBeforeResetData(dataLength) {\n          if (dataLength > DATA_LENGTH_FOR_LOADING) {\n            this.set('state', renderStateMap.LOADING);\n          }\n        },\n\n        /**\n         * Event handler for 'change:editingAddress' event on focusModel\n         * @param {module:model/focus} focusModel - focus model\n         * @param {{rowKey: Number, columnName: String}} address - address\n         * @private\n         */\n        _onEditingAddressChange: function _onEditingAddressChange(focusModel, address) {\n          var target = address;\n          var editing = true;\n          var self = this;\n\n          if (!address) {\n            target = focusModel.previous('editingAddress');\n            editing = false;\n          }\n\n          this._updateCellData(target.rowKey, target.columnName, {\n            editing: editing\n          });\n\n          this._triggerEditingStateChanged(target.rowKey, target.columnName); // defered call to prevent 'change:scrollLeft' or 'change:scrollTop' event\n          // triggered by module:view/layout/body._onScroll()\n          // when module:model/focus.scrollToFocus() method is called.\n\n\n          _.defer(function () {\n            self._toggleChangeLayoutEventHandlers(editing);\n          });\n        },\n\n        /**\n         * Toggle event handler for change:scrollTop and change:scrollLeft event.\n         * @param {Boolean} editing - whether currently editing\n         * @private\n         */\n        _toggleChangeLayoutEventHandlers: function _toggleChangeLayoutEventHandlers(editing) {\n          var renderEventName = 'change:scrollTop change:scrollLeft';\n          var dimensionEventName = 'columnWidthChanged';\n\n          if (editing) {\n            this.listenToOnce(this.dimensionModel, dimensionEventName, this._onChangeLayoutBound);\n            this.once(renderEventName, this._onChangeLayoutBound);\n          } else {\n            this.stopListening(this.dimensionModel, dimensionEventName, this._onChangeLayoutBound);\n            this.off(renderEventName, this._onChangeLayoutBound);\n          }\n        },\n\n        /**\n         * Triggers the 'editingStateChanged' event if the cell data identified by\n         * given row key and column name has the useViewMode:true option.\n         * @param {String} rowKey - row key\n         * @param {String} columnName - column name\n         * @private\n         */\n        _triggerEditingStateChanged: function _triggerEditingStateChanged(rowKey, columnName) {\n          var cellData = this.getCellData(rowKey, columnName);\n\n          if (snippet.pick(cellData, 'columnModel', 'editOptions', 'useViewMode') !== false && cellData.convertedHTML === null) {\n            this.trigger('editingStateChanged', cellData);\n          }\n        },\n\n        /**\n         * Updates the view-data of the cell identified by given rowKey and columnName.\n         * @param {(String|Number)} rowKey - row key\n         * @param {String} columnName - column name\n         * @param {Object} cellData - cell data\n         * @private\n         */\n        _updateCellData: function _updateCellData(rowKey, columnName, cellData) {\n          var rowModel = this._getRowModel(rowKey, columnName);\n\n          if (rowModel) {\n            rowModel.setCell(columnName, cellData);\n          }\n        },\n\n        /**\n         * Update data of tree-cell\n         * @param {number} rowKey - row key\n         * @private\n         */\n        _updateTreeCellData: function _updateTreeCellData(rowKey) {\n          var columnName = this.columnModel.getTreeColumnName();\n\n          var rowModel = this._getRowModel(rowKey, columnName);\n\n          if (rowModel) {\n            rowModel.setCell(columnName, {\n              hasChildren: this.dataModel.get(rowKey).hasTreeChildren()\n            });\n          }\n        },\n\n        /**\n         * Initializes own properties.\n         * (called by module:addon/net)\n         */\n        initializeVariables: function initializeVariables() {\n          this.set({\n            top: 0,\n            scrollTop: 0,\n            scrollLeft: 0,\n            startNumber: 1\n          });\n        },\n\n        /**\n         * Initializes values of the scroll\n         * @private\n         */\n        _initializeScrollValues: function _initializeScrollValues() {\n          this.set({\n            scrollTop: 0,\n            scrollLeft: 0\n          });\n        },\n\n        /**\n         * 열고정 영역 또는 열고정이 아닌 영역에 대한 Render Collection 을 반환한다.\n         * @param {String} [whichSide='R']    어느 영역인지 여부. 'L|R' 중에 하나의 값을 넘긴다.\n         * @returns {Object} collection  해당 영역의 랜더 데이터 콜랙션\n         */\n        getCollection: function getCollection(whichSide) {\n          var attrName = this._getPartialWhichSideType(whichSide);\n\n          return this.get(attrName);\n        },\n\n        /**\n         * Get string of partial which side type\n         * @param {string} whichSide - Type of which side (L|R)\n         * @returns {string} String of appened prefix value 'partial'\n         * @private\n         */\n        _getPartialWhichSideType: function _getPartialWhichSideType(whichSide) {\n          return snippet.isString(whichSide) ? 'partial' + whichSide + 'side' : 'partialRside';\n        },\n\n        /**\n         * Event handler for regenerating left and right side frames when the Data.ColumnModel is changed\n         * @private\n         */\n        _onColumnModelChange: function _onColumnModelChange() {\n          var scrollLeftBeforeChange = this.get('scrollLeft');\n          var scrollTopBeforeChange = this.get('scrollTop');\n          this.set({\n            scrollLeft: 0,\n            scrollTop: 0\n          }, {\n            silent: true\n          });\n\n          this._resetViewModelList();\n\n          this._setRenderingRange(true);\n\n          this.refresh({\n            columnModelChanged: true\n          });\n\n          this._updateMaxScrollLeft();\n\n          this.set({\n            scrollLeft: scrollLeftBeforeChange,\n            scrollTop: scrollTopBeforeChange\n          });\n        },\n\n        /**\n         * Event handler for changing data list\n         * @private\n         */\n        _onDataModelChange: function _onDataModelChange() {\n          this._resetViewModelList();\n\n          this._setRenderingRange(true);\n\n          this.refresh({\n            type: 'reset',\n            dataListChanged: true\n          });\n        },\n\n        /**\n         * Event handler for adding data list\n         * @param {array} rowList - List of added item\n         * @param {object} options - Info of added item\n         * @private\n         */\n        _onAddDataModelChange: function _onAddDataModelChange(rowList, options) {\n          var columnNamesMap = this._getColumnNamesOfEachSide();\n\n          var at = options.at;\n          var height, viewData, rowNum;\n          var viewModel;\n\n          _.each(rowList, function (row, index) {\n            height = this.coordRowModel.getHeightAt(index);\n\n            _.each(['lside', 'rside'], function (attrName) {\n              rowNum = at + index + 1;\n              viewData = this._createViewDataFromDataModel(row, columnNamesMap[attrName], height, rowNum);\n              viewModel = this._createRowModel(viewData, true);\n              this.get(attrName).splice(at + index, 0, viewModel);\n            }, this);\n          }, this);\n\n          this._updateTreeCellData(options.parentRowKey);\n\n          this._setRenderingRange(true);\n\n          this.refresh({\n            type: 'add',\n            dataListChanged: true\n          });\n\n          if (options.focus) {\n            this.focusModel.focusAt(options.at, 0);\n          }\n        },\n\n        /**\n         * Event handler for removing data list\n         * @param {number|string} rowKey - rowKey of the removed row\n         * @param {number} removedIndex - Index of the removed row\n         * @param {Array.<number>} [descendantRowKeys] - All descendants key of the removed when using tree\n         * @param {number} [parentRowKey] - Parent key of the removed row when using tree\n         * @private\n         */\n        _onRemoveDataModelChange: function _onRemoveDataModelChange(rowKey, removedIndex, descendantRowKeys, parentRowKey) {\n          var removedRowsCnt = descendantRowKeys ? descendantRowKeys.length : 1;\n\n          _.each(['lside', 'rside'], function (attrName) {\n            this.get(attrName).splice(removedIndex, removedRowsCnt);\n          }, this);\n\n          this._updateTreeCellData(parentRowKey);\n\n          this._setRenderingRange(true);\n\n          this.refresh({\n            dataListChanged: true\n          });\n        },\n\n        /**\n         * Event handler for deleting cell data\n         * @param {GridEvent} ev - event object when \"delRange\" event is fired\n         * @private\n         */\n        _onRangeDataModelChange: function _onRangeDataModelChange(ev) {\n          var columnModel = this.columnModel;\n          var rowKeys = ev.rowKeys;\n          var columnNames = ev.columnNames;\n\n          this._setRenderingRange(true);\n\n          _.each(['partialLside', 'partialRside'], function (attrName) {\n            _.each(this.get(attrName).models, function (model) {\n              var rowKey = model.get('rowKey');\n\n              var changedRow = _.contains(rowKeys, rowKey);\n\n              if (changedRow) {\n                _.each(columnNames, function (columnName) {\n                  if (columnModel.getColumnModel(columnName).editOptions) {\n                    this._updateCellData(rowKey, columnName, {\n                      value: '',\n                      formattedValue: ''\n                    });\n                  }\n                }, this);\n              }\n            }, this);\n          }, this);\n\n          this.refresh({\n            type: 'deleteRange',\n            dataListChanged: true\n          });\n        },\n\n        /**\n         * Resets dummy rows and trigger 'dataListChanged' event.\n         * @private\n         */\n        _resetDummyRows: function _resetDummyRows() {\n          this._clearDummyRows();\n\n          this._fillDummyRows();\n\n          this.trigger('rowListChanged');\n        },\n\n        /**\n         * Set index-range to render\n         * @param {boolean} silent - whether set attributes silently\n         * @private\n         */\n        _setRenderingRange: function _setRenderingRange(silent) {\n          var dataLength = this.dataModel.length;\n          this.set({\n            startIndex: dataLength ? 0 : -1,\n            endIndex: dataLength - 1\n          }, {\n            silent: silent\n          });\n        },\n\n        /**\n         * Returns the new data object for rendering based on rowDataModel and specified column names.\n         * @param  {Object} rowDataModel - Instance of module:model/data/row\n         * @param  {Array.<String>} columnNames - Column names\n         * @param  {Number} height - the height of the row\n         * @param  {Number} rowNum - Row number\n         * @returns {Object} - view data object\n         * @private\n         */\n        _createViewDataFromDataModel: function _createViewDataFromDataModel(rowDataModel, columnNames, height, rowNum) {\n          var viewData = {\n            rowNum: rowNum,\n            height: height,\n            rowKey: rowDataModel.get('rowKey'),\n            _extraData: rowDataModel.get('_extraData')\n          };\n\n          _.each(columnNames, function (columnName) {\n            var value = rowDataModel.get(columnName);\n\n            if (columnName === '_number' && !_.isNumber(value)) {\n              value = rowNum;\n            }\n\n            viewData[columnName] = value;\n          });\n\n          return viewData;\n        },\n\n        /**\n         * Returns the object that contains two array of column names splitted by frozenCount.\n         * @returns {{lside: Array, rside: Array}} - Column names map\n         * @private\n         */\n        _getColumnNamesOfEachSide: function _getColumnNamesOfEachSide() {\n          var frozenCount = this.columnModel.getVisibleFrozenCount(true);\n          var columnModels = this.columnModel.getVisibleColumns(null, true);\n\n          var columnNames = _.pluck(columnModels, 'name');\n\n          return {\n            lside: columnNames.slice(0, frozenCount),\n            rside: columnNames.slice(frozenCount)\n          };\n        },\n\n        /**\n         * Add view model list by range\n         * @param {number} startIndex - Index of start row\n         * @param {number} endIndex - Index of end row\n         * @private\n         */\n        _addViewModelListWithRange: function _addViewModelListWithRange(startIndex, endIndex) {\n          var dataModel = this.dataModel;\n\n          var columnNamesMap = this._getColumnNamesOfEachSide();\n\n          var index, row, height;\n\n          if (startIndex < 0 || endIndex < 0) {\n            return;\n          }\n\n          for (index = startIndex; index < endIndex + 1; index += 1) {\n            row = dataModel.at(index);\n            height = this.coordRowModel.getHeightAt(index);\n\n            if (dataModel.isVisibleRow(row.get('rowKey'))) {\n              this._addViewModelList(row, columnNamesMap, height, index);\n            }\n          }\n        },\n\n        /**\n         * Add view model list on each side\n         * @param {object} rowDataModel - Data model of row\n         * @param {object} columnNamesMap - Map of column names\n         * @param {number} height - Height of row\n         * @param {number} index - Index of row\n         * @private\n         */\n        _addViewModelList: function _addViewModelList(rowDataModel, columnNamesMap, height, index) {\n          _.each(['lside', 'rside'], function (attrName) {\n            var viewData;\n\n            if (!this.get(attrName)[index]) {\n              viewData = this._createViewDataFromDataModel(rowDataModel, columnNamesMap[attrName], height, index + 1);\n              this.get(attrName)[index] = this._createRowModel(viewData, true);\n            }\n          }, this);\n        },\n\n        /**\n         * Update the row number\n         * @param {number} startIndex - Start index\n         * @param {number} endIndex - End index\n         * @private\n         */\n        _updateRowNumber: function _updateRowNumber(startIndex, endIndex) {\n          var collection = this.get('lside');\n          var index = startIndex;\n          var currentModel, rowNum, newRowNum;\n\n          for (; index <= endIndex; index += 1) {\n            currentModel = collection[index];\n            newRowNum = index + 1;\n\n            if (currentModel) {\n              rowNum = currentModel.get('rowNum');\n              newRowNum = index + this.get('startNumber');\n\n              if (rowNum !== newRowNum) {\n                currentModel.set({\n                  rowNum: newRowNum\n                }, {\n                  silent: true\n                });\n                currentModel.setCell('_number', {\n                  formattedValue: newRowNum,\n                  value: newRowNum\n                });\n              }\n            }\n          }\n        },\n\n        /**\n         * Reset partial view model list\n         * @param {number} startIndex - Index of start row\n         * @param {number} endIndex - Index of end row\n         * @private\n         */\n        _resetPartialViewModelList: function _resetPartialViewModelList(startIndex, endIndex) {\n          var originalWhichSide, partialWhichSide;\n          var viewModelList, partialViewModelList;\n\n          _.each(['L', 'R'], function (whichSide) {\n            partialViewModelList = [];\n            originalWhichSide = whichSide.toLowerCase() + 'side';\n            partialWhichSide = this._getPartialWhichSideType(whichSide);\n            viewModelList = this.get(originalWhichSide);\n            partialViewModelList = this._getPartialViewModelList(viewModelList, startIndex, endIndex);\n            this.get(partialWhichSide).reset(partialViewModelList);\n          }, this);\n        },\n\n        /**\n         * Get partial view model list\n         * @param {Array.<obejct>} viewModelList - List of view model\n         * @param {number} startIndex - Index of start row\n         * @param {number} endIndex - Index of end row\n         * @returns {Array.<module:model/data/row>}>} List of partial view model\n         * @private\n         */\n        _getPartialViewModelList: function _getPartialViewModelList(viewModelList, startIndex, endIndex) {\n          var index = startIndex;\n          var len = endIndex + 1;\n          var partialViewModelList = [];\n          var viewModel;\n\n          for (; index < len; index += 1) {\n            viewModel = viewModelList[index];\n\n            if (viewModel && this.dataModel.isVisibleRow(viewModel.get('rowKey'))) {\n              partialViewModelList.push(viewModel);\n            }\n          }\n\n          return partialViewModelList;\n        },\n\n        /**\n         * Returns the count of rows (except dummy rows) in view model list\n         * @returns {Number} Count of rows\n         * @private\n         */\n        _getActualRowCount: function _getActualRowCount() {\n          return this.get('endIndex') - this.get('startIndex') + 1;\n        },\n\n        /**\n         * Removes all dummy rows in the view model list.\n         * @private\n         */\n        _clearDummyRows: function _clearDummyRows() {\n          var dataRowCount = this.get('endIndex') - this.get('startIndex') + 1;\n\n          _.each(['lside', 'rside'], function (attrName) {\n            var rowList = this.get(attrName);\n\n            while (rowList.length > dataRowCount) {\n              rowList.pop();\n            }\n          }, this);\n        },\n\n        /**\n         * Calculate required count of dummy rows and set the 'dummyRowCount' attribute.\n         * @param {boolean} silent - whether sets the dummyRowCount silently\n         * @private\n         */\n        _resetDummyRowCount: function _resetDummyRowCount() {\n          var dimensionModel = this.dimensionModel;\n          var totalRowHeight = dimensionModel.get('totalRowHeight');\n          var rowHeight = dimensionModel.get('rowHeight') + CELL_BORDER_WIDTH;\n          var bodyHeight = dimensionModel.get('bodyHeight') - dimensionModel.getScrollXHeight();\n          var dummyRowCount = 0;\n\n          if (totalRowHeight < bodyHeight) {\n            dummyRowCount = Math.ceil((bodyHeight - totalRowHeight) / rowHeight);\n          }\n\n          this.set('dummyRowCount', dummyRowCount);\n        },\n\n        /**\n         * fills the empty area with dummy rows.\n         * @private\n         */\n        _fillDummyRows: function _fillDummyRows() {\n          var dummyRowCount = this.get('dummyRowCount');\n          var rowNum, rowHeight;\n\n          if (dummyRowCount) {\n            rowNum = this.get('startNumber') + this.get('endIndex') + 1;\n            rowHeight = this.dimensionModel.get('rowHeight');\n\n            _.times(dummyRowCount, function () {\n              _.each(['partialLside', 'partialRside'], function (listName) {\n                this.get(listName).push(this._createRowModel({\n                  height: rowHeight,\n                  rowNum: rowNum\n                }));\n              }, this);\n\n              rowNum += 1;\n            }, this);\n          }\n        },\n\n        /* eslint-disable complexity */\n\n        /**\n         * Refreshes the rendering range and the list of view models, and triggers events.\n         * @param {object} options - options\n         * @param {boolean} [options.columnModelChanged] - The boolean value whether columnModel has changed\n         * @param {boolean} [options.dataListChanged] - The boolean value whether dataModel has changed\n         * @param {string} [options.type] - Event type (reset|add|remove)\n         */\n        refresh: function refresh(options) {\n          var columnModelChanged = !!options && options.columnModelChanged;\n          var dataListChanged = !!options && options.dataListChanged;\n          var eventType = !!options && options.type;\n          var startIndex, endIndex, i;\n          startIndex = this.get('startIndex');\n          endIndex = this.get('endIndex');\n\n          if (eventType !== 'add' && eventType !== 'deleteRange') {\n            this._addViewModelListWithRange(startIndex, endIndex);\n          }\n\n          if (eventType !== 'deleteRange') {\n            this._updateRowNumber(startIndex, endIndex);\n          }\n\n          this._resetPartialViewModelList(startIndex, endIndex);\n\n          this._fillDummyRows();\n\n          if (startIndex >= 0 && endIndex >= 0) {\n            for (i = startIndex; i <= endIndex; i += 1) {\n              this._executeRelation(i);\n            }\n          }\n\n          if (columnModelChanged) {\n            this.trigger('columnModelChanged');\n          } else {\n            this.trigger('rowListChanged', dataListChanged);\n\n            if (dataListChanged) {\n              this.coordRowModel.syncWithDom();\n            }\n          }\n\n          this._refreshState();\n        },\n\n        /* eslint-enable complexity */\n\n        /**\n         * Set state value based on the DataModel.length\n         * @private\n         */\n        _refreshState: function _refreshState() {\n          if (this.dataModel.length) {\n            this.set('state', renderStateMap.DONE);\n          } else {\n            this.set('state', renderStateMap.EMPTY);\n          }\n        },\n\n        /**\n         * columnName 으로 lside 와 rside rendering collection 중 하나를 반환한다.\n         * @param {String} columnName   컬럼명\n         * @returns {Collection} 컬럼명에 해당하는 영역의 콜랙션\n         * @private\n         */\n        _getCollectionByColumnName: function _getCollectionByColumnName(columnName) {\n          var lside = this.get('partialLside');\n          var collection;\n\n          if (lside.at(0) && lside.at(0).get(columnName)) {\n            collection = lside;\n          } else {\n            collection = this.get('partialRside');\n          }\n\n          return collection;\n        },\n\n        /**\n         * Returns the specified row model.\n         * @param {(Number|String)} rowKey - row key\n         * @param {String} columnName - column name\n         * @returns {module:model/row}\n         * @private\n         */\n        _getRowModel: function _getRowModel(rowKey, columnName) {\n          var collection = this._getCollectionByColumnName(columnName);\n\n          return collection.get(rowKey);\n        },\n\n        /**\n         * 셀 데이터를 반환한다.\n         * @param {number} rowKey   데이터의 키값\n         * @param {String} columnName   컬럼명\n         * @returns {object} cellData 셀 데이터\n         * @example\n         {\n             rowKey: rowKey,\n             columnName: columnName,\n             value: value,\n             rowSpan: rowSpanData.count,\n             isMainRow: rowSpanData.isMainRow,\n             mainRowKey: rowSpanData.mainRowKey,\n             editable: editable,\n             disabled: disabled,\n             listItems: [],\n             className: row.getClassNameList(columnName).join(' '),\n             changed: []    //names of changed properties\n         }\n         */\n        getCellData: function getCellData(rowKey, columnName) {\n          var row = this._getRowModel(rowKey, columnName);\n\n          var cellData = null;\n\n          if (row) {\n            cellData = row.get(columnName);\n          }\n\n          return cellData;\n        },\n\n        /**\n         * Executes the relation of the row identified by rowIndex\n         * @param {Number} rowIndex - Row index\n         * @private\n         */\n        _executeRelation: function _executeRelation(rowIndex) {\n          var row = this.dataModel.at(rowIndex);\n          var renderIdx = rowIndex - this.get('startIndex');\n          var rowModel, relationResult;\n          relationResult = row.executeRelationCallbacksAll();\n\n          _.each(relationResult, function (changes, columnName) {\n            rowModel = this._getCollectionByColumnName(columnName).at(renderIdx);\n\n            if (rowModel) {\n              rowModel.setCell(columnName, changes);\n            }\n          }, this);\n        },\n\n        /**\n         * Create row model\n         * @param {object} attrs - Attributes to create\n         * @param {boolean} parse - Whether calling parse or not\n         * @returns {object} Row model\n         * @private\n         */\n        _createRowModel: function _createRowModel(attrs, parse) {\n          return new Row(attrs, {\n            parse: parse,\n            dataModel: this.dataModel,\n            columnModel: this.columnModel,\n            focusModel: this.focusModel\n          });\n        },\n\n        /**\n         * Reset view models when value of columModel or dataModel is changed\n         * @private\n         */\n        _resetViewModelList: function _resetViewModelList() {\n          _.each(['lside', 'rside'], function (attrName) {\n            this.set(attrName, new Array(this.dataModel.length));\n          }, this);\n        }\n      });\n      module.exports = Renderer;\n      /***/\n    },\n    /* 27 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Row Model for Rendering (View Model)\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var Model = __webpack_require__(9);\n\n      var util = __webpack_require__(17);\n      /**\n       * Row Model\n       * @module model/row\n       * @param  {object} attributes - Attributes\n       * @param  {object} options - Options\n       * @extends module:base/model\n       * @ignore\n       */\n\n\n      var Row = Model.extend(\n      /** @lends module:model/row.prototype */\n      {\n        initialize: function initialize(attributes, options) {\n          var rowKey = attributes && attributes.rowKey;\n          var dataModel = options.dataModel;\n          var rowData = dataModel.get(rowKey);\n          this.dataModel = dataModel;\n          this.columnModel = options.columnModel;\n          this.focusModel = options.focusModel;\n\n          if (rowData) {\n            this.listenTo(rowData, 'change', this._onDataModelChange);\n            this.listenTo(rowData, 'restore', this._onDataModelRestore);\n            this.listenTo(rowData, 'extraDataChanged', this._setRowExtraData);\n            this.listenTo(dataModel, 'disabledChanged', this._onDataModelDisabledChanged);\n            this.rowData = rowData;\n          }\n        },\n        idAttribute: 'rowKey',\n\n        /**\n         * Event handler for 'change' event on module:data/row\n         * @param {Object} rowData - RowData model on which event occurred\n         * @private\n         */\n        _onDataModelChange: function _onDataModelChange(rowData) {\n          _.each(rowData.changed, function (value, columnName) {\n            var column, isTextType;\n\n            if (this.has(columnName)) {\n              column = this.columnModel.getColumnModel(columnName);\n              isTextType = this.columnModel.isTextType(columnName);\n              this.setCell(columnName, this._getValueAttrs(value, rowData, column, isTextType));\n            }\n          }, this);\n        },\n\n        /**\n         * Event handler for 'restore' event on module:data/row\n         * @param {String} columnName - columnName\n         * @private\n         */\n        _onDataModelRestore: function _onDataModelRestore(columnName) {\n          var cellData = this.get(columnName);\n\n          if (cellData) {\n            this.trigger('restore', cellData);\n          }\n        },\n\n        /**\n         * Returns an array of visible column names.\n         * @returns {Array.<String>} Visible column names\n         * @private\n         */\n        _getColumnNameList: function _getColumnNameList() {\n          var columnModels = this.columnModel.getVisibleColumns(null, true);\n          return _.pluck(columnModels, 'name');\n        },\n\n        /**\n         * Event handler for 'disabledChanged' event on dataModel\n         */\n        _onDataModelDisabledChanged: function _onDataModelDisabledChanged() {\n          var columnNames = this._getColumnNameList();\n\n          _.each(columnNames, function (columnName) {\n            this.setCell(columnName, {\n              disabled: this.rowData.isDisabled(columnName),\n              className: this._getClassNameString(columnName)\n            });\n          }, this);\n        },\n\n        /**\n         * Sets the 'disabled', 'editable', 'className' property of each cell data.\n         * @private\n         */\n        _setRowExtraData: function _setRowExtraData() {\n          _.each(this._getColumnNameList(), function (columnName) {\n            var cellData = this.get(columnName);\n\n            if (!snippet.isUndefined(cellData) && cellData.isMainRow) {\n              if (cellData.tree) {\n                this._setTreeCell(columnName);\n              } else {\n                this._setCell(columnName);\n              }\n            }\n          }, this);\n        },\n\n        /**\n         * Set normal cell's properties\n         * @param {string} columnName - Column name\n         * @private\n         */\n        _setCell: function _setCell(columnName) {\n          var cellState = this.rowData.getCellState(columnName);\n          this.setCell(columnName, {\n            disabled: cellState.disabled,\n            editable: cellState.editable,\n            className: this._getClassNameString(columnName)\n          });\n        },\n\n        /**\n         * Set tree-cell's property\n         * @param {string} columnName - Column name\n         * @private\n         */\n        _setTreeCell: function _setTreeCell(columnName) {\n          this.setCell(columnName, {\n            isExpanded: this.rowData.getTreeExpanded()\n          });\n        },\n\n        /**\n         * Overrides Backbone.Model.parse\n         * (this method is called before initialize method)\n         * @param {Array} data - Original data\n         * @param {Object} options - Options\n         * @returns {Array} - Converted data.\n         * @override\n         */\n        parse: function parse(data, options) {\n          return this._formatData(data, options.dataModel, options.columnModel, options.focusModel);\n        },\n\n        /**\n         * Convert the original data to the rendering data.\n         * @param {Array} data - Original data\n         * @param {module:model/data/rowList} dataModel - Data model\n         * @param {module:model/data/columnModel} columnModel - Column model\n         * @param {module:model/data/focusModel} focusModel - focus model\n         * @param {Number} rowHeight - The height of a row\n         * @returns {Array} - Converted data\n         * @private\n         */\n        _formatData: function _formatData(data, dataModel, columnModel, focusModel) {\n          var rowKey = data.rowKey;\n          var rowHeight = data.height;\n          var columnData, row;\n\n          if (_.isUndefined(rowKey)) {\n            return data;\n          }\n\n          row = dataModel.get(rowKey);\n          columnData = _.omit(data, 'rowKey', '_extraData', 'height', 'rowNum');\n\n          _.each(columnData, function (value, columnName) {\n            var rowSpanData = this._getRowSpanData(columnName, data, dataModel.isRowSpanEnable());\n\n            var cellState = row.getCellState(columnName);\n            var isTextType = columnModel.isTextType(columnName);\n            var column = columnModel.getColumnModel(columnName);\n            data[columnName] = {\n              rowKey: rowKey,\n              height: rowHeight,\n              columnName: columnName,\n              rowSpan: rowSpanData.count,\n              isMainRow: rowSpanData.isMainRow,\n              mainRowKey: rowSpanData.mainRowKey,\n              editable: cellState.editable,\n              disabled: cellState.disabled,\n              editing: focusModel.isEditingCell(rowKey, columnName),\n              whiteSpace: column.whiteSpace || 'nowrap',\n              valign: column.valign,\n              listItems: snippet.pick(column, 'editOptions', 'listItems'),\n              className: this._getClassNameString(columnName, row, focusModel),\n              columnModel: column,\n              changed: [] // changed property names\n\n            };\n\n            _.assign(data[columnName], this._getValueAttrs(value, row, column, isTextType));\n\n            _.assign(data[columnName], this._getTreeAttrs(value, row, column, columnModel));\n          }, this);\n\n          return data;\n        },\n\n        /**\n         * Returns the class name string of the a cell.\n         * @param {String} columnName - column name\n         * @param {module:model/data/row} [row] - data model of a row\n         * @param {module:model/focus} [focusModel] - focus model\n         * @returns {String}\n         */\n        _getClassNameString: function _getClassNameString(columnName, row, focusModel) {\n          var classNames;\n\n          if (!row) {\n            row = this.dataModel.get(this.get('rowKey'));\n\n            if (!row) {\n              return '';\n            }\n          }\n\n          if (!focusModel) {\n            focusModel = this.focusModel;\n          }\n\n          classNames = row.getClassNameList(columnName);\n          return classNames.join(' ');\n        },\n\n        /**\n         * Returns the tree values of the attributes related to the cell value.\n         * @param {String|Number} value - Value\n         * @param {module:model/data/row} row - Row data model\n         * @param {Object} column - Column model object\n         * @param {module:model/data/columnModel} columnModel - column model\n         * @returns {Object}\n         * @private\n         */\n        _getTreeAttrs: function _getTreeAttrs(value, row, column, columnModel) {\n          var attrs = {};\n\n          if (columnModel.isTreeType(column.name)) {\n            attrs = {\n              tree: columnModel.hasTreeColumn(),\n              depth: row.getTreeDepth(),\n              isExpanded: row.getTreeExpanded(),\n              hasChildren: row.hasTreeChildren(),\n              useIcon: columnModel.useTreeIcon()\n            };\n          }\n\n          return attrs;\n        },\n\n        /**\n         * Returns the values of the attributes related to the cell value.\n         * @param {String|Number} value - Value\n         * @param {module:model/data/row} row - Row data model\n         * @param {Object} column - Column model object\n         * @param {Boolean} isTextType - True if the cell is the text-type\n         * @returns {Object}\n         * @private\n         */\n        _getValueAttrs: function _getValueAttrs(value, row, column, isTextType) {\n          var prefix = snippet.pick(column, 'editOptions', 'prefix');\n          var postfix = snippet.pick(column, 'editOptions', 'postfix');\n          var converter = snippet.pick(column, 'editOptions', 'converter');\n          var rowAttrs = row.toJSON();\n          return {\n            value: this._getValueToDisplay(value, column, isTextType),\n            formattedValue: this._getFormattedValue(value, rowAttrs, column),\n            prefix: this._getExtraContent(prefix, value, rowAttrs),\n            postfix: this._getExtraContent(postfix, value, rowAttrs),\n            convertedHTML: this._getConvertedHTML(converter, value, rowAttrs)\n          };\n        },\n\n        /**\n         * If the column has a 'formatter' function, exeucute it and returns the result.\n         * @param {String} value - value to display\n         * @param {Object} rowAttrs - All attributes of the row\n         * @param {Object} column - Column info\n         * @returns {String}\n         * @private\n         */\n        _getFormattedValue: function _getFormattedValue(value, rowAttrs, column) {\n          var result;\n\n          if (_.isFunction(column.formatter)) {\n            result = column.formatter(value, rowAttrs, column);\n          } else {\n            result = value;\n          }\n\n          if (_.isNumber(result)) {\n            result = String(result);\n          } else if (!result) {\n            result = '';\n          }\n\n          return result;\n        },\n\n        /**\n         * Returns the value of the 'prefix' or 'postfix'.\n         * @param {(String|Function)} content - content\n         * @param {String} cellValue - cell value\n         * @param {Object} rowAttrs - All attributes of the row\n         * @returns {string}\n         * @private\n         */\n        _getExtraContent: function _getExtraContent(content, cellValue, rowAttrs) {\n          var result = '';\n\n          if (_.isFunction(content)) {\n            result = content(cellValue, rowAttrs);\n          } else if (snippet.isExisty(content)) {\n            result = content;\n          }\n\n          return result;\n        },\n\n        /**\n         * If the 'converter' function exist, execute it and returns the result.\n         * @param {Function} converter - converter\n         * @param {String} cellValue - cell value\n         * @param {Object} rowAttrs - All attributes of the row\n         * @returns {(String|Null)} - HTML string or Null\n         * @private\n         */\n        _getConvertedHTML: function _getConvertedHTML(converter, cellValue, rowAttrs) {\n          var convertedHTML = null;\n\n          if (_.isFunction(converter)) {\n            convertedHTML = converter(cellValue, rowAttrs);\n          }\n\n          if (convertedHTML === false) {\n            convertedHTML = null;\n          }\n\n          return convertedHTML;\n        },\n\n        /**\n         * Returns the value to display\n         * @param {String|Number} value - value\n         * @param {String} column - column name\n         * @param {Boolean} isTextType - True if the cell is the text-typee\n         * @returns {String}\n         * @private\n         */\n        _getValueToDisplay: function _getValueToDisplay(value, column, isTextType) {\n          var isExisty = snippet.isExisty;\n          var useHtmlEntity = column.useHtmlEntity;\n          var defaultValue = column.defaultValue;\n\n          if (!isExisty(value)) {\n            value = isExisty(defaultValue) ? defaultValue : '';\n          }\n\n          if (isTextType && useHtmlEntity && snippet.hasEncodableString(value)) {\n            value = snippet.encodeHTMLEntity(value);\n          }\n\n          return value;\n        },\n\n        /**\n         * Returns the rowspan data.\n         * @param {String} columnName - column name\n         * @param {Object} data - data\n         * @param {Boolean} isRowSpanEnable - Whether the rowspan enable\n         * @returns {Object} rowSpanData\n         * @private\n         */\n        _getRowSpanData: function _getRowSpanData(columnName, data, isRowSpanEnable) {\n          var rowSpanData = snippet.pick(data, '_extraData', 'rowSpanData', columnName);\n\n          if (!isRowSpanEnable || !rowSpanData) {\n            rowSpanData = {\n              mainRowKey: data.rowKey,\n              count: 0,\n              isMainRow: true\n            };\n          }\n\n          return rowSpanData;\n        },\n\n        /**\n         * Updates the className attribute of the cell identified by a given column name.\n         * @param {String} columnName - column name\n         */\n        updateClassName: function updateClassName(columnName) {\n          this.setCell(columnName, {\n            className: this._getClassNameString(columnName)\n          });\n        },\n\n        /**\n         * Sets the cell data.\n         * (Each cell data is reference type, so do not change the cell data directly and\n         *  use this method to trigger change event)\n         * @param {String} columnName - Column name\n         * @param {Object} param - Key-Value pair of the data to change\n         */\n        setCell: function setCell(columnName, param) {\n          var isValueChanged = false;\n          var changed = [];\n          var rowIndex, rowKey, data;\n\n          if (!this.has(columnName)) {\n            return;\n          }\n\n          rowKey = this.get('rowKey');\n          data = _.clone(this.get(columnName));\n\n          _.each(param, function (changeValue, name) {\n            if (!util.isEqual(data[name], changeValue)) {\n              isValueChanged = name === 'value' ? true : isValueChanged;\n              data[name] = changeValue;\n              changed.push(name);\n            }\n          }, this);\n\n          if (changed.length) {\n            data.changed = changed;\n            this.set(columnName, data, {\n              silent: this._shouldSetSilently(data, isValueChanged)\n            });\n\n            if (isValueChanged) {\n              rowIndex = this.dataModel.indexOfRowKey(rowKey);\n              this.trigger('valueChange', rowIndex);\n            }\n          }\n        },\n\n        /**\n         * Returns whether the 'set' method should be called silently.\n         * @param {Object} cellData - cell data\n         * @param {Boolean} valueChanged - true if value changed\n         * @returns {Boolean}\n         * @private\n         */\n        _shouldSetSilently: function _shouldSetSilently(cellData, valueChanged) {\n          var valueChangedOnEditing = cellData.editing && valueChanged;\n          var useViewMode = snippet.pick(cellData, 'columnModel', 'editOptions', 'useViewMode') !== false;\n          var editingChangedToTrue = _.contains(cellData.changed, 'editing') && cellData.editing; // Silent Cases\n          // 1: If values have been changed while the editing is true,\n          //    prevent the related cell-view from changing its value-state until editing is finished.\n          // 2: If useViewMode is true and editing is changing to true,\n          //    prevent the related cell-view from changing its state to enable editing,\n          //    as the editing-layer will be used for editing instead.\n\n          return valueChangedOnEditing || useViewMode && editingChangedToTrue;\n        }\n      });\n      module.exports = Row;\n      /***/\n    },\n    /* 28 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview RowList 클래스파일\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var Collection = __webpack_require__(13);\n\n      var Row = __webpack_require__(27);\n      /**\n        * View Model rowList collection\n        * @module model/rowList\n        * @extends module:base/collection\n        * @param {Object} rawData - Raw data\n        * @param {Object} options - Options\n        * @ignore\n        */\n\n\n      var RowList = Collection.extend(\n      /** @lends module:model/rowList.prototype */\n      {\n        initialize: function initialize(rawData, options) {\n          _.assign(this, {\n            dataModel: options.dataModel,\n            columnModel: options.columnModel,\n            focusModel: options.focusModel\n          });\n        },\n        model: Row\n      });\n      module.exports = RowList;\n      /***/\n    },\n    /* 29 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Render model to be used for smart-rendering\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var Renderer = __webpack_require__(26);\n\n      var dimensionConst = __webpack_require__(10).dimension;\n\n      var CELL_BORDER_WIDTH = dimensionConst.CELL_BORDER_WIDTH; // The ratio of buffer size to bodyHeight\n\n      var BUFFER_RATIO = 0.3; // The ratio of the size bodyHeight which can cause to refresh the rendering range\n\n      var BUFFER_HIT_RATIO = 0.1;\n      /**\n       * Render model to be used for smart-rendering\n       * @module model/renderer-smart\n       * @extends module:model/renderer\n       * @ignore\n       */\n\n      var SmartRenderer = Renderer.extend(\n      /** @lends module:model/renderer-smart.prototype */\n      {\n        initialize: function initialize() {\n          Renderer.prototype.initialize.apply(this, arguments);\n          this.on('change:scrollTop', this._onChangeScrollTop, this);\n          this.listenTo(this.dimensionModel, 'change:bodyHeight', this._onChangeBodyHeight);\n        },\n\n        /**\n         * Event handler for change:scrollTop event\n         * @private\n         */\n        _onChangeScrollTop: function _onChangeScrollTop() {\n          if (this._shouldRefresh(this.get('scrollTop'))) {\n            this._setRenderingRange();\n          }\n        },\n\n        /**\n         * Event handler for change:bodyHeight event on model/dimension\n         * @private\n         */\n        _onChangeBodyHeight: function _onChangeBodyHeight() {\n          this._setRenderingRange();\n        },\n\n        /**\n         * Calculate the range to render and set the attributes.\n         * @param {boolean} silent - whether set attributes silently\n         * @private\n         */\n        _setRenderingRange: function _setRenderingRange(silent) {\n          var scrollTop = this.get('scrollTop');\n          var dimensionModel = this.dimensionModel;\n          var dataModel = this.dataModel;\n          var coordRowModel = this.coordRowModel;\n          var bodyHeight = dimensionModel.get('bodyHeight');\n          var bufferSize = parseInt(bodyHeight * BUFFER_RATIO, 10);\n          var startIndex = Math.max(coordRowModel.indexOf(scrollTop - bufferSize), 0);\n          var endIndex = Math.min(coordRowModel.indexOf(scrollTop + bodyHeight + bufferSize), dataModel.length - 1);\n          var top, bottom;\n\n          if (dataModel.isRowSpanEnable()) {\n            startIndex += this._getStartRowSpanMinCount(startIndex);\n            endIndex += this._getEndRowSpanMaxCount(endIndex);\n          }\n\n          top = coordRowModel.getOffsetAt(startIndex);\n          bottom = coordRowModel.getOffsetAt(endIndex) + coordRowModel.getHeightAt(endIndex) + CELL_BORDER_WIDTH;\n          this.set({\n            top: top,\n            bottom: bottom,\n            startIndex: startIndex,\n            endIndex: endIndex\n          }, {\n            silent: silent\n          });\n        },\n\n        /**\n         * 렌더링을 시작하는 행에 rowSpan 정보가 있으면, count 값이 가장 작은 행의 값을 반환한다.\n         * @param {number} startIndex 시작하는 행의 Index\n         * @returns {number} rowSpan의 count 값 (0 이하)\n         * @private\n         */\n        _getStartRowSpanMinCount: function _getStartRowSpanMinCount(startIndex) {\n          var firstRow = this.dataModel.at(startIndex);\n          var result = 0;\n          var counts;\n\n          if (firstRow) {\n            counts = _.pluck(firstRow.getRowSpanData(), 'count');\n            counts.push(0); // count가 음수인 경우(mainRow가 아닌 경우)에만 최소값을 구함. 없으면 0\n\n            result = _.min(counts);\n          }\n\n          return result;\n        },\n\n        /**\n         * 렌더링할 마지막 행에 rowSpan 정보가 있으면, count 값이 가장 큰 행의 값을 반환한다.\n         * @param {number} endIndex 마지막 행의 Index\n         * @returns {number} rowSpan의 count 값 (0 이상)\n         * @private\n         */\n        _getEndRowSpanMaxCount: function _getEndRowSpanMaxCount(endIndex) {\n          var lastRow = this.dataModel.at(endIndex);\n          var result = 0;\n          var counts;\n\n          if (lastRow) {\n            counts = _.pluck(lastRow.getRowSpanData(), 'count');\n            counts.push(0); // count가 양수인 경우(mainRow인 경우)에만 최대값을 구함. 없으면 0\n\n            result = _.max(counts);\n          } // subtract 1, as the count includes main-cell itself\n\n\n          if (result > 0) {\n            result -= 1;\n          }\n\n          return result;\n        },\n\n        /**\n         * Returns whether the scroll potision hits the buffer limit or not.\n         * @param {number} scrollTop - scroll top\n         * @returns {boolean}\n         * @private\n         */\n        _shouldRefresh: function _shouldRefresh(scrollTop) {\n          var bodyHeight = this.dimensionModel.get('bodyHeight');\n          var scrollBottom = scrollTop + bodyHeight;\n          var totalRowHeight = this.dimensionModel.get('totalRowHeight');\n          var top = this.get('top');\n          var bottom = this.get('bottom');\n          var bufferHitSize = parseInt(bodyHeight * BUFFER_HIT_RATIO, 10);\n          var hitTopBuffer = scrollTop - top < bufferHitSize;\n          var hitBottomBuffer = bottom - scrollBottom < bufferHitSize;\n          return hitTopBuffer && top > 0 || hitBottomBuffer && bottom < totalRowHeight;\n        }\n      }); // exports consts for external use\n\n      SmartRenderer.BUFFER_RATIO = BUFFER_RATIO;\n      SmartRenderer.BUFFER_HIT_RATIO = BUFFER_HIT_RATIO;\n      module.exports = SmartRenderer;\n      /***/\n    },\n    /* 30 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Selection Model class\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var Model = __webpack_require__(9);\n\n      var GridEvent = __webpack_require__(16);\n\n      var util = __webpack_require__(17);\n\n      var typeConst = __webpack_require__(10).selectionType;\n      /**\n       * Selection Model class\n       * @module model/selection\n       * @extends module:base/view\n       * @param {Object} attr - Attributes\n       * @param {Object} options - Options\n       * @ignore\n       */\n\n\n      var Selection = Model.extend(\n      /** @lends module:model/selection.prototype */\n      {\n        initialize: function initialize(attr, options) {\n          var domEventBus;\n          Model.prototype.initialize.apply(this, arguments);\n\n          _.assign(this, {\n            dataModel: options.dataModel,\n            columnModel: options.columnModel,\n            dimensionModel: options.dimensionModel,\n            focusModel: options.focusModel,\n            renderModel: options.renderModel,\n            coordRowModel: options.coordRowModel,\n            coordConverterModel: options.coordConverterModel,\n            domEventBus: options.domEventBus,\n            inputRange: null,\n            minimumColumnRange: null,\n            intervalIdForAutoScroll: null,\n            scrollPixelScale: 40,\n            enabled: true,\n            selectionType: typeConst.CELL\n          });\n\n          this.listenTo(this.dataModel, 'add remove sort reset', this.end);\n          this.listenTo(this.dataModel, 'paste', this._onPasteData);\n\n          if (this.isEnabled() && options.domEventBus) {\n            domEventBus = options.domEventBus;\n            this.listenTo(domEventBus, 'dragstart:header', this._onDragStartHeader);\n            this.listenTo(domEventBus, 'dragmove:header', this._onDragMoveHeader);\n            this.listenTo(domEventBus, 'dragmove:body', this._onDragMoveBody);\n            this.listenTo(domEventBus, 'dragend:body', this._onDragEndBody);\n            this.listenTo(domEventBus, 'mousedown:body', this._onMouseDownBody);\n            this.listenTo(domEventBus, 'key:move key:edit', this._onKeyMoveOrEdit);\n            this.listenTo(domEventBus, 'key:select', this._onKeySelect);\n            this.listenTo(domEventBus, 'key:delete', this._onKeyDelete);\n          }\n\n          this.on('change:range', this._triggerSelectionEvent);\n          this.mouseupHandler = $.proxy(this.stopAutoScroll, this);\n          $(document).on('mouseup', this.mouseupHandler);\n        },\n        defaults: {\n          /**\n           * Selection range\n           * ex) {row: [0, 1], column: [1, 2]}\n           * @type {{row: array, column: array}}\n           * @ignore\n           */\n          range: null,\n          selectionUnit: 'cell'\n        },\n\n        /**\n         * Event handler for 'dragstart:header' event on domEventBus\n         * @param {module:event/gridEvent} gridEvent - GridEvent\n         * @private\n         */\n        _onDragStartHeader: function _onDragStartHeader(gridEvent) {\n          var columnModel = this.columnModel;\n          var columnNames = columnModel.getUnitColumnNamesIfMerged(gridEvent.columnName);\n          var columnRange;\n\n          if (_.some(columnNames, util.isMetaColumn)) {\n            gridEvent.stop();\n            return;\n          }\n\n          columnRange = this._getColumnRangeWithNames(columnNames);\n\n          if (gridEvent.shiftKey) {\n            this.update(0, columnRange[1], typeConst.COLUMN);\n\n            this._extendColumnSelection(columnRange, gridEvent.pageX, gridEvent.pageY);\n          } else {\n            this.minimumColumnRange = columnRange;\n            this.selectColumn(columnRange[0]);\n            this.update(0, columnRange[1]);\n          }\n        },\n\n        /**\n         * Event handler for 'dragmove:header' event on domEventBus\n         * @param {module:event/gridEvent} gridEvent - GridEvent\n         * @private\n         */\n        _onDragMoveHeader: function _onDragMoveHeader(gridEvent) {\n          var columnModel = this.columnModel;\n          var columnNames, columnRange;\n\n          if (gridEvent.isOnHeaderArea && !gridEvent.columnName) {\n            return;\n          }\n\n          columnNames = columnModel.getUnitColumnNamesIfMerged(gridEvent.columnName);\n\n          if (columnNames.length) {\n            columnRange = this._getColumnRangeWithNames(columnNames);\n          }\n\n          this._extendColumnSelection(columnRange, gridEvent.pageX, gridEvent.pageY);\n        },\n\n        /**\n         * Event handler for key:move/key:edit fevent on domEventBus\n         * @private\n         */\n        _onKeyMoveOrEdit: function _onKeyMoveOrEdit() {\n          this.end();\n        },\n\n        /**\n         * Event handler for key:select event on domEventBus\n         * @param {module:event/gridEvent} ev - GridEvent\n         * @private\n         */\n        _onKeySelect: function _onKeySelect(ev) {\n          // eslint-disable-line complexity\n          var address = this._getRecentAddress();\n\n          var lastRowIndex = this.dataModel.length - 1;\n          var lastColummnIndex = this.columnModel.getVisibleColumns().length - 1;\n          var rowKey = this.dataModel.at(address.row).get('rowKey');\n\n          switch (ev.command) {\n            case 'up':\n              address.row += this.coordRowModel.getPreviousOffset(rowKey);\n              break;\n\n            case 'down':\n              address.row += this.coordRowModel.getNextOffset(rowKey);\n              break;\n\n            case 'left':\n              address.column -= 1;\n              break;\n\n            case 'right':\n              address.column += 1;\n              break;\n\n            case 'pageUp':\n              address.row = this.coordRowModel.getPageMovedIndex(address.row, false);\n              break;\n\n            case 'pageDown':\n              address.row = this.coordRowModel.getPageMovedIndex(address.row, true);\n              break;\n\n            case 'firstColumn':\n              address.column = 0;\n              break;\n\n            case 'lastColumn':\n              address.column = lastColummnIndex;\n              break;\n\n            case 'firstCell':\n              address.row = 0;\n              address.column = 0;\n              break;\n\n            case 'lastCell':\n              address.row = lastRowIndex;\n              address.column = lastColummnIndex;\n              break;\n\n            case 'all':\n              this.selectAll();\n              address = null;\n              break;\n\n            default:\n              address = null;\n          }\n\n          if (address) {\n            this.update(address.row, address.column);\n\n            this._scrollTo(address.row, address.column);\n          }\n        },\n\n        /**\n         * Event handler for key:delete event on domEventBus\n         * @private\n         */\n        _onKeyDelete: function _onKeyDelete() {\n          var dataModel = this.dataModel;\n          var focused;\n\n          if (this.hasSelection()) {\n            dataModel.delRange(this.get('range'));\n          } else {\n            focused = this.focusModel.which();\n            dataModel.del(focused.rowKey, focused.columnName);\n          }\n        },\n\n        /**\n         * Return an address of recently extended cell\n         * @returns {{row: number, column:number}} index\n         * @private\n         */\n        _getRecentAddress: function _getRecentAddress() {\n          var focusedIndex = this.focusModel.indexOf();\n          var selectionRange = this.get('range');\n\n          var index = _.assign({}, focusedIndex);\n\n          var selectionRowRange, selectionColumnRange;\n\n          if (selectionRange) {\n            selectionRowRange = selectionRange.row;\n            selectionColumnRange = selectionRange.column;\n            index.row = selectionRowRange[0];\n            index.column = selectionColumnRange[0];\n\n            if (selectionRowRange[1] > focusedIndex.row) {\n              index.row = selectionRowRange[1];\n            }\n\n            if (selectionColumnRange[1] > focusedIndex.column) {\n              index.column = selectionColumnRange[1];\n            }\n          }\n\n          return index;\n        },\n\n        /**\n         * Returns whether the given address is valid\n         * @param {{row: number, column: number}} address - address\n         * @returns {boolean}\n         * @private\n         */\n        _isValidAddress: function _isValidAddress(address) {\n          return !!this.dataModel.at(address.row) && !!this.columnModel.at(address.colummn);\n        },\n\n        /**\n         * Scrolls to the position of given address\n         * @param {number} rowIndex - row index\n         * @param {number} columnIndex - column index\n         * @private\n         */\n        _scrollTo: function _scrollTo(rowIndex, columnIndex) {\n          var row = this.dataModel.at(rowIndex);\n          var column = this.columnModel.at(columnIndex);\n          var rowKey, columnName, selectionType, scrollPosition;\n\n          if (!row || !column) {\n            return;\n          }\n\n          rowKey = row.get('rowKey');\n          columnName = column.name;\n          scrollPosition = this.coordConverterModel.getScrollPosition(rowKey, columnName);\n\n          if (scrollPosition) {\n            selectionType = this.getType();\n\n            if (selectionType === typeConst.COLUMN) {\n              delete scrollPosition.scrollTop;\n            } else if (selectionType === typeConst.ROW) {\n              delete scrollPosition.scrollLeft;\n            }\n\n            this.renderModel.set(scrollPosition);\n          }\n        },\n\n        /**\n         * Examine the type of selection with given column index\n         * @param {Number} columnIndex - columnIndex\n         * @returns {String}\n         * @private\n         */\n        _getTypeByColumnIndex: function _getTypeByColumnIndex(columnIndex) {\n          var visibleColumns = this.columnModel.getVisibleColumns(null, true);\n          var columnName = visibleColumns[columnIndex].name;\n\n          switch (columnName) {\n            case '_button':\n              return null;\n\n            case '_number':\n              return typeConst.ROW;\n\n            default:\n              return typeConst.CELL;\n          }\n        },\n\n        /**\n         * Event handler for 'mousedown:body' event on domEventBus\n         * @param {module:event/gridEvent} gridEvent - GridEvent\n         * @private\n         */\n        _onMouseDownBody: function _onMouseDownBody(gridEvent) {\n          var address = this.coordConverterModel.getIndexFromMousePosition(gridEvent.pageX, gridEvent.pageY, true);\n\n          var selType = this._getTypeByColumnIndex(address.column);\n\n          var rowIndex, columnIndex;\n\n          if (!selType) {\n            return;\n          }\n\n          rowIndex = address.row;\n          columnIndex = address.column - this.columnModel.getVisibleMetaColumnCount();\n\n          if (gridEvent.shiftKey) {\n            this.update(rowIndex, Math.max(columnIndex, 0));\n          } else if (selType === typeConst.ROW) {\n            this.selectRow(rowIndex);\n          } else {\n            this.focusModel.focusAt(rowIndex, columnIndex);\n            this.end();\n          }\n        },\n\n        /**\n         * Event handler for 'dragmove:body' event on domEventBus\n         * @param {module:event/gridEvent} gridEvent - GridEvent\n         * @private\n         */\n        _onDragMoveBody: function _onDragMoveBody(gridEvent) {\n          var address = this.coordConverterModel.getIndexFromMousePosition(gridEvent.pageX, gridEvent.pageY);\n          this.update(address.row, address.column);\n\n          this._setScrolling(gridEvent.pageX, gridEvent.pageY);\n        },\n\n        /**\n         * Event handler for 'dragend:body' event on domEventBus\n         * @private\n         */\n        _onDragEndBody: function _onDragEndBody() {\n          this.stopAutoScroll();\n        },\n\n        /**\n         * Event handler for 'paste' event on DataModel\n         * @param {Object} range - Range\n         */\n        _onPasteData: function _onPasteData(range) {\n          this.start(range.startIdx.row, range.startIdx.column);\n          this.update(range.endIdx.row, range.endIdx.column);\n        },\n\n        /**\n         * Returns the range of column index of given column names\n         * @param {Array.<string>} columnNames - column names\n         * @returns {Array.<number>}\n         * @private\n         */\n        _getColumnRangeWithNames: function _getColumnRangeWithNames(columnNames) {\n          var columnModel = this.columnModel;\n\n          var columnIndexes = _.map(columnNames, function (name) {\n            return columnModel.indexOfColumnName(name, true);\n          });\n\n          var minMax = util.getMinMax(columnIndexes);\n          return [minMax.min, minMax.max];\n        },\n\n        /**\n         * Set selection type\n         * @param {string} type - Selection type (CELL, ROW, COLUMN)\n         */\n        setType: function setType(type) {\n          this.selectionType = typeConst[type] || this.selectionType;\n        },\n\n        /**\n         * Returns the selection type (using internal state)\n         * @returns {string} type - Selection type (CELL, ROW, COLUMN)\n         */\n        getType: function getType() {\n          return this.selectionType;\n        },\n\n        /**\n         * Returns the selection unit (by options)\n         * @returns {string} unit - Selection unit (CELL, ROW)\n         */\n        getSelectionUnit: function getSelectionUnit() {\n          return this.get('selectionUnit').toUpperCase();\n        },\n\n        /**\n         * Enables the selection.\n         */\n        enable: function enable() {\n          this.enabled = true;\n        },\n\n        /**\n         * Disables the selection.\n         */\n        disable: function disable() {\n          this.end();\n          this.enabled = false;\n        },\n\n        /**\n         * Returns whether the selection is enabled.\n         * @returns {boolean} True if the selection is enabled.\n         */\n        isEnabled: function isEnabled() {\n          return this.enabled;\n        },\n\n        /**\n         * Starts the selection.\n         * @param {Number} rowIndex - Row index\n         * @param {Number} columnIndex - Column index\n         * @param {string} type - Selection type\n         */\n        start: function start(rowIndex, columnIndex, type) {\n          if (!this.isEnabled()) {\n            return;\n          }\n\n          this.setType(type);\n          this.inputRange = {\n            row: [rowIndex, rowIndex],\n            column: [columnIndex, columnIndex]\n          };\n\n          this._resetRangeAttribute();\n        },\n\n        /**\n         * Updates the selection range.\n         * @param {number} rowIndex - Row index\n         * @param {number} columnIndex - Column index\n         * @param {string} [type] - Selection type\n         */\n        update: function update(rowIndex, columnIndex, type) {\n          // eslint-disable-line complexity\n          var focusedIndex;\n\n          if (!this.enabled || type !== typeConst.COLUMN && rowIndex < 0 || type !== typeConst.ROW && columnIndex < 0) {\n            return;\n          }\n\n          if (!this.hasSelection()) {\n            focusedIndex = this.focusModel.indexOf();\n\n            if (this.getSelectionUnit() === typeConst.ROW) {\n              this.start(focusedIndex.row, 0, typeConst.ROW);\n            } else {\n              this.start(focusedIndex.row, focusedIndex.column, typeConst.CELL);\n            }\n          } else {\n            this.setType(type);\n          }\n\n          this._updateInputRange(rowIndex, columnIndex);\n\n          this._resetRangeAttribute();\n        },\n\n        /**\n         * Update input range (end range, not start range)\n         * @param {number} rowIndex - Row index\n         * @param {number} columnIndex - Column index\n         * @private\n         */\n        _updateInputRange: function _updateInputRange(rowIndex, columnIndex) {\n          var inputRange = this.inputRange;\n\n          if (this.selectionType === typeConst.ROW) {\n            columnIndex = this.columnModel.getVisibleColumns().length - 1;\n          } else if (this.selectionType === typeConst.COLUMN) {\n            rowIndex = this.dataModel.length - 1;\n          }\n\n          inputRange.row[1] = rowIndex;\n          inputRange.column[1] = columnIndex;\n        },\n\n        /**\n         * Extend column selection\n         * @param {undefined|Array} columnIndexes - Column indexes\n         * @param {number} pageX - Mouse position X\n         * @param {number} pageY - Mouse positino Y\n         * @private\n         */\n        _extendColumnSelection: function _extendColumnSelection(columnIndexes, pageX, pageY) {\n          var minimumColumnRange = this.minimumColumnRange;\n          var index = this.coordConverterModel.getIndexFromMousePosition(pageX, pageY);\n          var range = {\n            row: [0, this.dataModel.length - 1],\n            column: []\n          };\n          var minMax;\n\n          if (!columnIndexes || !columnIndexes.length) {\n            columnIndexes = [index.column];\n          }\n\n          this._setScrolling(pageX, pageY);\n\n          if (minimumColumnRange) {\n            minMax = util.getMinMax(columnIndexes.concat(minimumColumnRange));\n          } else {\n            columnIndexes.push(this.inputRange.column[0]);\n            minMax = util.getMinMax(columnIndexes);\n          }\n\n          range.column.push(minMax.min, minMax.max);\n\n          this._resetRangeAttribute(range);\n        },\n\n        /**\n         * Set auto scrolling for selection\n         * @param {number} pageX - Mouse position X\n         * @param {number} pageY - Mouse positino Y\n         * @private\n         */\n        _setScrolling: function _setScrolling(pageX, pageY) {\n          var overflow = this.dimensionModel.getOverflowFromMousePosition(pageX, pageY);\n          this.stopAutoScroll();\n\n          if (this._isAutoScrollable(overflow.x, overflow.y)) {\n            this.intervalIdForAutoScroll = setInterval(_.bind(this._adjustScroll, this, overflow.x, overflow.y));\n          }\n        },\n\n        /**\n         * selection 영역 선택을 종료하고 selection 데이터를 초기화한다.\n         */\n        end: function end() {\n          this.inputRange = null;\n          this.unset('range');\n          this.minimumColumnRange = null;\n        },\n\n        /**\n         * Stops the auto-scroll interval.\n         */\n        stopAutoScroll: function stopAutoScroll() {\n          if (!_.isNull(this.intervalIdForAutoScroll)) {\n            clearInterval(this.intervalIdForAutoScroll);\n            this.intervalIdForAutoScroll = null;\n          }\n        },\n\n        /**\n         * Select all data in a row\n         * @param {Number} rowIndex - Row idnex\n         */\n        selectRow: function selectRow(rowIndex) {\n          if (this.isEnabled()) {\n            this.focusModel.focusAt(rowIndex, 0);\n            this.start(rowIndex, 0, typeConst.ROW);\n            this.update(rowIndex, this.columnModel.getVisibleColumns().length - 1);\n          }\n        },\n\n        /**\n         * Select all data in a column\n         * @param {Number} columnIdx - Column index\n         */\n        selectColumn: function selectColumn(columnIdx) {\n          if (this.isEnabled()) {\n            this.focusModel.focusAt(0, columnIdx);\n            this.start(0, columnIdx, typeConst.COLUMN);\n            this.update(this.dataModel.length - 1, columnIdx);\n          }\n        },\n\n        /**\n         * Selects all data range.\n         */\n        selectAll: function selectAll() {\n          if (this.isEnabled()) {\n            this.start(0, 0, typeConst.CELL);\n            this.update(this.dataModel.length - 1, this.columnModel.getVisibleColumns().length - 1);\n          }\n        },\n\n        /**\n         * Returns the row and column indexes of the starting position.\n         * @returns {{row: number, column: number}} Objects containing indexes\n         */\n        getStartIndex: function getStartIndex() {\n          var range = this.get('range');\n          return {\n            row: range.row[0],\n            column: range.column[0]\n          };\n        },\n\n        /**\n         * Returns the row and column indexes of the ending position.\n         * @returns {{row: number, column: number}} Objects containing indexes\n         */\n        getEndIndex: function getEndIndex() {\n          var range = this.get('range');\n          return {\n            row: range.row[1],\n            column: range.column[1]\n          };\n        },\n\n        /**\n         * selection 데이터가 존재하는지 확인한다.\n         * @returns {boolean} selection 데이터 존재여부\n         */\n        hasSelection: function hasSelection() {\n          return !!this.get('range');\n        },\n\n        /**\n         * Returns whether given range is a single cell. (include merged cell)\n         * @param {Array.<String>} columnNames - columnNames\n         * @param {Array.<Object>} rowList - rowList\n         * @returns {Boolean}\n         */\n        _isSingleCell: function _isSingleCell(columnNames, rowList) {\n          var isSingleColumn = columnNames.length === 1;\n          var isSingleRow = rowList.length === 1;\n          var isSingleMergedCell = isSingleColumn && !isSingleRow && rowList[0].getRowSpanData(columnNames[0]).count === rowList.length;\n          return isSingleColumn && isSingleRow || isSingleMergedCell;\n        },\n\n        /**\n         * Returns the string value of all cells in the selection range as a single string.\n         * @returns {String}\n         */\n        getValuesToString: function getValuesToString() {\n          var self = this;\n\n          var rowList = this._getRangeRowList();\n\n          var columnNames = this._getRangeColumnNames();\n\n          var rowValues = _.map(rowList, function (row) {\n            return _.map(columnNames, function (columnName) {\n              return self.getValueToString(row.get('rowKey'), columnName);\n            }).join('\\t');\n          });\n\n          if (this._isSingleCell(columnNames, rowList)) {\n            return rowValues[0];\n          }\n\n          return rowValues.join('\\n');\n        },\n\n        /**\n         * Returns the string value of a single cell by copy options.\n         * @param {Nubmer} rowKey - Row key\n         * @param {Number} columnName - Column name\n         * @returns {String}\n         */\n        getValueToString: function getValueToString(rowKey, columnName) {\n          var columnModel = this.columnModel;\n          var cellData = this.renderModel.getCellData(rowKey, columnName);\n          var copyOptions = columnModel.getCopyOptions(columnName);\n          var column = columnModel.getColumnModel(columnName);\n          var row = this.dataModel.get(rowKey);\n          var value = row.getValueString(columnName);\n          var text;\n\n          if (copyOptions.customValue) {\n            text = this._getCustomValue(copyOptions.customValue, value, row.toJSON(), column);\n          } else if (copyOptions.useListItemText) {\n            text = value;\n          } else if (copyOptions.useFormattedValue) {\n            text = cellData.formattedValue;\n          } else {\n            text = value;\n          }\n\n          return text;\n        },\n\n        /**\n         * If the column has a 'copyOptions.customValue' function, exeucute it and returns the result.\n         * @param {String} customValue - value to display\n         * @param {String} value - value to display\n         * @param {Object} rowAttrs - All attributes of the row\n         * @param {Object} column - Column info\n         * @returns {String}\n         * @private\n         */\n        _getCustomValue: function _getCustomValue(customValue, value, rowAttrs, column) {\n          var result;\n\n          if (_.isFunction(customValue)) {\n            result = customValue(value, rowAttrs, column);\n          } else {\n            result = customValue;\n          }\n\n          return result;\n        },\n\n        /**\n         * Returns an array of selected row list\n         * @returns {Array.<module:model/data/row>}\n         * @private\n         */\n        _getRangeRowList: function _getRangeRowList() {\n          var rowRange = this.get('range').row;\n          var index = rowRange[0];\n          var len = rowRange[1] + 1;\n          var rowList = [];\n\n          for (; index < len; index += 1) {\n            if (this.coordRowModel.getHeightAt(index)) {\n              rowList.push(this.dataModel.at(index));\n            }\n          }\n\n          return rowList;\n        },\n\n        /**\n         * Returns an array of selected column names\n         * @returns {Array.<string>}\n         * @private\n         */\n        _getRangeColumnNames: function _getRangeColumnNames() {\n          var columnRange = this.get('range').column;\n          var columns = this.columnModel.getVisibleColumns().slice(columnRange[0], columnRange[1] + 1);\n          return _.pluck(columns, 'name');\n        },\n\n        /**\n         * 마우스 드래그로 selection 선택 시 auto scroll 조건에 해당하는지 반환한다.\n         * @param {Number} overflowX    가로축 기준 영역 overflow 값\n         * @param {Number} overflowY    세로축 기준 영역 overflow 값\n         * @returns {boolean} overflow 되었는지 여부\n         * @private\n         */\n        _isAutoScrollable: function _isAutoScrollable(overflowX, overflowY) {\n          return !(overflowX === 0 && overflowY === 0);\n        },\n\n        /**\n         * Adjusts scrollTop and scrollLeft value.\n         * @param {Number} overflowX    가로축 기준 영역 overflow 값\n         * @param {Number} overflowY    세로축 기준 영역 overflow 값\n         * @private\n         */\n        _adjustScroll: function _adjustScroll(overflowX, overflowY) {\n          var renderModel = this.renderModel;\n\n          if (overflowX) {\n            this._adjustScrollLeft(overflowX, renderModel.get('scrollLeft'), renderModel.get('maxScrollLeft'));\n          }\n\n          if (overflowY) {\n            this._adjustScrollTop(overflowY, renderModel.get('scrollTop'), renderModel.get('maxScrollTop'));\n          }\n        },\n\n        /**\n         * Adjusts scrollLeft value.\n         * @param  {number} overflowX - 1 | 0 | -1\n         * @param  {number} scrollLeft - Current scrollLeft value\n         * @param  {number} maxScrollLeft - Max scrollLeft value\n         * @private\n         */\n        _adjustScrollLeft: function _adjustScrollLeft(overflowX, scrollLeft, maxScrollLeft) {\n          var adjusted = scrollLeft;\n          var pixelScale = this.scrollPixelScale;\n\n          if (overflowX < 0) {\n            adjusted = Math.max(0, scrollLeft - pixelScale);\n          } else if (overflowX > 0) {\n            adjusted = Math.min(maxScrollLeft, scrollLeft + pixelScale);\n          }\n\n          this.renderModel.set('scrollLeft', adjusted);\n        },\n\n        /**\n         * Adjusts scrollTop value.\n         * @param  {number} overflowY - 1 | 0 | -1\n         * @param  {number} scrollTop - Current scrollTop value\n         * @param  {number} maxScrollTop - Max scrollTop value\n         * @private\n         */\n        _adjustScrollTop: function _adjustScrollTop(overflowY, scrollTop, maxScrollTop) {\n          var adjusted = scrollTop;\n          var pixelScale = this.scrollPixelScale;\n\n          if (overflowY < 0) {\n            adjusted = Math.max(0, scrollTop - pixelScale);\n          } else if (overflowY > 0) {\n            adjusted = Math.min(maxScrollTop, scrollTop + pixelScale);\n          }\n\n          this.renderModel.set('scrollTop', adjusted);\n        },\n\n        /**\n         * Expands the 'this.inputRange' if rowspan data exists, and resets the 'range' attributes to the value.\n         * @param {{column: number[], row: number[]}} [inputRange] - Input range. Default is this.inputRange\n         * @private\n         */\n        _resetRangeAttribute: function _resetRangeAttribute(inputRange) {\n          // eslint-disable-line complexity\n          var dataModel = this.dataModel;\n          var hasSpannedRange, spannedRange, tmpRowRange;\n          inputRange = inputRange || this.inputRange;\n\n          if (!inputRange) {\n            this.set('range', null);\n            return;\n          }\n\n          spannedRange = {\n            row: _.sortBy(inputRange.row),\n            column: _.sortBy(inputRange.column)\n          };\n\n          if (dataModel.isRowSpanEnable() && this.selectionType === typeConst.CELL) {\n            do {\n              tmpRowRange = _.assign([], spannedRange.row);\n              spannedRange = this._getRowSpannedIndex(spannedRange);\n              hasSpannedRange = spannedRange.row[0] !== tmpRowRange[0] || spannedRange.row[1] !== tmpRowRange[1];\n            } while (hasSpannedRange);\n\n            this._setRangeMinMax(spannedRange.row, spannedRange.column);\n          }\n\n          this.set('range', spannedRange);\n        },\n\n        /**\n         * Trigger 'selection' event\n         * @private\n         */\n        _triggerSelectionEvent: function _triggerSelectionEvent() {\n          var range = this.get('range');\n          var dataModel = this.dataModel;\n          var columnModel = this.columnModel;\n          var rowRange, columnRange, gridEvent;\n          var startRow, endRow, startColumn, endColumn;\n\n          if (!range) {\n            return;\n          }\n\n          rowRange = range.row;\n          columnRange = range.column;\n          startRow = dataModel.getRowDataAt(rowRange[0]);\n          startColumn = columnModel.at(columnRange[0]);\n          endRow = dataModel.getRowDataAt(rowRange[1]);\n          endColumn = columnModel.at(columnRange[1]);\n\n          if (!startRow || !endRow || !startColumn || !endColumn) {\n            return;\n          }\n\n          gridEvent = new GridEvent(null, {\n            range: {\n              start: [startRow.rowKey, startColumn.name],\n              end: [endRow.rowKey, endColumn.name]\n            }\n          });\n          /**\n           * Occurs when selecting cells\n           * @event Grid#selection\n           * @type {module:event/gridEvent}\n           * @property {Object} range - Range of selection\n           * @property {Array} range.start - Info of start cell (ex: [rowKey, columName])\n           * @property {Array} range.end - Info of end cell (ex: [rowKey, columnName])\n           * @property {Grid} instance - Current grid instance\n           */\n\n          this.trigger('selection', gridEvent);\n        },\n\n        /**\n         * Set min, max value of range(row, column)\n         * @param {Array} rowRange - Row range\n         * @param {Array} columnRange - Column range\n         * @private\n         */\n        _setRangeMinMax: function _setRangeMinMax(rowRange, columnRange) {\n          if (rowRange) {\n            rowRange[0] = Math.max(0, rowRange[0]);\n            rowRange[1] = Math.min(this.dataModel.length - 1, rowRange[1]);\n          }\n\n          if (columnRange) {\n            columnRange[0] = Math.max(0, columnRange[0]);\n            columnRange[1] = Math.min(this.columnModel.getVisibleColumns().length - 1, columnRange[1]);\n          }\n        },\n\n        /**\n         * row start index 기준으로 rowspan 을 확인하며 startRangeList 업데이트 하는 함수\n         * @param {object} param - parameters\n         * @private\n         */\n        _concatRowSpanIndexFromStart: function _concatRowSpanIndexFromStart(param) {\n          var startIndex = param.startIndex;\n          var endIndex = param.endIndex;\n          var columnName = param.columnName;\n          var rowSpanData = param.startRowSpanDataMap && param.startRowSpanDataMap[columnName];\n          var startIndexList = param.startIndexList;\n          var endIndexList = param.endIndexList;\n          var spannedIndex;\n\n          if (!rowSpanData) {\n            return;\n          }\n\n          if (!rowSpanData.isMainRow) {\n            spannedIndex = startIndex + rowSpanData.count;\n            startIndexList.push(spannedIndex);\n          } else {\n            spannedIndex = startIndex + rowSpanData.count - 1;\n\n            if (spannedIndex > endIndex) {\n              endIndexList.push(spannedIndex);\n            }\n          }\n        },\n\n        /**\n         * row end index 기준으로 rowspan 을 확인하며 endRangeList 를 업데이트 하는 함수\n         * @param {object} param - parameters\n         * @private\n         */\n        _concatRowSpanIndexFromEnd: function _concatRowSpanIndexFromEnd(param) {\n          var endIndex = param.endIndex;\n          var columnName = param.columnName;\n          var rowSpanData = param.endRowSpanDataMap && param.endRowSpanDataMap[columnName];\n          var endIndexList = param.endIndexList;\n          var dataModel = param.dataModel;\n          var spannedIndex, tmpRowSpanData;\n\n          if (!rowSpanData) {\n            return;\n          }\n\n          if (!rowSpanData.isMainRow) {\n            spannedIndex = endIndex + rowSpanData.count;\n            tmpRowSpanData = dataModel.at(spannedIndex).getRowSpanData(columnName);\n            spannedIndex += tmpRowSpanData.count - 1;\n\n            if (spannedIndex > endIndex) {\n              endIndexList.push(spannedIndex);\n            }\n          } else {\n            spannedIndex = endIndex + rowSpanData.count - 1;\n            endIndexList.push(spannedIndex);\n          }\n        },\n\n        /**\n         * rowSpan 된 Index range 를 반환한다.\n         * @param {{row: Array, column: Array}} spannedRange 인덱스 정보\n         * @returns {{row: Array, column: Array}} New Range\n         * @private\n         */\n        _getRowSpannedIndex: function _getRowSpannedIndex(spannedRange) {\n          var columns = this.columnModel.getVisibleColumns().slice(spannedRange.column[0], spannedRange.column[1] + 1);\n          var dataModel = this.dataModel;\n          var startIndexList = [spannedRange.row[0]];\n          var endIndexList = [spannedRange.row[1]];\n          var startRow = dataModel.at(spannedRange.row[0]);\n          var endRow = dataModel.at(spannedRange.row[1]);\n          var newSpannedRange = $.extend({}, spannedRange);\n          var startRowSpanDataMap, endRowSpanDataMap, param;\n\n          if (!startRow || !endRow) {\n            return newSpannedRange;\n          }\n\n          startRowSpanDataMap = dataModel.at(spannedRange.row[0]).getRowSpanData();\n          endRowSpanDataMap = dataModel.at(spannedRange.row[1]).getRowSpanData(); // 모든 열을 순회하며 각 열마다 설정된 rowSpan 정보에 따라 인덱스를 업데이트 한다.\n\n          _.each(columns, function (columnModel) {\n            param = {\n              columnName: columnModel.name,\n              startIndex: spannedRange.row[0],\n              endIndex: spannedRange.row[1],\n              endRowSpanDataMap: endRowSpanDataMap,\n              startRowSpanDataMap: startRowSpanDataMap,\n              startIndexList: startIndexList,\n              endIndexList: endIndexList,\n              dataModel: dataModel\n            };\n\n            this._concatRowSpanIndexFromStart(param);\n\n            this._concatRowSpanIndexFromEnd(param);\n          }, this);\n\n          newSpannedRange.row = [Math.min.apply(null, startIndexList), Math.max.apply(null, endIndexList)];\n          return newSpannedRange;\n        },\n\n        /**\n         * remove mouseup event\n         * @private\n         */\n        _destroy: function _destroy() {\n          $(document).off('mouseup', this.mouseupHandler);\n        }\n      });\n      module.exports = Selection;\n      /***/\n    },\n    /* 31 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Focus 관련 데이터 처리름 담당한다.\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var Model = __webpack_require__(9);\n\n      var typeConst = __webpack_require__(10).summaryType;\n      /**\n       * Summary Model\n       * @module model/summary\n       * @extends module:base/model\n       * @param {Object} attr - attributes\n       * @param {Object} options - options\n       * @ignore\n       */\n\n\n      var Summary = Model.extend(\n      /** @lends module:model/summary.prototype */\n      {\n        initialize: function initialize(attr, options) {\n          this.dataModel = options.dataModel;\n          this.columnModel = options.columnModel;\n          /**\n           * Set for storing names of auto-calculate column\n           * The value is always 'true'\n           * @type {Object}\n           * @example\n           * {\n           *     c1: true\n           *     c2: true\n           * }\n           */\n\n          this.autoColumnNameSet = {};\n          /**\n           * Store template functions of each column\n           * K: column name\n           * V: template function\n           * @example\n           * {\n           *     c1: function() {},\n           *     c2: function() {}\n           * }\n           * @type {Object}\n           */\n\n          this.columnTemplateMap = {};\n          /**\n           * Summary value map (KV)\n           * K: column name {string}\n           * V: value map {object}\n           * @type {object}\n           * @example\n           * {\n           *    columnName1: {\n           *        [typeConst.SUM]: 200,\n           *        [typeConst.AVG]: 200,\n           *    },\n           *    columnName2: {\n           *        [typeConst.MAX]: 100\n           *    }\n           * }\n           */\n\n          this.columnSummaryMap = {}; // store defaultContent option for future reset\n\n          this.defaultContent = options.defaultContent; // store columnContent option for future reset\n\n          this.columnContent = options.columnContent;\n          this.listenTo(this.dataModel, 'add remove reset', this._onChangeDataRows);\n          this.listenTo(this.dataModel, 'change', this._onChangeDataCells);\n          this.listenTo(this.dataModel, 'deleteRange', this._onDeleteRangeData);\n          this.listenTo(this.columnModel, 'columnModelChange', this._resetAll);\n\n          this._resetAll();\n        },\n\n        /**\n         * Reset autoColumnNames and columnTemplateMap based on columnContent options.\n         * @param {Object} columnContent - summary.columnContent options\n         * @private\n         */\n        _resetColumnContent: function _resetColumnContent() {\n          var columnContentMap = {};\n          var defaultContent = this.defaultContent;\n          var columnContent = this.columnContent || {};\n\n          if (defaultContent) {\n            _.forEach(this.columnModel.getVisibleColumns(), function (column) {\n              columnContentMap[column.name] = columnContent[column.name] || defaultContent;\n            });\n          } else {\n            columnContentMap = columnContent;\n          }\n\n          _.each(columnContentMap, function (options, columnName) {\n            this.setColumnContent(columnName, options);\n          }, this);\n        },\n\n        /**\n         * Reset autoColumnNameSet, columnTemplateMap, columnSummaryMap\n         * @private\n         */\n        _resetAll: function _resetAll() {\n          this._resetColumnContent();\n\n          this._resetColumnSummaryMap();\n        },\n\n        /**\n         * Calculate summaries of given array.\n         * Values which can not be converted to Number type will be considered as 0.\n         * @param {Array} values - An array of values (to be converted to Number type)\n         * @returns {Object}\n         * @private\n         */\n        _calculate: function _calculate(values) {\n          var min = Number.MAX_VALUE;\n          var max = Number.MIN_VALUE;\n          var count = values.length;\n          var sum = 0;\n          var avg = 0;\n          var resultMap = {};\n          var i, value;\n\n          for (i = 0; i < count; i += 1) {\n            value = Number(values[i]);\n\n            if (isNaN(value)) {\n              value = 0;\n            }\n\n            sum += value;\n\n            if (min > value) {\n              min = value;\n            }\n\n            if (max < value) {\n              max = value;\n            }\n          }\n\n          if (!count) {\n            max = min = avg = 0;\n          } else {\n            avg = sum / count;\n          }\n\n          resultMap[typeConst.SUM] = sum;\n          resultMap[typeConst.MIN] = min;\n          resultMap[typeConst.MAX] = max;\n          resultMap[typeConst.AVG] = avg;\n          resultMap[typeConst.CNT] = count;\n          return resultMap;\n        },\n\n        /**\n         * Reset summary values of given columnName\n         * @param {Array.<string>} columnNames - An array of column names\n         * @private\n         */\n        _resetColumnSummaryMap: function _resetColumnSummaryMap(columnNames) {\n          var targetColumnNames = _.keys(this.autoColumnNameSet);\n\n          if (columnNames) {\n            targetColumnNames = _.intersection(columnNames, targetColumnNames);\n          }\n\n          _.each(targetColumnNames, function (columnName) {\n            this._changeColumnSummaryValue(columnName);\n          }, this);\n        },\n\n        /**\n         * Change Summary Value\n         * @param {string} columnName - column name\n         * @private\n         */\n        _changeColumnSummaryValue: function _changeColumnSummaryValue(columnName) {\n          var values = this.dataModel.getColumnValues(columnName);\n\n          var valueMap = this._calculate(values);\n\n          this.columnSummaryMap[columnName] = valueMap;\n          this.trigger('change', columnName, valueMap);\n        },\n\n        /**\n         * Event handler for 'add', 'append', 'remove' event on dataModel\n         * @private\n         */\n        _onChangeDataRows: function _onChangeDataRows() {\n          this._resetColumnSummaryMap();\n        },\n\n        /**\n         * Event handler for 'change' event on dataModel\n         * @param {object} model - row model\n         * @private\n         */\n        _onChangeDataCells: function _onChangeDataCells(model) {\n          this._resetColumnSummaryMap(_.keys(model.changed));\n        },\n\n        /**\n         * Event handler for 'deleteRange' event on dataModel\n         * @param {GridEvent} ev - event object when \"delRange\" event is fired\n         * @private\n         */\n        _onDeleteRangeData: function _onDeleteRangeData(ev) {\n          this._resetColumnSummaryMap(ev.columnNames);\n        },\n\n        /**\n         * Returns the summary value of given column and type.\n         * If the summaryType is not specified, returns all values of types as an object\n         * @param {string} columnName - column name\n         * @param {string} [summaryType] - summary type\n         * @returns {number|Object}\n         */\n        getValue: function getValue(columnName, summaryType) {\n          var valueMap = this.columnSummaryMap[columnName];\n          var value;\n\n          if (!summaryType) {\n            return _.isUndefined(valueMap) ? null : valueMap;\n          }\n\n          value = snippet.pick(valueMap, summaryType);\n          return _.isUndefined(value) ? null : value;\n        },\n\n        /**\n         * Returns the summary value of given column.\n         * If the column name is not specified, all values of available columns are returned.\n         * @param {string} [columnName] - column name\n         * @returns {Object}\n         */\n        getValues: function getValues(columnName) {\n          if (columnName) {\n            return $.extend({}, this.columnSummaryMap[columnName]);\n          }\n\n          return $.extend(true, {}, this.columnSummaryMap);\n        },\n\n        /**\n        * Returns whether given column is visible.\n        * @param {string} columnName - Parameter description.\n        * @returns {boolean}\n        * @private\n        */\n        _isVisibleColumn: function _isVisibleColumn(columnName) {\n          return this.columnModel.getVisibleColumns().indexOf(columnName) !== -1;\n        },\n\n        /**\n        * Return template function of given column name\n        * @param {string} columnName - column name\n        * @returns {function}\n        */\n        getTemplate: function getTemplate(columnName) {\n          var template = this.columnTemplateMap[columnName];\n\n          if (!template && this.defaultContent && this._isVisibleColumn(columnName)) {\n            template = this.defaultContent.template;\n          }\n\n          return template;\n        },\n\n        /**\n         * Set summary contents.\n         * (Just trigger 'setSummaryContent')\n         * @param {string} columnName - columnName\n         * @param {string|object} content - HTML string or Options Object\n         * @param {boolean} shouldChangeValue - If set to true, summary value is re-calculated\n         */\n        setColumnContent: function setColumnContent(columnName, content, shouldChangeValue) {\n          // eslint-disable-line complexity\n          if (_.isObject(content) && _.isFunction(content.template)) {\n            this.columnTemplateMap[columnName] = content.template;\n\n            if (content.useAutoSummary !== false) {\n              this.autoColumnNameSet[columnName] = true;\n            }\n          } else if (_.isString(content)) {\n            delete this.autoColumnNameSet[columnName];\n            this.columnTemplateMap[columnName] = content;\n          }\n\n          if (shouldChangeValue) {\n            this._changeColumnSummaryValue(columnName);\n          }\n        }\n      });\n      module.exports = Summary;\n      /***/\n    },\n    /* 32 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Clipboard Model\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var Model = __webpack_require__(9);\n      /**\n       * Clipboard Model\n       * @module model/clipboard\n       * @extends module:base/model\n       * @param {Object} attr - Attributes\n       * @param {Object} options - Options\n       * @ignore\n       */\n\n\n      var Clipboard = Model.extend(\n      /** @lends module:model/clipboard.prototype*/\n      {\n        initialize: function initialize(attr, options) {\n          Model.prototype.initialize.apply(this, arguments);\n\n          _.assign(this, {\n            columnModel: options.columnModel,\n            dataModel: options.dataModel,\n            selectionModel: options.selectionModel,\n            renderModel: options.renderModel,\n            focusModel: options.focusModel,\n            copyOptions: options.copyOptions,\n            domEventBus: options.domEventBus\n          });\n\n          this.listenTo(options.domEventBus, 'key:clipboard', this._onKeyClipboard);\n        },\n        defaults: {\n          /**\n           * String value to be stored in the system clipboard\n           * @type {String}\n           */\n          text: null\n        },\n\n        /**\n         * Set clipboard text to trigger event\n         */\n        setClipboardText: function setClipboardText() {\n          this.set('text', this._getClipboardText());\n        },\n\n        /**\n         * Paste the text from clipboard to Grid\n         * @param {array} data - clipboard data\n         */\n        pasteClipboardDataToGrid: function pasteClipboardDataToGrid(data) {\n          var selectionModel = this.selectionModel;\n          var focusModel = this.focusModel;\n          var dataModel = this.dataModel;\n          var selRange, selRowLen, selColLen;\n          var startIdx;\n\n          if (selectionModel.hasSelection()) {\n            selRange = selectionModel.get('range');\n            selRowLen = selRange.row[1] - selRange.row[0] + 1;\n            selColLen = selRange.column[1] - selRange.column[0] + 1;\n            data = this._duplicateData(data, selRowLen, selColLen);\n            startIdx = selectionModel.getStartIndex();\n          } else {\n            startIdx = focusModel.indexOf();\n          }\n\n          dataModel.paste(data, startIdx);\n        },\n\n        /**\n         * Event handler for key:clipboard event on the domEventBus\n         * @param {module:event/gridEvent} gridEvent - GridEvent\n         * @private\n         */\n        _onKeyClipboard: function _onKeyClipboard(gridEvent) {\n          var command = gridEvent.command;\n\n          if (command === 'copy') {\n            this.setClipboardText();\n          }\n        },\n\n        /**\n         * Duplicate given data based on the selection range\n         * @param {Array.<Array.<string>>} data - 2D array of string values\n         * @param {number} selRowLen - row length of selection range\n         * @param {number} selColLen - column length of selection range\n         * @returns {Array.<Array.<string>>}\n         * @private\n         */\n        _duplicateData: function _duplicateData(data, selRowLen, selColLen) {\n          var dataRowLen = data.length;\n          var dataColLen = data[0].length;\n          var rowDupCount = Math.floor(selRowLen / dataRowLen) - 1;\n          var colDupCount = Math.floor(selColLen / dataColLen) - 1;\n          var result = $.extend(true, [], data); // duplicate rows\n\n          _.times(rowDupCount, function () {\n            _.forEach(data, function (row) {\n              result.push(row.slice(0));\n            });\n          }); // duplicate columns\n\n\n          _.forEach(result, function (row) {\n            var rowData = row.slice(0);\n\n            _.times(colDupCount, function () {\n              [].push.apply(row, rowData);\n            });\n          });\n\n          return result;\n        },\n\n        /**\n         * Returns the text to be stored in the clipboard\n         * @returns {String}\n         * @private\n         */\n        _getClipboardText: function _getClipboardText() {\n          var selectionModel = this.selectionModel;\n          var focused = this.focusModel.which();\n          var text;\n\n          if (selectionModel.hasSelection()) {\n            text = selectionModel.getValuesToString();\n          } else {\n            text = selectionModel.getValueToString(focused.rowKey, focused.columnName);\n          }\n\n          return text;\n        }\n      });\n      module.exports = Clipboard;\n      /***/\n    },\n    /* 33 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview View factory\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var snippet = __webpack_require__(3);\n\n      var DatePicker = __webpack_require__(34);\n\n      var ContainerView = __webpack_require__(35);\n\n      var ContentAreaView = __webpack_require__(36);\n\n      var PaginationView = __webpack_require__(37);\n\n      var HeightResizeHandleView = __webpack_require__(39);\n\n      var StateLayerView = __webpack_require__(41);\n\n      var ClipboardView = __webpack_require__(43);\n\n      var LsideFrameView = __webpack_require__(45);\n\n      var RsideFrameView = __webpack_require__(47);\n\n      var HeaderView = __webpack_require__(48);\n\n      var HeaderResizeHandleView = __webpack_require__(49);\n\n      var BodyView = __webpack_require__(50);\n\n      var BodyTableView = __webpack_require__(51);\n\n      var SummaryView = __webpack_require__(52);\n\n      var RowListView = __webpack_require__(53);\n\n      var SelectionLayerView = __webpack_require__(54);\n\n      var EditingLayerView = __webpack_require__(55);\n\n      var DatePickeLayerView = __webpack_require__(56);\n\n      var FocusLayerView = __webpack_require__(57);\n\n      var isOptionEnabled = __webpack_require__(17).isOptionEnabled;\n\n      var frameConst = __webpack_require__(10).frame;\n      /**\n       * View Factory\n       * @module viewFactory\n       * @ignore\n       */\n\n\n      var ViewFactory = snippet.defineClass({\n        init: function init(options) {\n          // dependencies\n          this.domState = options.domState;\n          this.domEventBus = options.domEventBus;\n          this.modelManager = options.modelManager;\n          this.painterManager = options.painterManager;\n          this.componentHolder = options.componentHolder; // view options\n\n          this.summaryOptions = options.summary;\n          this.heightResizable = options.heightResizable;\n          this.usageStatistics = options.usageStatistics;\n        },\n\n        /**\n         * Creates container view and returns it.\n         * @param {Object} options - Options set by user\n         * @returns {module:view/container}\n         */\n        createContainer: function createContainer() {\n          return new ContainerView({\n            el: this.domState.$el,\n            gridId: this.modelManager.gridId,\n            domEventBus: this.domEventBus,\n            dataModel: this.modelManager.dataModel,\n            dimensionModel: this.modelManager.dimensionModel,\n            viewFactory: this\n          });\n        },\n\n        /**\n         * Creates a view instance for the contents area.\n         * @returns {module:view/layout/content-area}\n         */\n        createContentArea: function createContentArea() {\n          return new ContentAreaView({\n            dimensionModel: this.modelManager.dimensionModel,\n            viewFactory: this\n          });\n        },\n\n        /**\n         * Creates pagination view and returns it.\n         * @returns {module:view/pagination} - New pagination view instance\n         */\n        createPagination: function createPagination() {\n          if (!isOptionEnabled(this.componentHolder.getOptions('pagination'))) {\n            return null;\n          }\n\n          return new PaginationView({\n            componentHolder: this.componentHolder,\n            dimensionModel: this.modelManager.dimensionModel,\n            focusModel: this.modelManager.focusModel,\n            usageStatistics: this.usageStatistics\n          });\n        },\n\n        /**\n         * Creates height resize handle view and returns it.\n         * @returns {module:view/resizeHandle} - New resize hander view instance\n         */\n        createHeightResizeHandle: function createHeightResizeHandle() {\n          if (!isOptionEnabled(this.heightResizable)) {\n            return null;\n          }\n\n          return new HeightResizeHandleView({\n            dimensionModel: this.modelManager.dimensionModel,\n            domEventBus: this.domEventBus\n          });\n        },\n\n        /**\n         * Creates state layer view and returns it.\n         * @returns {module:view/stateLayer} - New state layer view instance\n         */\n        createStateLayer: function createStateLayer() {\n          return new StateLayerView({\n            dimensionModel: this.modelManager.dimensionModel,\n            renderModel: this.modelManager.renderModel\n          });\n        },\n\n        /**\n         * Creates clipboard view and returns it.\n         * @returns {module:view/clipboard} - New clipboard view instance\n         */\n        createClipboard: function createClipboard() {\n          return new ClipboardView({\n            clipboardModel: this.modelManager.clipboardModel,\n            focusModel: this.modelManager.focusModel,\n            domEventBus: this.domEventBus\n          });\n        },\n\n        /**\n         * Creates frame view and returns it.\n         * @param  {String} whichSide - L(left) or R(right)\n         * @returns {module:view/layout/frame} New frame view instance\n         */\n        createFrame: function createFrame(whichSide) {\n          var Constructor = whichSide === frameConst.L ? LsideFrameView : RsideFrameView;\n          return new Constructor({\n            dimensionModel: this.modelManager.dimensionModel,\n            renderModel: this.modelManager.renderModel,\n            viewFactory: this\n          });\n        },\n\n        /**\n         * Creates header view and returns it.\n         * @param  {String} whichSide - 'L'(left) or 'R'(right)\n         * @returns {module:view/layout/header} New header view instance\n         */\n        createHeader: function createHeader(whichSide) {\n          return new HeaderView({\n            whichSide: whichSide,\n            renderModel: this.modelManager.renderModel,\n            focusModel: this.modelManager.focusModel,\n            selectionModel: this.modelManager.selectionModel,\n            dataModel: this.modelManager.dataModel,\n            columnModel: this.modelManager.columnModel,\n            coordRowModel: this.modelManager.coordRowModel,\n            coordColumnModel: this.modelManager.coordColumnModel,\n            dimensionModel: this.modelManager.dimensionModel,\n            domEventBus: this.domEventBus,\n            viewFactory: this\n          });\n        },\n\n        /**\n         * Creates summary view and returns it.\n         * @param {string} whichSide - 'L'(left) or 'R'(right)\n         * @returns {object}\n         */\n        createSummary: function createSummary(whichSide) {\n          if (!this.summaryOptions) {\n            return null;\n          }\n\n          return new SummaryView({\n            whichSide: whichSide,\n            columnModel: this.modelManager.columnModel,\n            renderModel: this.modelManager.renderModel,\n            dimensionModel: this.modelManager.dimensionModel,\n            coordColumnModel: this.modelManager.coordColumnModel,\n            summaryModel: this.modelManager.summaryModel\n          });\n        },\n\n        /**\n         * Creates resize handler of header view and returns it.\n         * @param {string} whichSide - 'L'(left) or 'R'(right)\n         * @param {array} handleHeights - Height values of each resize handle\n         * @param {boolean} frozenBorder - Whether the resize handle is matching the frozen border or not\n         * @returns {module:view/layout/header} New resize handler view instance\n         */\n        createHeaderResizeHandle: function createHeaderResizeHandle(whichSide, handleHeights, frozenBorder) {\n          return new HeaderResizeHandleView({\n            whichSide: whichSide,\n            handleHeights: handleHeights,\n            frozenBorder: frozenBorder,\n            columnModel: this.modelManager.columnModel,\n            dimensionModel: this.modelManager.dimensionModel,\n            coordColumnModel: this.modelManager.coordColumnModel,\n            domEventBus: this.domEventBus\n          });\n        },\n\n        /**\n         * Creates body view and returns it.\n         * @param  {String} whichSide - 'L'(left) or 'R'(right)\n         * @returns {module:view/layout/body} New body view instance\n         */\n        createBody: function createBody(whichSide) {\n          return new BodyView({\n            whichSide: whichSide,\n            renderModel: this.modelManager.renderModel,\n            dimensionModel: this.modelManager.dimensionModel,\n            domEventBus: this.domEventBus,\n            viewFactory: this\n          });\n        },\n\n        /**\n         * Creates body-table view and returns it.\n         * @param  {String} whichSide - 'L'(left) or 'R'(right)\n         * @returns {module:view/layout/bodyTable} New body-table view instance\n         */\n        createBodyTable: function createBodyTable(whichSide) {\n          return new BodyTableView({\n            whichSide: whichSide,\n            dimensionModel: this.modelManager.dimensionModel,\n            coordColumnModel: this.modelManager.coordColumnModel,\n            renderModel: this.modelManager.renderModel,\n            columnModel: this.modelManager.columnModel,\n            painterManager: this.painterManager,\n            viewFactory: this\n          });\n        },\n\n        /**\n         * Creates row list view and returns it.\n         * @param  {Object} options - Options\n         * @param  {jQuery} options.el - jquery object wrapping tbody html element\n         * @param  {String} options.whichSide - 'L'(left) or 'R'(right)\n         * @param  {module:view/layout/bodyTable} options.bodyTableView - body table view\n         * @returns {module:view/rowList} New row list view instance\n         */\n        createRowList: function createRowList(options) {\n          return new RowListView({\n            el: options.el,\n            whichSide: options.whichSide,\n            bodyTableView: options.bodyTableView,\n            dataModel: this.modelManager.dataModel,\n            columnModel: this.modelManager.columnModel,\n            dimensionModel: this.modelManager.dimensionModel,\n            selectionModel: this.modelManager.selectionModel,\n            renderModel: this.modelManager.renderModel,\n            focusModel: this.modelManager.focusModel,\n            coordRowModel: this.modelManager.coordRowModel,\n            painterManager: this.painterManager\n          });\n        },\n\n        /**\n         * Creates selection view and returns it.\n         * @param  {String} whichSide - 'L'(left) or 'R'(right)\n         * @returns {module:view/selectionLayer} New selection layer view instance\n         */\n        createSelectionLayer: function createSelectionLayer(whichSide) {\n          return new SelectionLayerView({\n            whichSide: whichSide,\n            selectionModel: this.modelManager.selectionModel,\n            dimensionModel: this.modelManager.dimensionModel,\n            columnModel: this.modelManager.columnModel,\n            coordRowModel: this.modelManager.coordRowModel,\n            coordColumnModel: this.modelManager.coordColumnModel\n          });\n        },\n\n        /**\n         * Creates editing layer view and returns it.\n         * @returns {module:view/editingLayer}\n         */\n        createEditingLayer: function createEditingLayer() {\n          return new EditingLayerView({\n            renderModel: this.modelManager.renderModel,\n            inputPainters: this.painterManager.getInputPainters(true),\n            domState: this.domState\n          });\n        },\n\n        /**\n         * Creates an instance of date-picker layer view.\n         * @returns {module:view/datePickerLayer}\n         */\n        createDatePickerLayer: function createDatePickerLayer() {\n          if (!DatePicker) {\n            return null;\n          }\n\n          return new DatePickeLayerView({\n            focusModel: this.modelManager.focusModel,\n            columnModel: this.modelManager.columnModel,\n            textPainter: this.painterManager.getInputPainters().text,\n            domState: this.domState,\n            domEventBus: this.domEventBus,\n            usageStatistics: this.usageStatistics\n          });\n        },\n\n        /**\n         * Creates focus layer view and returns it.\n         * @param  {String} whichSide - 'L'(left) or 'R'(right)\n         * @returns {module:view/focusLayer} New focus layer view instance\n         */\n        createFocusLayer: function createFocusLayer(whichSide) {\n          return new FocusLayerView({\n            whichSide: whichSide,\n            dimensionModel: this.modelManager.dimensionModel,\n            columnModel: this.modelManager.columnModel,\n            focusModel: this.modelManager.focusModel,\n            coordRowModel: this.modelManager.coordRowModel,\n            coordColumnModel: this.modelManager.coordColumnModel,\n            coordConverterModel: this.modelManager.coordConverterModel\n          });\n        }\n      });\n      module.exports = ViewFactory;\n      /***/\n    },\n    /* 34 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_34__;\n      /***/\n    },\n    /* 35 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview View class that conaints a top element of the DOM structure of the grid.\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var View = __webpack_require__(4);\n\n      var GridEvent = __webpack_require__(16);\n\n      var targetTypeConst = GridEvent.targetTypeConst;\n\n      var attrNameConst = __webpack_require__(10).attrName;\n\n      var classNameConst = __webpack_require__(19);\n      /**\n       * Container View\n       * @module view/container\n       * @extends module:base/view\n       * @param {Object} options - Options\n       * @ignore\n       */\n\n\n      var Container = View.extend(\n      /** @lends module:view/container.prototype */\n      {\n        initialize: function initialize(options) {\n          View.prototype.initialize.call(this);\n          this.gridId = options.gridId;\n          this.dimensionModel = options.dimensionModel;\n          this.dataModel = options.dataModel;\n          this.viewFactory = options.viewFactory;\n          this.domEventBus = options.domEventBus;\n\n          this._createChildViews();\n\n          this.listenTo(this.dimensionModel, 'setWidth', this._onSetWidth);\n          $(window).on('resize.grid', $.proxy(this._onResizeWindow, this));\n          this.__$el = this.$el.clone();\n        },\n        events: {\n          'click': '_onClick',\n          'dblclick': '_onDblClick',\n          'mousedown': '_onMouseDown',\n          'mouseover': '_onMouseOver',\n          'mouseout': '_onMouseOut',\n          // for preventing drag\n          'selectstart': '_preventDrag',\n          'dragstart': '_preventDrag'\n        },\n\n        /**\n         * 내부에서 사용할 view 인스턴스들을 초기화한다.\n         * @private\n         */\n        _createChildViews: function _createChildViews() {\n          var factory = this.viewFactory;\n\n          this._addChildren([factory.createContentArea(), factory.createHeightResizeHandle(), factory.createPagination(), factory.createStateLayer(), factory.createEditingLayer(), factory.createDatePickerLayer(), factory.createClipboard()]);\n        },\n\n        /**\n         * Event handler for resize event on window.\n         * @private\n         */\n        _onResizeWindow: function _onResizeWindow() {\n          this.domEventBus.trigger('windowResize');\n        },\n\n        /**\n         * drag 이벤트 발생시 이벤트 핸들러\n         * @returns {boolean} false\n         * @private\n         */\n        _preventDrag: function _preventDrag() {\n          return false;\n        },\n\n        /**\n         * Event handler for 'setWidth' event on Dimension\n         * @private\n         */\n        _onSetWidth: function _onSetWidth() {\n          this.$el.width(this.dimensionModel.get('width'));\n        },\n\n        /**\n         * Event handler for click event\n         * The reason for using 'elementFromPoint' is because of the selection.\n         * @param {MouseEvent} ev - Mouse event\n         * @private\n         */\n        _onClick: function _onClick(ev) {\n          var pointX = ev.pageX - window.pageXOffset;\n          var pointY = ev.pageY - window.pageYOffset;\n          var $target = $(document.elementFromPoint(pointX, pointY));\n          var gridEvent = new GridEvent(ev, GridEvent.getTargetInfo($target));\n          /**\n           * Occurs when a mouse button is clicked on the Grid.\n           * The properties of the event object include the native event object.\n           * @event Grid#click\n           * @type {module:event/gridEvent}\n           * @property {jQueryEvent} nativeEvent - Event object\n           * @property {string} targetType - Type of event target\n           * @property {number} rowKey - rowKey of the target cell\n           * @property {string} columnName - columnName of the target cell\n           * @property {Grid} instance - Current grid instance\n           */\n\n          this.domEventBus.trigger('click', gridEvent);\n\n          if (!gridEvent.isStopped() && gridEvent.targetType === targetTypeConst.CELL) {\n            this.domEventBus.trigger('click:cell', gridEvent);\n          }\n        },\n\n        /**\n         * Event handler for the dblclick event\n         * @param {MouseEvent} ev - MouseEvent\n         * @private\n         */\n        _onDblClick: function _onDblClick(ev) {\n          var $target = $(ev.target);\n          var gridEvent = new GridEvent(ev, GridEvent.getTargetInfo($target));\n          /**\n           * Occurs when a mouse button is double clicked on the Grid.\n           * The properties of the event object include the native event object.\n           * @event Grid#dblclick\n           * @type {module:event/gridEvent}\n           * @property {jQueryEvent} nativeEvent - Event object\n           * @property {string} targetType - Type of event target\n           * @property {number} rowKey - rowKey of the target cell\n           * @property {string} columnName - columnName of the target cell\n           * @property {Grid} instance - Current grid instance\n           */\n\n          this.domEventBus.trigger('dblclick', gridEvent);\n\n          if (!gridEvent.isStopped() && gridEvent.targetType === targetTypeConst.CELL) {\n            this.domEventBus.trigger('dblclick:cell', gridEvent);\n          }\n        },\n\n        /**\n         * Event listener for the mouseover event\n         * @param {MouseEvent} ev - MouseEvent\n         * @private\n         */\n        _onMouseOver: function _onMouseOver(ev) {\n          var $target = $(ev.target);\n          var gridEvent = new GridEvent(ev, GridEvent.getTargetInfo($target));\n          /**\n           * Occurs when a mouse pointer is moved onto the Grid.\n           * The properties of the event object include the native MouseEvent object.\n           * @event Grid#mouseover\n           * @type {module:event/gridEvent}\n           * @property {jQueryEvent} nativeEvent - Event object\n           * @property {string} targetType - Type of event target\n           * @property {number} rowKey - rowKey of the target cell\n           * @property {string} columnName - columnName of the target cell\n           * @property {Grid} instance - Current grid instance\n           */\n\n          this.domEventBus.trigger('mouseover', gridEvent);\n        },\n\n        /**\n         * Event listener for the mouseout event\n         * @param {MouseEvent} ev - MouseEvent\n         * @private\n         */\n        _onMouseOut: function _onMouseOut(ev) {\n          var $target = $(ev.target);\n          var gridEvent = new GridEvent(ev, GridEvent.getTargetInfo($target));\n          /**\n           * Occurs when a mouse pointer is moved off from the Grid.\n           * The event object has all properties copied from the native MouseEvent.\n           * @event Grid#mouseout\n           * @type {module:event/gridEvent}\n           * @property {jQueryEvent} nativeEvent - Event object\n           * @property {string} targetType - Type of event target\n           * @property {number} rowKey - rowKey of the target cell\n           * @property {string} columnName - columnName of the target cell\n           * @property {Grid} instance - Current grid instance\n           */\n\n          this.domEventBus.trigger('mouseout', gridEvent);\n        },\n\n        /**\n         * Event handler for 'mousedown' event\n         * @param {MouseEvent} ev - Mouse event\n         * @private\n         */\n        _onMouseDown: function _onMouseDown(ev) {\n          var $target = $(ev.target);\n          var gridEvent = new GridEvent(ev, GridEvent.getTargetInfo($target));\n          var shouldFocus = !$target.is('input, a, button, select, textarea');\n          var mainButton = gridEvent.columnName === '_button' && $target.parent().is('label');\n\n          if (shouldFocus && !mainButton) {\n            ev.preventDefault(); // fix IE8 bug (cancelling event doesn't prevent focused element from losing foucs)\n\n            $target[0].unselectable = true;\n            /**\n             * Occurs when a mouse button is downed on the Grid.\n             * The event object has all properties copied from the native MouseEvent.\n             * @event Grid#mousedown\n             * @type {module:event/gridEvent}\n             * @property {jQueryEvent} nativeEvent - Event object\n             * @property {string} targetType - Type of event target\n             * @property {number} rowKey - rowKey of the target cell\n             * @property {string} columnName - columnName of the target cell\n             * @property {Grid} instance - Current grid instance\n             */\n\n            this.domEventBus.trigger('mousedown:focus', gridEvent);\n          }\n        },\n\n        /**\n         * Render\n         * @returns {module:view/container} this object\n         */\n        render: function render() {\n          var childElements = this._renderChildren();\n\n          this.$el.addClass(classNameConst.CONTAINER).attr(attrNameConst.GRID_ID, this.gridId).append(childElements);\n\n          this._triggerChildrenAppended();\n\n          return this;\n        },\n\n        /**\n         * Destroy\n         */\n        destroy: function destroy() {\n          this.stopListening();\n          $(window).off('resize.grid');\n\n          this._destroyChildren();\n\n          this.$el.replaceWith(this.__$el);\n          this.$el = this.__$el = null;\n        }\n      });\n      module.exports = Container;\n      /***/\n    },\n    /* 36 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Class for the content area\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var View = __webpack_require__(4);\n\n      var classNameConst = __webpack_require__(19);\n\n      var constMap = __webpack_require__(10);\n\n      var frameConst = constMap.frame;\n      var ContentArea;\n      /**\n       * Create DIV element to draw border\n       * @param {String} className - border class name\n       * @returns {jQuery}\n       * @ignore\n       */\n\n      function borderDIV(className) {\n        return $('<div>').addClass(classNameConst.BORDER_LINE).addClass(className);\n      }\n      /**\n       * Content area\n       * @module view/layout/content-area\n       * @extends module:base/view\n       * @param {Object} options - Options\n       * @ignore\n       */\n\n\n      ContentArea = View.extend(\n      /** @lends module:view/layout/content-area.prototype */\n      {\n        initialize: function initialize(options) {\n          View.prototype.initialize.call(this);\n          this.viewFactory = options.viewFactory;\n          this.dimensionModel = options.dimensionModel;\n\n          this._addFrameViews();\n        },\n        className: classNameConst.CONTENT_AREA,\n\n        /**\n         * Creates Frame views and add them as children.\n         * @private\n         */\n        _addFrameViews: function _addFrameViews() {\n          var factory = this.viewFactory;\n\n          this._addChildren([factory.createFrame(frameConst.L), factory.createFrame(frameConst.R)]);\n        },\n\n        /**\n         * Renders\n         * @returns {Object} this object\n         */\n        render: function render() {\n          var dimensionModel = this.dimensionModel;\n          var scrollXHeight = dimensionModel.getScrollXHeight();\n\n          var childElements = this._renderChildren().concat([borderDIV(classNameConst.BORDER_TOP), borderDIV(classNameConst.BORDER_LEFT), borderDIV(classNameConst.BORDER_RIGHT), borderDIV(classNameConst.BORDER_BOTTOM).css('bottom', scrollXHeight)]);\n\n          var classNames = [];\n\n          if (!dimensionModel.get('scrollX')) {\n            classNames.push(classNameConst.NO_SCROLL_X);\n          }\n\n          if (!dimensionModel.get('scrollY')) {\n            classNames.push(classNameConst.NO_SCROLL_Y);\n          }\n\n          if (dimensionModel.get('summaryHeight')) {\n            if (dimensionModel.get('summaryPosition') === constMap.summaryPosition.TOP) {\n              classNames.push(classNameConst.HAS_SUMMARY_TOP);\n            } else {\n              classNames.push(classNameConst.HAS_SUMMARY_BOTTOM);\n            }\n          }\n\n          if (dimensionModel.get('rsideWidth')) {\n            classNames.push(classNameConst.SHOW_LSIDE_AREA);\n          }\n\n          this.$el.addClass(classNames.join(' '));\n          this.$el.append(childElements);\n          return this;\n        }\n      });\n      module.exports = ContentArea;\n      /***/\n    },\n    /* 37 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Class for the pagination\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var TuiPaginaton = __webpack_require__(38);\n\n      var View = __webpack_require__(4);\n\n      var classNameConst = __webpack_require__(19);\n\n      var defaultOptions = {\n        totalItems: 1,\n        itemsPerPage: 10,\n        visiblePages: 5,\n        centerAlign: true\n      };\n      var PAGINATION_CLASSNAME = 'tui-pagination ' + classNameConst.PAGINATION;\n      /**\n       * Class for the pagination\n       * @module view/pagination\n       * @extends module:base/view\n       * @param {Object} options - Options\n       * @ignore\n       */\n\n      var Pagination = View.extend(\n      /** @lends module:view/pagination.prototype */\n      {\n        initialize: function initialize(options) {\n          this.dimensionModel = options.dimensionModel;\n          this.componentHolder = options.componentHolder;\n          this.usageStatistics = options.usageStatistics;\n\n          this._stopEventPropagation();\n\n          this.on('appended', this._onAppended);\n        },\n        className: PAGINATION_CLASSNAME,\n\n        /**\n         * Render\n         * @returns {Object} this object\n         */\n        render: function render() {\n          this._destroyChildren();\n\n          this.componentHolder.setInstance('pagination', this._createComponent());\n          return this;\n        },\n\n        /**\n         * Stop propagation of mouse down event\n         * @private\n         */\n        _stopEventPropagation: function _stopEventPropagation() {\n          this.$el.mousedown(function (ev) {\n            ev.stopPropagation();\n          });\n        },\n\n        /**\n         * Event handler for 'appended' event\n         * @private\n         */\n        _onAppended: function _onAppended() {\n          this.dimensionModel.set('paginationHeight', this.$el.outerHeight());\n        },\n\n        /**\n         * Create an option object for creating a tui.Pagination component.\n         * @returns {Object}\n         */\n        _createOptionObject: function _createOptionObject() {\n          var customOptions = this.componentHolder.getOptions('pagination');\n\n          if (customOptions === true) {\n            customOptions = {};\n          }\n\n          return _.assign({\n            usageStatistics: this.usageStatistics\n          }, defaultOptions, customOptions);\n        },\n\n        /**\n         * Create new tui.Pagination instance\n         * @returns {tui.Pagination}\n         * @private\n         */\n        _createComponent: function _createComponent() {\n          var ComponentClass = TuiPaginaton;\n\n          if (!ComponentClass) {\n            throw new Error('Cannot find component \\'tui.Pagination\\'');\n          }\n\n          return new ComponentClass(this.$el, this._createOptionObject());\n        }\n      });\n      module.exports = Pagination;\n      /***/\n    },\n    /* 38 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_38__;\n      /***/\n    },\n    /* 39 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Class for the height resize handle\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var View = __webpack_require__(4);\n\n      var classNameConst = __webpack_require__(19);\n\n      var DragEventEmitter = __webpack_require__(40);\n      /**\n       * Class for the height resize handle\n       * @module view/layout/heightResizeHandle\n       * @extends module:base/view\n       * @param {Object} options - Options\n       * @ignore\n       */\n\n\n      var HeightResizeHandle = View.extend(\n      /** @lends module:view/layout/heightResizeHandle.prototype */\n      {\n        initialize: function initialize(options) {\n          this.dimensionModel = options.dimensionModel;\n          this.domEventBus = options.domEventBus;\n          this.dragEmitter = new DragEventEmitter({\n            type: 'resizeHeight',\n            cursor: 'row-resize',\n            domEventBus: this.domEventBus\n          });\n          this.on('appended', this._onAppended);\n        },\n        className: classNameConst.HEIGHT_RESIZE_HANDLE,\n        events: {\n          'mousedown': '_onMouseDown'\n        },\n\n        /**\n         * Event handler for 'appended' event\n         * @private\n         */\n        _onAppended: function _onAppended() {\n          this.dimensionModel.set('resizeHandleHeight', this.$el.outerHeight());\n        },\n\n        /**\n         * Event handler for 'mousedown' event\n         * @param {MouseEvent} ev - MouseEvent object\n         * @private\n         */\n        _onMouseDown: function _onMouseDown(ev) {\n          ev.preventDefault();\n          this.dragEmitter.start(ev, {\n            mouseOffsetY: ev.offsetY\n          });\n        },\n\n        /**\n         * Render\n         * @returns {Object} this object\n         */\n        render: function render() {\n          this.$el.html('<button><span></span></button>');\n          return this;\n        }\n      });\n      module.exports = HeightResizeHandle;\n      /***/\n    },\n    /* 40 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Drag event emitter\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var GridEvent = __webpack_require__(16);\n      /* Drag event emitter\n       * @module event/dragEventEmitter\n       * @ignore\n       */\n\n\n      var DragEventEmitter = snippet.defineClass(\n      /** @lends module:event/dragEventEmitter.prototype */\n      {\n        init: function init(options) {\n          _.assign(this, {\n            type: options.type,\n            domEventBus: options.domEventBus,\n            onDragMove: options.onDragMove,\n            onDragEnd: options.onDragEnd,\n            cursor: options.cursor,\n            startData: null\n          });\n        },\n\n        /**\n         * Starts drag\n         * @param {MouseEvent} ev - MouseEvent\n         * @param {Object} data - start data (to be used in dragmove, dragend event)\n         */\n        start: function start(ev, data) {\n          var gridEvent = new GridEvent(ev, data);\n          this.domEventBus.trigger('dragstart:' + this.type, gridEvent);\n\n          if (!gridEvent.isStopped()) {\n            this._startDrag(ev.target, data);\n          }\n        },\n\n        /**\n         * Starts drag\n         * @param {HTMLElement} target - drag target\n         * @param {Object} data - start data\n         * @private\n         */\n        _startDrag: function _startDrag(target, data) {\n          this.startData = data;\n\n          this._attachDragEvents();\n\n          if (this.cursor) {\n            $('body').css('cursor', this.cursor);\n          } // for IE8 and under\n\n\n          if (target.setCapture) {\n            target.setCapture();\n          }\n        },\n\n        /**\n         * Ends drag\n         * @private\n         */\n        _endDrag: function _endDrag() {\n          this.startData = null;\n\n          this._detachDragEvents();\n\n          if (this.cursor) {\n            $('body').css('cursor', 'default');\n          } // for IE8 and under\n\n\n          if (document.releaseCapture) {\n            document.releaseCapture();\n          }\n        },\n\n        /**\n         * Event handler for 'mousemove' event on document\n         * @param {MouseEvent} ev - MouseEvent\n         * @private\n         */\n        _onMouseMove: function _onMouseMove(ev) {\n          var gridEvent; // Prevent 'dragmove' from occuring when mouse button is not pressed.\n          // This can happen when the alert dialog pops up from the the 'blur/mousedown' event handler.\n\n          if (!ev.buttons) {\n            this._endDrag();\n\n            return;\n          }\n\n          gridEvent = new GridEvent(ev, {\n            startData: this.startData,\n            pageX: ev.pageX,\n            pageY: ev.pageY\n          });\n\n          if (_.isFunction(this.onDragMove)) {\n            this.onDragMove(gridEvent);\n          }\n\n          if (!gridEvent.isStopped()) {\n            this.domEventBus.trigger('dragmove:' + this.type, gridEvent);\n          }\n        },\n\n        /**\n         * Event handler for 'mouseup' event on document\n         * @param {MouseEvent} ev - MouseEvent\n         * @private\n         */\n        _onMouseUp: function _onMouseUp(ev) {\n          var gridEvent = new GridEvent(ev, {\n            startData: this.startData\n          });\n\n          if (_.isFunction(this.onDragEnd)) {\n            this.onDragEnd(gridEvent);\n          }\n\n          if (!gridEvent.isStopped()) {\n            this.domEventBus.trigger('dragend:' + this.type, gridEvent);\n\n            this._endDrag();\n          }\n        },\n\n        /**\n         * Event handler for 'selectstart' event on document\n         * @param {MouseEvent} ev - MouseEvent\n         * @private\n         */\n        _onSelectStart: function _onSelectStart(ev) {\n          ev.preventDefault();\n        },\n\n        /**\n         * Attach mouse event handlers for drag to document\n         * @private\n         */\n        _attachDragEvents: function _attachDragEvents() {\n          $(document).on('mousemove.grid', _.bind(this._onMouseMove, this)).on('mouseup.grid', _.bind(this._onMouseUp, this)).on('selectstart.grid', _.bind(this._onSelectStart, this));\n        },\n\n        /**\n         * Detach mouse event handlers drag from document\n         * @private\n         */\n        _detachDragEvents: function _detachDragEvents() {\n          $(document).off('.grid');\n        }\n      });\n      module.exports = DragEventEmitter;\n      /***/\n    },\n    /* 41 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Layer class that represents the state of rendering phase\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var View = __webpack_require__(4);\n\n      var stateConst = __webpack_require__(10).renderState;\n\n      var classNameConst = __webpack_require__(19);\n\n      var i18n = __webpack_require__(42);\n\n      var TABLE_BORDER_WIDTH = __webpack_require__(10).dimension.TABLE_BORDER_WIDTH;\n      /**\n       * Layer class that represents the state of rendering phase.\n       * @module view/stateLayer\n       * @extends module:base/view\n       * @param {Object} options - Options\n       * @ignore\n       */\n\n\n      var StateLayer = View.extend(\n      /** @lends module:view/stateLayer.prototype */\n      {\n        initialize: function initialize(options) {\n          this.dimensionModel = options.dimensionModel;\n          this.renderModel = options.renderModel;\n          this.listenTo(this.dimensionModel, 'change', this._refreshLayout);\n          this.listenTo(this.renderModel, 'change:state', this.render);\n        },\n        className: classNameConst.LAYER_STATE,\n        template: _.template('<div class=\"' + classNameConst.LAYER_STATE_CONTENT + '\">' + '    <p><%= text %></p>' + '    <% if (isLoading) { %>' + '    <div class=\"' + classNameConst.LAYER_STATE_LOADING + '\"></div>' + '    <% } %>' + '</div>'),\n\n        /**\n         * Render\n         * @returns {object} This object\n         */\n        render: function render() {\n          var renderState = this.renderModel.get('state');\n\n          if (renderState === stateConst.DONE) {\n            this.$el.hide();\n          } else {\n            this._showLayer(renderState);\n          }\n\n          return this;\n        },\n\n        /**\n         * Shows the state layer.\n         * @param {string} renderState - Render state {@link module:common/constMap#renderState}\n         * @private\n         */\n        _showLayer: function _showLayer(renderState) {\n          var layerHtml = this.template({\n            text: this._getMessage(renderState),\n            isLoading: renderState === stateConst.LOADING\n          });\n          this.$el.html(layerHtml).show();\n\n          this._refreshLayout();\n        },\n\n        /**\n         * Returns the message based on the renderState value\n         * @param  {string} renderState - Renderer.state value\n         * @returns {string} - Message\n         */\n        _getMessage: function _getMessage(renderState) {\n          switch (renderState) {\n            case stateConst.LOADING:\n              return i18n.get('display.loadingData');\n\n            case stateConst.EMPTY:\n              return i18n.get('display.noData');\n\n            default:\n              return null;\n          }\n        },\n\n        /**\n         * Sets the marginTop and height value.\n         * @private\n         */\n        _refreshLayout: function _refreshLayout() {\n          var dimensionModel = this.dimensionModel;\n          var headerHeight = dimensionModel.get('headerHeight');\n          var bodyHeight = dimensionModel.get('bodyHeight');\n          var scrollXHeight = dimensionModel.getScrollXHeight();\n          var scrollYWidth = dimensionModel.getScrollYWidth();\n          this.$el.css({\n            top: headerHeight,\n            height: bodyHeight - scrollXHeight - TABLE_BORDER_WIDTH,\n            left: 0,\n            right: scrollYWidth\n          });\n        }\n      });\n      module.exports = StateLayer;\n      /***/\n    },\n    /* 42 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview i18n module file\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var util = __webpack_require__(17);\n\n      var messages = {\n        en: {\n          display: {\n            noData: 'No data.',\n            loadingData: 'Loading data.',\n            resizeHandleGuide: 'You can change the width of the column by mouse drag, ' + 'and initialize the width by double-clicking.'\n          },\n          net: {\n            confirmCreate: 'Are you sure you want to create {{count}} data?',\n            confirmUpdate: 'Are you sure you want to update {{count}} data?',\n            confirmDelete: 'Are you sure you want to delete {{count}} data?',\n            confirmModify: 'Are you sure you want to modify {{count}} data?',\n            noDataToCreate: 'No data to create.',\n            noDataToUpdate: 'No data to update.',\n            noDataToDelete: 'No data to delete.',\n            noDataToModify: 'No data to modify.',\n            failResponse: 'An error occurred while requesting data.\\nPlease try again.'\n          }\n        },\n        ko: {\n          display: {\n            noData: '데이터가 존재하지 않습니다.',\n            loadingData: '데이터를 불러오는 중입니다.',\n            resizeHandleGuide: '마우스 드래그하여 컬럼 너비를 조정할 수 있고, ' + '더블 클릭으로 컬럼 너비를 초기화할 수 있습니다.'\n          },\n          net: {\n            confirmCreate: '{{count}}건의 데이터를 생성하겠습니까?',\n            confirmUpdate: '{{count}}건의 데이터를 수정하겠습니까?',\n            confirmDelete: '{{count}}건의 데이터를 삭제하겠습니까?',\n            confirmModify: '{{count}}건의 데이터를 처리하겠습니까?',\n            noDataToCreate: '생성할 데이터가 없습니다.',\n            noDataToUpdate: '수정할 데이터가 없습니다.',\n            noDataToDelete: '삭제할 데이터가 없습니다.',\n            noDataToModify: '처리할 데이터가 없습니다.',\n            failResponse: '데이터 요청 중에 에러가 발생하였습니다.\\n다시 시도하여 주시기 바랍니다.'\n          }\n        }\n      };\n      var messageMap = {};\n      /**\n       * Flatten message map\n       * @param {object} data - Messages\n       * @returns {object} Flatten message object (key foramt is 'key.subKey')\n       * @ignore\n       */\n\n      function flattenMessageMap(data) {\n        var obj = {};\n        var newKey;\n\n        _.each(data, function (groupMessages, key) {\n          _.each(groupMessages, function (message, subKey) {\n            newKey = [key, subKey].join('.');\n            obj[newKey] = message;\n          });\n        }, this);\n\n        return obj;\n      }\n\n      module.exports = {\n        /**\n         * Set messages\n         * @param {string} localeCode - Code to set locale messages and\n         *     this is the language or language-region combination. (ex: en-US)\n         * @param {object} [data] - Messages using in Grid\n         */\n        setLanguage: function setLanguage(localeCode, data) {\n          var localeMessages = messages[localeCode];\n          var originData, newData;\n\n          if (!localeMessages && !data) {\n            throw new Error('You should set messages to map the locale code.');\n          }\n\n          newData = flattenMessageMap(data);\n\n          if (localeMessages) {\n            originData = flattenMessageMap(localeMessages);\n            messageMap = _.extend(originData, newData);\n          } else {\n            messageMap = newData;\n          }\n        },\n\n        /**\n         * Get message\n         * @param {string} key - Key to find message (ex: 'net.confirmCreate')\n         * @param {object} [replacements] - Values to replace string\n         * @returns {string} Message\n         */\n        get: function get(key, replacements) {\n          var message = messageMap[key];\n\n          if (replacements) {\n            message = util.replaceText(message, replacements);\n          }\n\n          return message;\n        }\n      };\n      /***/\n    },\n    /* 43 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Hidden Textarea View for handling key navigation events and emulating clipboard actions\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var View = __webpack_require__(4);\n\n      var clipboardUtil = __webpack_require__(18);\n\n      var keyEvent = __webpack_require__(44);\n\n      var classNameConst = __webpack_require__(19);\n\n      var KEYDOWN_LOCK_TIME = 10;\n      var Clipboard;\n      var isEdge = snippet.browser.edge;\n      var supportWindowClipboardData = !!window.clipboardData;\n      /**\n       * Returns whether the ev.preventDefault should be called\n       * @param {module:event/gridEvent} gridEvent - GridEvent\n       * @returns {boolean}\n       * @ignore\n       */\n\n      function shouldPreventDefault(gridEvent) {\n        return gridEvent.type !== 'key:clipboard';\n      }\n      /**\n       * Returns whether given GrivEvent instance is paste event\n       * @param {module:event/gridEvent} gridEvent - GridEvent\n       * @returns {boolean}\n       * @ignore\n       */\n\n\n      function isPasteEvent(gridEvent) {\n        return gridEvent.type === 'key:clipboard' && gridEvent.command === 'paste';\n      }\n      /**\n       * Clipboard view class\n       * @module view/clipboard\n       * @extends module:base/view\n       * @param {Object} options - Options\n       * @ignore\n       */\n\n\n      Clipboard = View.extend(\n      /** @lends module:view/clipboard.prototype */\n      {\n        initialize: function initialize(options) {\n          _.assign(this, {\n            focusModel: options.focusModel,\n            clipboardModel: options.clipboardModel,\n            domEventBus: options.domEventBus,\n            isLocked: false,\n            lockTimerId: null\n          });\n\n          this.listenTo(this.focusModel, 'focusClipboard', this._onFocusClipboard);\n          this.listenTo(this.clipboardModel, 'change:text', this._onClipboardTextChange);\n        },\n        tagName: 'div',\n        className: classNameConst.CLIPBOARD,\n        attributes: {\n          contenteditable: true\n        },\n        events: {\n          keydown: '_onKeyDown',\n          copy: '_onCopy',\n          paste: '_onPaste',\n          blur: '_onBlur'\n        },\n\n        /**\n         * Render\n         * @returns {module:view/clipboard}\n         */\n        render: function render() {\n          return this;\n        },\n\n        /**\n         * Event handler for blur event.\n         * @private\n         */\n        _onBlur: function _onBlur() {\n          var focusModel = this.focusModel;\n          setTimeout(function () {\n            focusModel.refreshState();\n          }, 0);\n        },\n\n        /**\n         * Event handler for the keydown event\n         * @param {Event} ev - Event\n         * @private\n         */\n        _onKeyDown: function _onKeyDown(ev) {\n          var gridEvent;\n\n          if (this.isLocked) {\n            ev.preventDefault();\n            return;\n          }\n\n          gridEvent = keyEvent.generate(ev);\n\n          if (!gridEvent) {\n            return;\n          }\n\n          this._lock();\n\n          if (shouldPreventDefault(gridEvent)) {\n            ev.preventDefault();\n          }\n\n          if (!isPasteEvent(gridEvent)) {\n            this.domEventBus.trigger(gridEvent.type, gridEvent);\n          }\n        },\n\n        /**\n         * oncopy event handler\n         * - Step 1: When the keys(ctrl+c) are downed on grid, 'key:clipboard' is triggered.\n         * - Step 2: To listen 'change:text event on the clipboard model.\n         * - Step 3: When 'change:text' event is fired,\n         *           IE browsers set copied data to window.clipboardData in event handler and\n         *           other browsers append copied data and focus to contenteditable element.\n         * - Step 4: Finally, when 'copy' event is fired on browsers except IE,\n         *           setting copied data to ClipboardEvent.clipboardData.\n         * @param {jQueryEvent} ev - Event object\n         * @private\n         */\n        _onCopy: function _onCopy(ev) {\n          var text = this.clipboardModel.get('text');\n\n          if (!supportWindowClipboardData) {\n            (ev.originalEvent || ev).clipboardData.setData('text/plain', text);\n          }\n\n          ev.preventDefault();\n        },\n\n        /**\n         * onpaste event handler\n         * The original 'paste' event should be prevented on browsers except MS\n         * to block that copied data is appending on contenteditable element.\n         * @param {jQueryEvent} ev - Event object\n         * @private\n         */\n        _onPaste: function _onPaste(ev) {\n          var clipboardData = (ev.originalEvent || ev).clipboardData || window.clipboardData;\n\n          if (!isEdge && !supportWindowClipboardData) {\n            ev.preventDefault();\n\n            this._pasteInOtherBrowsers(clipboardData);\n          } else {\n            this._pasteInMSBrowsers(clipboardData);\n          }\n        },\n\n        /**\n         * Event handler for 'focusClipboard' event on focusModel\n         * @private\n         */\n        _onFocusClipboard: function _onFocusClipboard() {\n          try {\n            if (!this._hasFocus()) {\n              this.$el.focus(); // bug fix for IE8 (calling focus() only once doesn't work)\n\n              if (!this._hasFocus()) {\n                this.$el.focus();\n              }\n            }\n          } catch (e) {// Do nothing.\n            // This try/catch block is just for preventing 'Unspecified error'\n            // in IE9(and under) when running test using karma.\n          }\n        },\n\n        /**\n         * Event handler for the 'change:text' event on the model/clipboard module\n         * @private\n         */\n        _onClipboardTextChange: function _onClipboardTextChange() {\n          var text = this.clipboardModel.get('text');\n\n          if (supportWindowClipboardData) {\n            window.clipboardData.setData('Text', text);\n          } else {\n            this.$el.html(text).focus();\n          }\n        },\n\n        /**\n         * Paste copied data in other browsers (chrome, safari, firefox)\n         * [if] condition is copying from ms-excel,\n         * [else] condition is copying from the grid or the copied data is plain text.\n         * @param {object} clipboardData - clipboard object\n         * @private\n         */\n        _pasteInOtherBrowsers: function _pasteInOtherBrowsers(clipboardData) {\n          var clipboardModel = this.clipboardModel;\n          var data = clipboardData.getData('text/html');\n          var table;\n\n          if (data && $(data).find('tbody').length > 0) {\n            // step 1: Append copied data on contenteditable element to parsing correctly table data.\n            this.$el.html('<table>' + $(data).find('tbody').html() + '</table>'); // step 2: Make grid data from cell data of appended table element.\n\n            table = this.$el.find('table')[0];\n            data = clipboardUtil.convertTableToData(table); // step 3: Empty contenteditable element to reset.\n\n            this.$el.html('');\n          } else {\n            data = clipboardData.getData('text/plain');\n            data = clipboardUtil.convertTextToData(data);\n          }\n\n          clipboardModel.pasteClipboardDataToGrid(data);\n        },\n\n        /**\n         * Paste copied data in MS-browsers (IE, edge)\n         * @param {object} clipboardData - clipboard object\n         * @private\n         */\n        _pasteInMSBrowsers: function _pasteInMSBrowsers(clipboardData) {\n          var self = this;\n          var clipboardModel = this.clipboardModel;\n          var data = clipboardData.getData('Text');\n          var table;\n          data = clipboardUtil.convertTextToData(data);\n          setTimeout(function () {\n            if (self.$el.find('table').length > 0) {\n              table = self.$el.find('table')[0];\n              data = clipboardUtil.convertTableToData(table);\n            }\n\n            self.$el.html('');\n            clipboardModel.pasteClipboardDataToGrid(data);\n          }, 0);\n        },\n\n        /**\n         * Lock for a moment to reduce event frequency\n         * @private\n         */\n        _lock: function _lock() {\n          this.isLocked = true;\n          this.lockTimerId = setTimeout(_.bind(this._unlock, this), KEYDOWN_LOCK_TIME);\n        },\n\n        /**\n         * Unlock\n         * @private\n         */\n        _unlock: function _unlock() {\n          this.isLocked = false;\n          this.lockTimerId = null;\n        },\n\n        /**\n         * Returns whether the element has focus\n         * @returns {boolean}\n         * @private\n         */\n        _hasFocus: function _hasFocus() {\n          return this.$el.is(':focus');\n        }\n      });\n      Clipboard.KEYDOWN_LOCK_TIME = KEYDOWN_LOCK_TIME;\n      module.exports = Clipboard;\n      /***/\n    },\n    /* 44 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Key event generator\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var GridEvent = __webpack_require__(16);\n\n      var keyCodeMap = {\n        backspace: 8,\n        tab: 9,\n        enter: 13,\n        ctrl: 17,\n        esc: 27,\n        left: 37,\n        up: 38,\n        right: 39,\n        down: 40,\n        a: 65,\n        c: 67,\n        v: 86,\n        space: 32,\n        pageUp: 33,\n        pageDown: 34,\n        home: 36,\n        end: 35,\n        del: 46\n      };\n\n      var keyNameMap = _.invert(keyCodeMap);\n      /**\n       * K-V object for matching keystroke and event command\n       * K: keystroke (order : ctrl -> shift -> keyName)\n       * V: [key event type, command]\n       * @type {Object}\n       * @ignore\n       */\n\n\n      var keyStrokeCommandMap = {\n        'up': ['move', 'up'],\n        'down': ['move', 'down'],\n        'left': ['move', 'left'],\n        'right': ['move', 'right'],\n        'pageUp': ['move', 'pageUp'],\n        'pageDown': ['move', 'pageDown'],\n        'home': ['move', 'firstColumn'],\n        'end': ['move', 'lastColumn'],\n        'enter': ['edit', 'currentCell'],\n        'space': ['edit', 'currentCell'],\n        'tab': ['edit', 'nextCell'],\n        'backspace': ['delete'],\n        'del': ['delete'],\n        'shift-tab': ['edit', 'prevCell'],\n        'shift-up': ['select', 'up'],\n        'shift-down': ['select', 'down'],\n        'shift-left': ['select', 'left'],\n        'shift-right': ['select', 'right'],\n        'shift-pageUp': ['select', 'pageUp'],\n        'shift-pageDown': ['select', 'pageDown'],\n        'shift-home': ['select', 'firstColumn'],\n        'shift-end': ['select', 'lastColumn'],\n        'ctrl-a': ['select', 'all'],\n        'ctrl-c': ['clipboard', 'copy'],\n        'ctrl-v': ['clipboard', 'paste'],\n        'ctrl-home': ['move', 'firstCell'],\n        'ctrl-end': ['move', 'lastCell'],\n        'ctrl-shift-home': ['select', 'firstCell'],\n        'ctrl-shift-end': ['select', 'lastCell']\n      };\n      /**\n       * Returns the keyStroke string\n       * @param {Event} ev - Keyboard event\n       * @returns {String}\n       * @ignore\n       */\n\n      function getKeyStrokeString(ev) {\n        var keys = [];\n\n        if (ev.ctrlKey || ev.metaKey) {\n          keys.push('ctrl');\n        }\n\n        if (ev.shiftKey) {\n          keys.push('shift');\n        }\n\n        keys.push(keyNameMap[ev.keyCode]);\n        return keys.join('-');\n      }\n      /* Keyboard Event Generator\n       * @module event/keyEvent\n       * @ignore\n       */\n\n\n      module.exports = {\n        generate: function generate(ev) {\n          var keyStroke = getKeyStrokeString(ev);\n          var commandInfo = keyStrokeCommandMap[keyStroke];\n          var gridEvent;\n\n          if (commandInfo) {\n            gridEvent = new GridEvent(ev, {\n              type: 'key:' + commandInfo[0],\n              command: commandInfo[1]\n            });\n          }\n\n          return gridEvent;\n        }\n      };\n      /***/\n    },\n    /* 45 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Left Side Frame\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var Frame = __webpack_require__(46);\n\n      var classNameConst = __webpack_require__(19);\n\n      var frameConst = __webpack_require__(10).frame;\n      /**\n       * Left Side Frame\n       * @module view/layout/frame-lside\n       * @extends module:view/layout/frame\n       * @ignore\n       */\n\n\n      var LsideFrame = Frame.extend(\n      /** @lends module:view/layout/frame-lside.prototype */\n      {\n        initialize: function initialize() {\n          Frame.prototype.initialize.apply(this, arguments);\n\n          _.assign(this, {\n            whichSide: frameConst.L\n          });\n\n          this.listenTo(this.dimensionModel, 'change:lsideWidth', this._onFrameWidthChanged);\n        },\n        className: classNameConst.LSIDE_AREA,\n\n        /**\n         * Event handler for 'change:lsideWidth' event on module:model/dimension\n         * @private\n         */\n        _onFrameWidthChanged: function _onFrameWidthChanged() {\n          this.$el.css({\n            width: this.dimensionModel.get('lsideWidth')\n          });\n        },\n\n        /**\n         * To be called at the beginning of the 'render' method.\n         * @override\n         */\n        beforeRender: function beforeRender() {\n          this.$el.css({\n            display: 'block',\n            width: this.dimensionModel.get('lsideWidth')\n          });\n        },\n\n        /**\n         * To be called at the end of the 'render' method.\n         * @override\n         */\n        afterRender: function afterRender() {\n          if (this.dimensionModel.get('scrollX')) {\n            this.$el.append($('<div />').addClass(classNameConst.SCROLLBAR_LEFT_BOTTOM));\n          }\n        }\n      });\n      module.exports = LsideFrame;\n      /***/\n    },\n    /* 46 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Frame Base\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var View = __webpack_require__(4);\n\n      var constMap = __webpack_require__(10);\n\n      var frameConst = constMap.frame;\n      var summaryPositionConst = constMap.summaryPosition;\n      /**\n       * Base class for frame view.\n       * @module view/layout/frame\n       * @extends module:base/view\n       * @param {Object} options Options\n       *      @param {String} [options.whichSide=R] R for Right side, L for Left side\n       * @ignore\n       */\n\n      var Frame = View.extend(\n      /** @lends module:view/layout/frame.prototype */\n      {\n        initialize: function initialize(options) {\n          View.prototype.initialize.call(this);\n\n          _.assign(this, {\n            viewFactory: options.viewFactory,\n            renderModel: options.renderModel,\n            dimensionModel: options.dimensionModel,\n            whichSide: options.whichSide || frameConst.R\n          });\n\n          this.listenTo(this.renderModel, 'columnModelChanged', this.render);\n        },\n\n        /**\n         * Render\n         * @returns {module:view/layout/frame} This object\n         */\n        render: function render() {\n          this.$el.empty();\n\n          this._destroyChildren();\n\n          this.beforeRender();\n\n          this._addChildren(this._createChildren());\n\n          this.$el.append(this._renderChildren());\n          this.afterRender();\n          return this;\n        },\n\n        /**\n         * To be called at the beginning of the 'render' method.\n         * @abstract\n         */\n        beforeRender: function beforeRender() {},\n\n        /**\n         * To be called at the end of the 'render' method.\n         * @abstract\n         */\n        afterRender: function afterRender() {},\n\n        /**\n         * Create children view to append on frame element\n         * @returns {array} View elements\n         * @private\n         */\n        _createChildren: function _createChildren() {\n          var factory = this.viewFactory;\n          var summaryPosition = this.dimensionModel.get('summaryPosition');\n          var header = factory.createHeader(this.whichSide);\n          var body = factory.createBody(this.whichSide);\n          var summary = factory.createSummary(this.whichSide, summaryPosition);\n          var children;\n\n          if (summaryPosition === summaryPositionConst.TOP) {\n            children = [header, summary, body];\n          } else if (summaryPosition === summaryPositionConst.BOTTOM) {\n            children = [header, body, summary];\n          } else {\n            children = [header, body];\n          }\n\n          return children;\n        }\n      });\n      module.exports = Frame;\n      /***/\n    },\n    /* 47 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Right Side Frame\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var Frame = __webpack_require__(46);\n\n      var classNameConst = __webpack_require__(19);\n\n      var constMap = __webpack_require__(10);\n\n      var frameConst = constMap.frame;\n      var dimensionConst = constMap.dimension;\n      var summaryPositionConst = constMap.summaryPosition;\n      var CELL_BORDER_WIDTH = dimensionConst.CELL_BORDER_WIDTH;\n      var RsideFrame;\n      /**\n       * Create div element to use on right-side area\n       * @param {string} className - class name to add on element\n       * @param {object} styles - style object to set css\n       * @returns {jQuery} created div element\n       * @ignore\n       */\n\n      function createDiv(className, styles) {\n        var $element = $('<div />').addClass(className);\n\n        if (styles) {\n          $element.css(styles);\n        }\n\n        return $element;\n      }\n      /**\n       * right side frame class\n       * @module view/layout/frame-rside\n       * @extends module:view/layout/frame\n       * @ignore\n       */\n\n\n      RsideFrame = Frame.extend(\n      /** @lends module:view/layout/frame-rside.prototype */\n      {\n        initialize: function initialize() {\n          Frame.prototype.initialize.apply(this, arguments);\n\n          _.assign(this, {\n            whichSide: frameConst.R,\n            $scrollBorder: null\n          });\n\n          this.listenTo(this.dimensionModel, 'change:lsideWidth change:rsideWidth', this._onFrameWidthChanged);\n          this.listenTo(this.dimensionModel, 'change:bodyHeight change:headerHeight', this._resetScrollBorderHeight);\n        },\n        className: classNameConst.RSIDE_AREA,\n\n        /**\n         * Event handler for 'change:rsideWidth' event on dimensionModel\n         * @private\n         * @override\n         */\n        _onFrameWidthChanged: function _onFrameWidthChanged() {\n          this._refreshLayout();\n        },\n\n        /**\n         * Refresh layout\n         * @private\n         */\n        _refreshLayout: function _refreshLayout() {\n          var dimensionModel = this.dimensionModel;\n          var width = dimensionModel.get('rsideWidth');\n          var marginLeft = dimensionModel.get('lsideWidth');\n          var frozenBorderWidth = dimensionModel.get('frozenBorderWidth'); // If the left side exists and the division border should not be doubled,\n          // left side should cover the right side by border-width to hide the left border of the right side.\n\n          if (marginLeft > 0 && !dimensionModel.isDivisionBorderDoubled()) {\n            width += CELL_BORDER_WIDTH;\n            marginLeft -= CELL_BORDER_WIDTH;\n          }\n\n          this.$el.css({\n            width: width,\n            marginLeft: marginLeft + frozenBorderWidth\n          });\n        },\n\n        /**\n         * Resets the height of a vertical scroll-bar border\n         * @private\n         */\n        _resetScrollBorderHeight: function _resetScrollBorderHeight() {\n          var dimensionModel, height;\n\n          if (this.$scrollBorder) {\n            dimensionModel = this.dimensionModel;\n            height = dimensionModel.get('bodyHeight') - dimensionModel.getScrollXHeight();\n            this.$scrollBorder.height(height);\n          }\n        },\n\n        /**\n         * To be called at the beginning of the 'render' method.\n         * @override\n         */\n        beforeRender: function beforeRender() {\n          this.$el.css('display', 'block');\n\n          this._refreshLayout();\n        },\n\n        /**\n         * To be called at the end of the 'render' method.\n         * @override\n         */\n        afterRender: function afterRender() {\n          var dimensionModel = this.dimensionModel;\n          var scrollX = dimensionModel.get('scrollX');\n          var scrollY = dimensionModel.get('scrollY');\n\n          var spaceHeights = this._getSpaceHeights(scrollX, scrollY);\n\n          this._setScrollbar(scrollX, scrollY, spaceHeights);\n\n          if (dimensionModel.get('frozenBorderWidth')) {\n            this._setFrozenBorder(scrollX);\n          }\n\n          this._resetScrollBorderHeight();\n        },\n\n        /**\n         * Get height values of top, bottom space on scroll area\n         * @param {boolean} scrollX - Whether the grid has x-scroll or not\n         * @param {boolean} scrollY - Whether the grid has y-scroll or not\n         * @returns {object} Heighs value\n         * @private\n         */\n        _getSpaceHeights: function _getSpaceHeights(scrollX, scrollY) {\n          var dimensionModel = this.dimensionModel;\n          var summaryHeight = dimensionModel.get('summaryHeight');\n          var summaryPosition = dimensionModel.get('summaryPosition');\n          var topHeight = dimensionModel.get('headerHeight');\n          var bottomHeight = scrollX ? dimensionConst.SCROLLBAR_WIDTH : 0;\n\n          if (scrollY && summaryHeight) {\n            if (summaryPosition === summaryPositionConst.TOP) {\n              topHeight += summaryHeight + dimensionConst.TABLE_BORDER_WIDTH;\n            } else {\n              bottomHeight += summaryHeight;\n            }\n          }\n\n          return {\n            top: topHeight,\n            bottom: bottomHeight\n          };\n        },\n\n        /**\n         * Create scrollbar area and set styles\n         * @param {boolean} scrollX - Whether the grid has x-scroll or not\n         * @param {boolean} scrollY - Whether the grid has y-scroll or not\n         * @param {object} spaceHeights - Height values of top, bottom space on scroll area\n         * @private\n         */\n        _setScrollbar: function _setScrollbar(scrollX, scrollY, spaceHeights) {\n          var $yInnerBorder, $yOuterBorder, $spaceRightTop, $spaceRightBottom, $frozenBorder;\n\n          if (scrollX) {\n            $frozenBorder = createDiv(classNameConst.SCROLLBAR_FROZEN_BORDER, {\n              height: dimensionConst.SCROLLBAR_WIDTH\n            });\n          }\n\n          if (scrollY) {\n            // subtract 2px for border-width (top and bottom)\n            $spaceRightTop = createDiv(classNameConst.SCROLLBAR_RIGHT_TOP, {\n              height: spaceHeights.top - 2\n            });\n            $yInnerBorder = createDiv(classNameConst.SCROLLBAR_Y_INNER_BORDER, {\n              top: spaceHeights.top\n            });\n            $yOuterBorder = createDiv(classNameConst.SCROLLBAR_Y_OUTER_BORDER);\n          }\n\n          if (scrollX || scrollY) {\n            $spaceRightBottom = createDiv(classNameConst.SCROLLBAR_RIGHT_BOTTOM, {\n              height: spaceHeights.bottom\n            });\n          }\n\n          this.$el.append($yInnerBorder, $yOuterBorder, $spaceRightTop, $spaceRightBottom, $frozenBorder);\n          this.$scrollBorder = $yInnerBorder;\n        },\n\n        /**\n         * Create frozen border and set styles\n         * @param {boolean} scrollX - Whether the grid has x-scroll or not\n         * @private\n         */\n        _setFrozenBorder: function _setFrozenBorder() {\n          var dimensionModel = this.dimensionModel;\n          var headerHeight = dimensionModel.get('headerHeight');\n          var frozenBorderWidth = dimensionModel.get('frozenBorderWidth');\n          var resizeHandleView = this.viewFactory.createHeaderResizeHandle(frameConst.L, [headerHeight], true);\n          var $resizeHanlder = resizeHandleView.render().$el;\n          var $frozenBorder = createDiv(classNameConst.FROZEN_BORDER, {\n            marginLeft: -frozenBorderWidth,\n            width: frozenBorderWidth\n          });\n          this.$el.append($resizeHanlder, $frozenBorder).find('.' + classNameConst.SCROLLBAR_FROZEN_BORDER).css({\n            marginLeft: -(frozenBorderWidth + CELL_BORDER_WIDTH),\n            width: frozenBorderWidth\n          });\n        }\n      });\n      module.exports = RsideFrame;\n      /***/\n    },\n    /* 48 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Header View\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var View = __webpack_require__(4);\n\n      var util = __webpack_require__(17);\n\n      var constMap = __webpack_require__(10);\n\n      var classNameConst = __webpack_require__(19);\n\n      var GridEvent = __webpack_require__(16);\n\n      var DragEventEmitter = __webpack_require__(40);\n\n      var frameConst = constMap.frame;\n      var DELAY_SYNC_CHECK = 10;\n      var keyCodeMap = constMap.keyCode;\n      var ATTR_COLUMN_NAME = constMap.attrName.COLUMN_NAME;\n      var CELL_BORDER_WIDTH = constMap.dimension.CELL_BORDER_WIDTH;\n      var TABLE_BORDER_WIDTH = constMap.dimension.TABLE_BORDER_WIDTH; // Minimum time (ms) to detect if an alert or confirm dialog has been displayed.\n\n      var MIN_INTERVAL_FOR_PAUSED = 200;\n      var Header;\n      /**\n       * Get count of same columns in complex columns\n       * @param {array} currentColumn - Current column's model\n       * @param {array} prevColumn - Previous column's model\n       * @returns {number} Count of same columns\n       * @ignore\n       */\n\n      function getSameColumnCount(currentColumn, prevColumn) {\n        var index = 0;\n        var len = Math.min(currentColumn.length, prevColumn.length);\n\n        for (; index < len; index += 1) {\n          if (currentColumn[index].name !== prevColumn[index].name) {\n            break;\n          }\n        }\n\n        return index;\n      }\n      /**\n       * Header Layout View\n       * @module view/layout/header\n       * @extends module:base/view\n       * @param {Object} options - options\n       * @param {String} [options.whichSide=R]  R: Right, L: Left\n       * @ignore\n       */\n\n\n      Header = View.extend(\n      /** @lends module:view/layout/header.prototype */\n      {\n        initialize: function initialize(options) {\n          View.prototype.initialize.call(this);\n\n          _.assign(this, {\n            renderModel: options.renderModel,\n            coordColumnModel: options.coordColumnModel,\n            selectionModel: options.selectionModel,\n            focusModel: options.focusModel,\n            columnModel: options.columnModel,\n            dataModel: options.dataModel,\n            coordRowModel: options.coordRowModel,\n            dimensionModel: options.dimensionModel,\n            viewFactory: options.viewFactory,\n            domEventBus: options.domEventBus,\n            whichSide: options.whichSide || frameConst.R\n          });\n\n          this.dragEmitter = new DragEventEmitter({\n            type: 'header',\n            domEventBus: this.domEventBus,\n            onDragMove: _.bind(this._onDragMove, this)\n          });\n          this.listenTo(this.renderModel, 'change:scrollLeft', this._onScrollLeftChange).listenTo(this.coordColumnModel, 'columnWidthChanged', this._onColumnWidthChanged).listenTo(this.selectionModel, 'change:range', this._refreshSelectedHeaders).listenTo(this.focusModel, 'change:columnName', this._refreshSelectedHeaders).listenTo(this.dataModel, 'sortChanged', this._updateBtnSortState).listenTo(this.dimensionModel, 'change:headerHeight', this.render);\n\n          if (this.whichSide === frameConst.L && this.columnModel.get('selectType') === 'checkbox') {\n            this.listenTo(this.dataModel, 'change:_button disabledChanged extraDataChanged add remove reset', _.debounce(_.bind(this._syncCheckedState, this), DELAY_SYNC_CHECK));\n          }\n        },\n        className: classNameConst.HEAD_AREA,\n        events: {\n          'click': '_onClick',\n          'keydown input': '_onKeydown',\n          'mousedown th': '_onMouseDown'\n        },\n\n        /**\n         * template\n         */\n        template: _.template('<table class=\"' + classNameConst.TABLE + '\">' + '<colgroup><%=colGroup%></colgroup>' + '<tbody><%=tBody%></tbody>' + '</table>'),\n\n        /**\n         * template for <th>\n         */\n        templateHeader: _.template('<th <%=attrColumnName%>=\"<%=columnName%>\" ' + 'class=\"<%=className%>\" ' + 'height=\"<%=height%>\" ' + '<%if(colspan > 0) {%>' + 'colspan=<%=colspan%> ' + '<%}%>' + '<%if(rowspan > 0) {%>' + 'rowspan=<%=rowspan%> ' + '<%}%>' + '>' + '<%=title%><%=btnSort%>' + '</th>'),\n\n        /**\n         * templse for <col>\n         */\n        templateCol: _.template('<col ' + '<%=attrColumnName%>=\"<%=columnName%>\" ' + 'style=\"width:<%=width%>px\">'),\n\n        /**\n         * HTML string for a button\n         */\n        markupBtnSort: '<a class=\"' + classNameConst.BTN_SORT + '\"></a>',\n\n        /**\n         * col group 마크업을 생성한다.\n         * @returns {string} <colgroup>에 들어갈 html 마크업 스트링\n         * @private\n         */\n        _getColGroupMarkup: function _getColGroupMarkup() {\n          var columnData = this._getColumnData();\n\n          var columnWidths = columnData.widths;\n          var columns = columnData.columns;\n          var htmlList = [];\n\n          _.each(columnWidths, function (width, index) {\n            htmlList.push(this.templateCol({\n              attrColumnName: ATTR_COLUMN_NAME,\n              columnName: columns[index].name,\n              width: width + CELL_BORDER_WIDTH\n            }));\n          }, this);\n\n          return htmlList.join('');\n        },\n\n        /**\n         * Returns an array of names of columns in selection range.\n         * @private\n         * @returns {Array.<String>}\n         */\n        _getSelectedColumnNames: function _getSelectedColumnNames() {\n          var columnRange = this.selectionModel.get('range').column;\n          var visibleColumns = this.columnModel.getVisibleColumns();\n          var selectedColumns = visibleColumns.slice(columnRange[0], columnRange[1] + 1);\n          return _.pluck(selectedColumns, 'name');\n        },\n        _onDragMove: function _onDragMove(gridEvent) {\n          var $target = $(gridEvent.target);\n          gridEvent.setData({\n            columnName: $target.closest('th').attr(ATTR_COLUMN_NAME),\n            isOnHeaderArea: $.contains(this.el, $target[0])\n          });\n        },\n\n        /**\n         * Returns an array of names of merged-column which contains every column name in the given array.\n         * @param {Array.<String>} columnNames - an array of column names to test\n         * @returns {Array.<String>}\n         * @private\n         */\n        _getContainingMergedColumnNames: function _getContainingMergedColumnNames(columnNames) {\n          var columnModel = this.columnModel;\n\n          var mergedColumnNames = _.pluck(columnModel.get('complexHeaderColumns'), 'name');\n\n          return _.filter(mergedColumnNames, function (mergedColumnName) {\n            var unitColumnNames = columnModel.getUnitColumnNamesIfMerged(mergedColumnName);\n            return _.every(unitColumnNames, function (name) {\n              return _.contains(columnNames, name);\n            });\n          });\n        },\n\n        /**\n         * Refreshes selected class of every header element (th)\n         * @private\n         */\n        _refreshSelectedHeaders: function _refreshSelectedHeaders() {\n          var $ths = this.$el.find('th');\n          var columnNames, mergedColumnNames;\n\n          if (this.selectionModel.hasSelection()) {\n            columnNames = this._getSelectedColumnNames();\n          } else if (this.focusModel.has(true)) {\n            columnNames = [this.focusModel.get('columnName')];\n          }\n\n          $ths.removeClass(classNameConst.CELL_SELECTED);\n\n          if (columnNames) {\n            mergedColumnNames = this._getContainingMergedColumnNames(columnNames);\n\n            _.each(columnNames.concat(mergedColumnNames), function (columnName) {\n              $ths.filter('[' + ATTR_COLUMN_NAME + '=\"' + columnName + '\"]').addClass(classNameConst.CELL_SELECTED);\n            });\n          }\n        },\n\n        /**\n         * Event handler for 'keydown' event on checkbox input\n         * @param {KeyboardEvent} event - event\n         * @private\n         */\n        _onKeydown: function _onKeydown(event) {\n          if (event.keyCode === keyCodeMap.TAB) {\n            event.preventDefault();\n            this.focusModel.focusClipboard();\n          }\n        },\n\n        /**\n         * Mousedown event handler\n         * @param {jQuery.Event} ev - MouseDown event\n         * @private\n         */\n        _onMouseDown: function _onMouseDown(ev) {\n          var $target = $(ev.target);\n          var columnName;\n\n          if (!this._triggerPublicMousedown(ev)) {\n            return;\n          }\n\n          if ($target.hasClass(classNameConst.BTN_SORT)) {\n            return;\n          }\n\n          columnName = $target.closest('th').attr(ATTR_COLUMN_NAME);\n\n          if (columnName) {\n            this.dragEmitter.start(ev, {\n              columnName: columnName\n            });\n          }\n        },\n\n        /**\n         * Trigger mousedown:body event on domEventBus and returns the result\n         * @param {MouseEvent} ev - MouseEvent\n         * @returns {module:event/gridEvent}\n         * @private\n         */\n        _triggerPublicMousedown: function _triggerPublicMousedown(ev) {\n          var startTime, endTime;\n          var gridEvent = new GridEvent(ev, GridEvent.getTargetInfo($(ev.target)));\n          var paused;\n          startTime = new Date().getTime();\n          this.domEventBus.trigger('mousedown', gridEvent);\n          endTime = new Date().getTime(); // check if the model window (alert or confirm) was popped up\n\n          paused = endTime - startTime > MIN_INTERVAL_FOR_PAUSED;\n          return !gridEvent.isStopped() && !paused;\n        },\n\n        /**\n         * selectType 이 checkbox 일 때 랜더링 되는 header checkbox 엘리먼트를 반환한다.\n         * @returns {jQuery} _butoon 컬럼 헤더의 checkbox input 엘리먼트\n         * @private\n         */\n        _getHeaderMainCheckbox: function _getHeaderMainCheckbox() {\n          return this.$el.find('th[' + ATTR_COLUMN_NAME + '=\"_button\"] input');\n        },\n\n        /**\n         * header 영역의 input 상태를 실제 checked 된 count 에 맞추어 반영한다.\n         * @private\n         */\n        _syncCheckedState: function _syncCheckedState() {\n          var checkedState = this.dataModel.getCheckedState();\n          var $input, props;\n          $input = this._getHeaderMainCheckbox();\n\n          if (!$input.length) {\n            return;\n          }\n\n          if (!checkedState.available) {\n            props = {\n              checked: false,\n              disabled: true\n            };\n          } else {\n            props = {\n              checked: checkedState.available === checkedState.checked,\n              disabled: false\n            };\n          }\n\n          $input.prop(props);\n        },\n\n        /**\n         * column width 변경시 col 엘리먼트들을 조작하기 위한 헨들러\n         * @private\n         */\n        _onColumnWidthChanged: function _onColumnWidthChanged() {\n          var columnWidths = this.coordColumnModel.getWidths(this.whichSide);\n          var $colList = this.$el.find('col');\n          var coordRowModel = this.coordRowModel;\n\n          _.each(columnWidths, function (columnWidth, index) {\n            $colList.eq(index).css('width', columnWidth + CELL_BORDER_WIDTH);\n          }); // Calls syncWithDom only from the Rside to prevent calling twice.\n          // Defered call to ensure that the execution occurs after both sides are rendered.\n\n\n          if (this.whichSide === frameConst.R) {\n            _.defer(function () {\n              coordRowModel.syncWithDom();\n            });\n          }\n        },\n\n        /**\n         * scroll left 값이 변경되었을 때 header 싱크를 맞추는 이벤트 핸들러\n         * @param {Object} model    변경이 발생한 model 인스턴스\n         * @param {Number} value    scrollLeft 값\n         * @private\n         */\n\n        /* istanbul ignore next: scrollLeft 를 확인할 수 없음 */\n        _onScrollLeftChange: function _onScrollLeftChange(model, value) {\n          if (this.whichSide === frameConst.R) {\n            this.el.scrollLeft = value;\n          }\n        },\n\n        /**\n         * Event handler for click event\n         * @param {jQuery.Event} ev - MouseEvent\n         * @private\n         */\n        _onClick: function _onClick(ev) {\n          var $target = $(ev.target);\n          var columnName = $target.closest('th').attr(ATTR_COLUMN_NAME);\n          var eventData = new GridEvent(ev);\n\n          if (columnName === '_button' && $target.is('input')) {\n            eventData.setData({\n              checked: $target.prop('checked')\n            });\n            this.domEventBus.trigger('click:headerCheck', eventData);\n          } else if ($target.is('a.' + classNameConst.BTN_SORT)) {\n            eventData.setData({\n              columnName: columnName,\n              sortingType: this._getColumnSortingType(columnName)\n            });\n            this.domEventBus.trigger('click:headerSort', eventData);\n          }\n        },\n\n        /**\n         * 정렬 버튼의 상태를 변경한다.\n         * @private\n         * @param {object} sortOptions 정렬 옵션\n         * @param {string} sortOptions.columnName 정렬할 컬럼명\n         * @param {boolean} sortOptions.ascending 오름차순 여부\n         */\n        _updateBtnSortState: function _updateBtnSortState(sortOptions) {\n          var className;\n\n          if (this._$currentSortBtn) {\n            this._$currentSortBtn.removeClass(classNameConst.BTN_SORT_DOWN + ' ' + classNameConst.BTN_SORT_UP);\n          }\n\n          this._$currentSortBtn = this.$el.find('th[' + ATTR_COLUMN_NAME + '=\"' + sortOptions.columnName + '\"] a.' + classNameConst.BTN_SORT);\n          className = sortOptions.ascending ? classNameConst.BTN_SORT_UP : classNameConst.BTN_SORT_DOWN;\n\n          this._$currentSortBtn.addClass(className);\n        },\n\n        /**\n         * 랜더링\n         * @returns {View.Layout.Header} this\n         */\n        render: function render() {\n          var resizeHandleHeights;\n\n          this._destroyChildren();\n\n          this.$el.css({\n            height: this.dimensionModel.get('headerHeight') - TABLE_BORDER_WIDTH\n          }).html(this.template({\n            colGroup: this._getColGroupMarkup(),\n            tBody: this._getTableBodyMarkup()\n          }));\n\n          if (this.coordColumnModel.get('resizable')) {\n            resizeHandleHeights = this._getResizeHandleHeights();\n\n            this._addChildren(this.viewFactory.createHeaderResizeHandle(this.whichSide, resizeHandleHeights));\n\n            this.$el.append(this._renderChildren());\n          }\n\n          return this;\n        },\n\n        /**\n         * 컬럼 정보를 반환한다.\n         * @returns {{widths: (Array|*), columns: (Array|*)}}   columnWidths 와 columns 를 함께 반환한다.\n         * @private\n         */\n        _getColumnData: function _getColumnData() {\n          var columnWidths = this.coordColumnModel.getWidths(this.whichSide);\n          var columns = this.columnModel.getVisibleColumns(this.whichSide, true);\n          return {\n            widths: columnWidths,\n            columns: columns\n          };\n        },\n\n        /* eslint-disable complexity */\n\n        /**\n         * Header 의 body markup 을 생성한다.\n         * @returns {string} header 의 테이블 body 영역에 들어갈 html 마크업 스트링\n         * @private\n         */\n        _getTableBodyMarkup: function _getTableBodyMarkup() {\n          var hierarchyList = this._getColumnHierarchyList();\n\n          var maxRowCount = this._getHierarchyMaxRowCount(hierarchyList);\n\n          var headerHeight = this.dimensionModel.get('headerHeight');\n          var rowMarkupList = new Array(maxRowCount);\n          var columnNames = new Array(maxRowCount);\n          var colSpanList = [];\n          var rowHeight = util.getRowHeight(maxRowCount, headerHeight) - 1;\n          var rowSpan = 1;\n          var height;\n          var headerMarkupList;\n\n          _.each(hierarchyList, function (hierarchy, i) {\n            var length = hierarchyList[i].length;\n            var curHeight = 0;\n\n            _.each(hierarchy, function (columnModel, j) {\n              var columnName = columnModel.name;\n              var classNames = [classNameConst.CELL, classNameConst.CELL_HEAD];\n\n              if (columnModel.validation && columnModel.validation.required) {\n                classNames.push(classNameConst.CELL_REQRUIRED);\n              }\n\n              rowSpan = length - 1 === j && maxRowCount - length + 1 > 1 ? maxRowCount - length + 1 : 1;\n              height = rowHeight * rowSpan;\n\n              if (j === length - 1) {\n                height = headerHeight - curHeight - 2;\n              } else {\n                curHeight += height + 1;\n              }\n\n              if (columnNames[j] === columnName) {\n                rowMarkupList[j].pop();\n                colSpanList[j] += 1;\n              } else {\n                colSpanList[j] = 1;\n              }\n\n              columnNames[j] = columnName;\n              rowMarkupList[j] = rowMarkupList[j] || [];\n              rowMarkupList[j].push(this.templateHeader({\n                attrColumnName: ATTR_COLUMN_NAME,\n                columnName: columnName,\n                className: classNames.join(' '),\n                height: height,\n                colspan: colSpanList[j],\n                rowspan: rowSpan,\n                title: columnModel.title,\n                btnSort: columnModel.sortable ? this.markupBtnSort : ''\n              }));\n            }, this);\n          }, this);\n\n          headerMarkupList = _.map(rowMarkupList, function (rowMarkup) {\n            return '<tr>' + rowMarkup.join('') + '</tr>';\n          });\n          return headerMarkupList.join('');\n        },\n\n        /* eslint-enable complexity */\n\n        /**\n         * column merge 가 설정되어 있을 때 헤더의 max row count 를 가져온다.\n         * @param {Array} hierarchyList 헤더 마크업 생성시 사용될 계층구조 데이터\n         * @returns {number} 헤더 영역의 row 최대값\n         * @private\n         */\n        _getHierarchyMaxRowCount: function _getHierarchyMaxRowCount(hierarchyList) {\n          var lengthList = [0];\n\n          _.each(hierarchyList, function (hierarchy) {\n            lengthList.push(hierarchy.length);\n          }, this);\n\n          return Math.max.apply(Math, lengthList);\n        },\n\n        /**\n         * column merge 가 설정되어 있을 때 헤더의 계층구조 리스트를 가져온다.\n         * @returns {Array}  계층구조 리스트\n         * @private\n         */\n        _getColumnHierarchyList: function _getColumnHierarchyList() {\n          var columns = this._getColumnData().columns;\n\n          var hierarchyList;\n          hierarchyList = _.map(columns, function (column) {\n            return this._getColumnHierarchy(column).reverse();\n          }, this);\n          return hierarchyList;\n        },\n\n        /**\n         * complexHeaderColumns 가 설정되어 있을 때 재귀적으로 돌면서 계층구조를 형성한다.\n         * @param {Object} column - column\n         * @param {Array} [results] - 결과로 메모이제이션을 이용하기 위한 인자값\n         * @returns {Array}\n         * @private\n         */\n        _getColumnHierarchy: function _getColumnHierarchy(column, results) {\n          var complexHeaderColumns = this.columnModel.get('complexHeaderColumns');\n          results = results || [];\n\n          if (column) {\n            results.push(column);\n\n            if (complexHeaderColumns) {\n              _.each(complexHeaderColumns, function (headerColumn) {\n                if ($.inArray(column.name, headerColumn.childNames) !== -1) {\n                  this._getColumnHierarchy(headerColumn, results);\n                }\n              }, this);\n            }\n          }\n\n          return results;\n        },\n\n        /**\n         * Get height values of resize handlers\n         * @returns {array} Height values of resize handles\n         */\n        _getResizeHandleHeights: function _getResizeHandleHeights() {\n          var hierarchyList = this._getColumnHierarchyList();\n\n          var maxRowCount = this._getHierarchyMaxRowCount(hierarchyList);\n\n          var rowHeight = util.getRowHeight(maxRowCount, this.dimensionModel.get('headerHeight')) - 1;\n          var handleHeights = [];\n          var index = 1;\n          var coulmnLen = hierarchyList.length;\n          var sameColumnCount, handleHeight;\n\n          for (; index < coulmnLen; index += 1) {\n            sameColumnCount = getSameColumnCount(hierarchyList[index], hierarchyList[index - 1]);\n            handleHeight = rowHeight * (maxRowCount - sameColumnCount);\n            handleHeights.push(handleHeight);\n          }\n\n          handleHeights.push(rowHeight * maxRowCount); // last resize handle\n\n          return handleHeights;\n        },\n\n        /**\n         * Get sorting type of the column\n         * @param {string} columnName - target column\n         * @returns {string|undefined} sorting type of the column\n         * @private\n         */\n        _getColumnSortingType: function _getColumnSortingType(columnName) {\n          var columnData = this._getColumnData();\n\n          var column = _.findWhere(columnData.columns, {\n            name: columnName\n          });\n\n          return column.sortingType;\n        }\n      });\n      Header.DELAY_SYNC_CHECK = DELAY_SYNC_CHECK;\n      module.exports = Header;\n      /***/\n    },\n    /* 49 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview ResizeHandle for the Header\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var View = __webpack_require__(4);\n\n      var constMap = __webpack_require__(10);\n\n      var classNameConst = __webpack_require__(19);\n\n      var DragEventEmitter = __webpack_require__(40);\n\n      var i18n = __webpack_require__(42);\n\n      var attrNameConst = constMap.attrName;\n      var frameConst = constMap.frame;\n      var CELL_BORDER_WIDTH = constMap.dimension.CELL_BORDER_WIDTH;\n      var RESIZE_HANDLE_WIDTH = constMap.dimension.RESIZE_HANDLE_WIDTH;\n      var EXTRA_WIDTH = 3;\n      var DEFAULT_WIDTH = 7;\n      /**\n       * Resize Handler class\n       * @module view/layout/resizeHandle\n       * @extends module:base/view\n       * @param {Object} options - Options\n       * @ignore\n       */\n\n      var ResizeHandle = View.extend(\n      /** @lends module:view/layout/resizeHandle.prototype */\n      {\n        initialize: function initialize(options) {\n          _.assign(this, {\n            columnModel: options.columnModel,\n            coordColumnModel: options.coordColumnModel,\n            dimensionModel: options.dimensionModel,\n            domEventBus: options.domEventBus,\n            handleHeights: options.handleHeights,\n            whichSide: options.whichSide || frameConst.R,\n            frozenBorder: options.frozenBorder || false\n          });\n\n          this.dragEmitter = new DragEventEmitter({\n            type: 'resizeColumn',\n            cursor: 'col-resize',\n            domEventBus: this.domEventBus,\n            onDragMove: _.bind(this._onDragMove, this)\n          });\n          this.listenTo(this.coordColumnModel, 'columnWidthChanged', this._refreshHandlerPosition);\n        },\n        className: classNameConst.COLUMN_RESIZE_CONTAINER,\n        events: function events() {\n          var eventHash = {};\n          eventHash['mousedown .' + classNameConst.COLUMN_RESIZE_HANDLE] = '_onMouseDown';\n          eventHash['dblclick .' + classNameConst.COLUMN_RESIZE_HANDLE] = '_onDblClick';\n          return eventHash;\n        },\n        template: _.template('<div ' + attrNameConst.COLUMN_INDEX + '=\"<%=columnIndex%>\" ' + attrNameConst.COLUMN_NAME + '=\"<%=columnName%>\" ' + 'class=\"' + classNameConst.COLUMN_RESIZE_HANDLE + ' <%=lastClass%>\" ' + 'title=\"<%=title%>\"' + 'style=\"width:<%=width%>;height:<%=height%>;display:<%=displayType%>\">' + '</div>'),\n\n        /**\n         * Return an object that contains an array of column width and an array of column model.\n         * @returns {{widths: (Array|*), columns: (Array|*)}} Column Data\n         * @private\n         */\n        _getColumnData: function _getColumnData() {\n          var columnWidths = this.coordColumnModel.getWidths(this.whichSide);\n          var columns = this.columnModel.getVisibleColumns(this.whichSide, true);\n          return {\n            widths: columnWidths,\n            columns: columns\n          };\n        },\n\n        /**\n         * Returns the HTML string of all handler.\n         * @returns {String}\n         * @private\n         */\n        _getResizeHandlerMarkup: function _getResizeHandlerMarkup() {\n          var frozenBorder = this.frozenBorder;\n\n          var columns = this._getColumnData().columns;\n\n          var length = columns.length;\n          var width = frozenBorder ? this.dimensionModel.get('frozenBorderWidth') + EXTRA_WIDTH : DEFAULT_WIDTH;\n\n          var resizeHandleMarkupList = _.map(frozenBorder ? [_.last(columns)] : columns, function (column, index) {\n            var columnName = column.name;\n            return this.template({\n              lastClass: index + 1 === length ? classNameConst.COLUMN_RESIZE_HANDLE_LAST : '',\n              columnIndex: frozenBorder ? length - 1 : index,\n              columnName: columnName,\n              width: width + 'px',\n              height: this.handleHeights[index] + 'px',\n              title: i18n.get('resizeHandleGuide'),\n              displayType: column.resizable === false ? 'none' : 'block'\n            });\n          }, this);\n\n          return resizeHandleMarkupList.join('');\n        },\n\n        /**\n         * Render\n         * @returns {module:view/layout/resizeHandle} This object\n         */\n        render: function render() {\n          var headerHeight = this.dimensionModel.get('headerHeight');\n\n          var htmlStr = this._getResizeHandlerMarkup();\n\n          var styles = {\n            display: 'block'\n          };\n\n          if (this.frozenBorder) {\n            this.$el.addClass(classNameConst.FROZEN_BORDER_TOP);\n          } else {\n            _.extend(styles, {\n              marginTop: -headerHeight,\n              height: headerHeight\n            });\n          }\n\n          this.$el.empty().html(htmlStr).css(styles);\n\n          this._refreshHandlerPosition();\n\n          return this;\n        },\n\n        /**\n         * Refresh the position of every handler.\n         * @private\n         */\n        _refreshHandlerPosition: function _refreshHandlerPosition() {\n          var columnData = this._getColumnData();\n\n          var columnWidths = columnData.widths;\n          var $resizeHandleList = this.$el.find('.' + classNameConst.COLUMN_RESIZE_HANDLE);\n          var handlerWidthHalf = Math.floor(RESIZE_HANDLE_WIDTH / 2);\n          var curPos = 0;\n          var left = 0;\n          snippet.forEachArray($resizeHandleList, function (item, index) {\n            var $handler = $resizeHandleList.eq(index);\n\n            if (!this.frozenBorder) {\n              curPos += columnWidths[index] + CELL_BORDER_WIDTH;\n              left = curPos - handlerWidthHalf;\n            }\n\n            $handler.css('left', left);\n          }, this);\n        },\n\n        /**\n         * Event handler for the 'mousedown' event\n         * @param {MouseEvent} ev - mouse event\n         * @private\n         */\n        _onMouseDown: function _onMouseDown(ev) {\n          var $target = $(ev.target);\n          var columnWidths = this.coordColumnModel.getWidths(this.whichSide);\n          var columnIndex = parseInt($target.attr(attrNameConst.COLUMN_INDEX), 10);\n          this.dragEmitter.start(ev, {\n            width: columnWidths[columnIndex],\n            columnIndex: this._getHandlerColumnIndex(columnIndex),\n            pageX: ev.pageX\n          });\n        },\n\n        /**\n         * Event handler for dragmove event\n         * @param {module:event/gridEvent} ev - GridEvent\n         * @private\n         */\n        _onDragMove: function _onDragMove(ev) {\n          var startData = ev.startData;\n          var diff = ev.pageX - startData.pageX;\n          ev.setData({\n            columnIndex: startData.columnIndex,\n            width: startData.width + diff\n          });\n        },\n\n        /**\n         * Event handler for the 'dblclick' event\n         * @param {MouseEvent} mouseEvent - mouse event\n         * @private\n         */\n        _onDblClick: function _onDblClick(mouseEvent) {\n          var $target = $(mouseEvent.target);\n          var columnIndex = parseInt($target.attr(attrNameConst.COLUMN_INDEX), 10);\n          this.domEventBus.trigger('dblclick:resizeColumn', {\n            columnIndex: this._getHandlerColumnIndex(columnIndex)\n          });\n        },\n\n        /**\n         * Find the real index (based on visibility) of the column using index value of the handler and returns it.\n         * @param {number} index - index value of the handler\n         * @returns {number}\n         * @private\n         */\n        _getHandlerColumnIndex: function _getHandlerColumnIndex(index) {\n          return this.whichSide === frameConst.R ? index + this.columnModel.getVisibleFrozenCount(true) : index;\n        }\n      });\n      module.exports = ResizeHandle;\n      /***/\n    },\n    /* 50 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Class for the body layout\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var View = __webpack_require__(4);\n\n      var DragEventEmitter = __webpack_require__(40);\n\n      var GridEvent = __webpack_require__(16);\n\n      var util = __webpack_require__(17);\n\n      var constMap = __webpack_require__(10);\n\n      var classNameConst = __webpack_require__(19);\n\n      var frameConst = constMap.frame; // Minimum time (ms) to detect if an alert or confirm dialog has been displayed.\n\n      var MIN_INTERVAL_FOR_PAUSED = 200; // Minimum distance (pixel) to detect if user wants to drag when moving mouse with button pressed.\n\n      var MIN_DISATNCE_FOR_DRAG = 10;\n      /**\n       * Class for the body layout\n       * @module view/layout/body\n       * @extends module:base/view\n       * @param {Object} options - Options\n       * @param {String} [options.whichSide=R] L or R (which side)\n       * @ignore\n       */\n\n      var Body = View.extend(\n      /** @lends module:view/layout/body.prototype */\n      {\n        initialize: function initialize(options) {\n          View.prototype.initialize.call(this);\n\n          _.assign(this, {\n            dimensionModel: options.dimensionModel,\n            renderModel: options.renderModel,\n            viewFactory: options.viewFactory,\n            domEventBus: options.domEventBus,\n            // DIV for setting rendering position of entire child-nodes of $el.\n            $container: null,\n            whichSide: options && options.whichSide || frameConst.R\n          });\n\n          this.listenTo(this.dimensionModel, 'change:bodyHeight', this._onBodyHeightChange).listenTo(this.dimensionModel, 'change:totalRowHeight', this._resetContainerHeight).listenTo(this.renderModel, 'change:scrollTop', this._onScrollTopChange).listenTo(this.renderModel, 'change:scrollLeft', this._onScrollLeftChange);\n          this.dragEmitter = new DragEventEmitter({\n            type: 'body',\n            domEventBus: this.domEventBus,\n            onDragMove: _.bind(this._onDragMove, this)\n          });\n        },\n        className: classNameConst.BODY_AREA,\n        events: function events() {\n          var hash = {};\n          hash.scroll = '_onScroll';\n          hash['mousedown .' + classNameConst.BODY_CONTAINER] = '_onMouseDown';\n          return hash;\n        },\n\n        /**\n         * Event handler for 'change:bodyHeight' event on module:model/dimension\n         * @param {Object} model - changed model\n         * @param {Number} value - new height value\n         * @private\n         */\n        _onBodyHeightChange: function _onBodyHeightChange(model, value) {\n          this.$el.css('height', value + 'px');\n        },\n\n        /**\n         * Resets the height of a container DIV\n         * @private\n         */\n        _resetContainerHeight: function _resetContainerHeight() {\n          this.$container.css({\n            height: this.dimensionModel.get('totalRowHeight')\n          });\n        },\n\n        /**\n         * Event handler for 'scroll' event on DOM\n         * @param {UIEvent} event - event object\n         * @private\n         */\n        _onScroll: function _onScroll(event) {\n          var attrs = {\n            scrollTop: event.target.scrollTop\n          };\n\n          if (this.whichSide === frameConst.R) {\n            attrs.scrollLeft = event.target.scrollLeft;\n          }\n\n          this.renderModel.set(attrs);\n        },\n\n        /**\n         * Event handler for 'change:scrollLeft' event on module:model/renderer\n         * @param {Object} model - changed model\n         * @param {Number} value - new scrollLeft value\n         * @private\n         */\n        _onScrollLeftChange: function _onScrollLeftChange(model, value) {\n          if (this.whichSide === frameConst.R) {\n            this.el.scrollLeft = value;\n          }\n        },\n\n        /**\n         * Event handler for 'chage:scrollTop' event on module:model/renderer\n         * @param {Object} model - changed model instance\n         * @param {Number} value - new scrollTop value\n         * @private\n         */\n        _onScrollTopChange: function _onScrollTopChange(model, value) {\n          this.el.scrollTop = value;\n        },\n\n        /**\n         * Mousedown event handler\n         * @param {MouseEvent} ev - MouseEvent\n         * @private\n         */\n        _onMouseDown: function _onMouseDown(ev) {\n          var $target = $(ev.target);\n          var isTargetInput = $target.is('input, teaxarea');\n\n          if (!this._triggerPublicMousedown(ev)) {\n            return;\n          }\n\n          this._triggerBodyMousedown(ev);\n\n          if (isTargetInput && ev.shiftKey) {\n            ev.preventDefault();\n          }\n\n          if (util.isRightClickEvent(ev)) {\n            return;\n          }\n\n          if (!isTargetInput || ev.shiftKey) {\n            this.dragEmitter.start(ev, {\n              pageX: ev.pageX,\n              pageY: ev.pageY\n            });\n          }\n        },\n\n        /**\n         * Trigger mousedown event on domEventBus and returns the result\n         * @param {MouseEvent} ev - MouseEvent\n         * @returns {module:event/gridEvent}\n         * @private\n         */\n        _triggerPublicMousedown: function _triggerPublicMousedown(ev) {\n          var startTime, endTime;\n          var gridEvent = new GridEvent(ev, GridEvent.getTargetInfo($(ev.target)));\n          var result = true;\n\n          if (gridEvent.targetType === GridEvent.targetTypeConst.DUMMY) {\n            result = false;\n          } else {\n            startTime = new Date().getTime();\n            this.domEventBus.trigger('mousedown', gridEvent);\n\n            if (gridEvent.isStopped()) {\n              result = false;\n            } else {\n              // check if the model window (alert or confirm) was popped up\n              endTime = new Date().getTime();\n              result = endTime - startTime <= MIN_INTERVAL_FOR_PAUSED;\n            }\n          }\n\n          return result;\n        },\n\n        /**\n         * Trigger mousedown:body event on domEventBus\n         * @param {MouseEvent} ev - MouseEvent\n         * @private\n         */\n        _triggerBodyMousedown: function _triggerBodyMousedown(ev) {\n          var gridEvent = new GridEvent(ev, {\n            pageX: ev.pageX,\n            pageY: ev.pageY,\n            shiftKey: ev.shiftKey\n          });\n          this.domEventBus.trigger('mousedown:body', gridEvent);\n        },\n\n        /**\n         * Event handler for dragmove\n         * @param {event:module/gridEvent} gridEvent - GridEvent\n         */\n        _onDragMove: function _onDragMove(gridEvent) {\n          var startData = gridEvent.startData;\n          var currentData = {\n            pageX: gridEvent.pageX,\n            pageY: gridEvent.pageY\n          };\n\n          if (this._getMouseMoveDistance(startData, currentData) < MIN_DISATNCE_FOR_DRAG) {\n            gridEvent.stop();\n          }\n        },\n\n        /**\n         * Returns the distance between start position and current position.\n         * @param {{pageX:number, pageY:number}} start - start position\n         * @param {{pageX:number, pageY:number}} current - current position\n         * @returns {number}\n         * @private\n         */\n        _getMouseMoveDistance: function _getMouseMoveDistance(start, current) {\n          var dx = Math.abs(start.pageX - current.pageX);\n          var dy = Math.abs(start.pageY - current.pageY);\n          return Math.round(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)));\n        },\n\n        /**\n         * renders\n         * @returns {module:view/layout/body}\n         */\n        render: function render() {\n          var whichSide = this.whichSide;\n\n          this._destroyChildren();\n\n          if (!this.dimensionModel.get('scrollX')) {\n            this.$el.css('overflow-x', 'hidden');\n          }\n\n          if (!this.dimensionModel.get('scrollY') && whichSide === frameConst.R) {\n            this.$el.css('overflow-y', 'hidden');\n          }\n\n          this.$el.css('height', this.dimensionModel.get('bodyHeight'));\n          this.$container = $('<div>').addClass(classNameConst.BODY_CONTAINER);\n          this.$el.append(this.$container);\n\n          this._addChildren([this.viewFactory.createBodyTable(whichSide), this.viewFactory.createSelectionLayer(whichSide), this.viewFactory.createFocusLayer(whichSide)]);\n\n          this.$container.append(this._renderChildren());\n\n          this._resetContainerHeight();\n\n          return this;\n        }\n      });\n      module.exports = Body;\n      /***/\n    },\n    /* 51 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Class for the table layout in the body(data) area\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var View = __webpack_require__(4);\n\n      var constMap = __webpack_require__(10);\n\n      var classNameConst = __webpack_require__(19);\n\n      var CELL_BORDER_WIDTH = constMap.dimension.CELL_BORDER_WIDTH;\n      var ATTR_COLUMN_NAME = constMap.attrName.COLUMN_NAME;\n      /**\n       * Class for the table layout in the body(data) area\n       * @module view/layout/bodyTable\n       * @extends module:base/view\n       * @param {Object} options - Options\n       * @param {String} [options.whichSide='R'] L or R (which side)\n       * @ignore\n       */\n\n      var BodyTable = View.extend(\n      /** @lends module:view/layout/bodyTable.prototype */\n      {\n        initialize: function initialize(options) {\n          View.prototype.initialize.call(this);\n\n          _.assign(this, {\n            dimensionModel: options.dimensionModel,\n            coordColumnModel: options.coordColumnModel,\n            renderModel: options.renderModel,\n            columnModel: options.columnModel,\n            viewFactory: options.viewFactory,\n            painterManager: options.painterManager,\n            whichSide: options.whichSide || 'R'\n          });\n\n          this.listenTo(this.coordColumnModel, 'columnWidthChanged', this._onColumnWidthChanged); // To prevent issue of appearing vertical scrollbar when dummy rows exist\n\n          this.listenTo(this.renderModel, 'change:dummyRowCount', this._onChangeDummyRowCount);\n          this.listenTo(this.dimensionModel, 'change:bodyHeight', this._resetHeight);\n\n          this._attachAllTableEventHandlers();\n        },\n        className: classNameConst.BODY_TABLE_CONTAINER,\n        template: _.template('<table class=\"' + classNameConst.TABLE + '\">' + '   <colgroup><%=colGroup%></colgroup>' + '   <tbody><%=tbody%></tbody>' + '</table>'),\n        templateCol: _.template('<col <%=attrColumnName%>=\"<%=columnName%>\" style=\"width:<%=width%>px\">'),\n\n        /**\n         * Event handler for 'columnWidthChanged' event on a dimension model.\n         * @private\n         */\n        _onColumnWidthChanged: function _onColumnWidthChanged() {\n          var columnWidths = this.coordColumnModel.getWidths(this.whichSide);\n          var $colList = this.$el.find('col');\n\n          _.each(columnWidths, function (width, index) {\n            $colList.eq(index).css('width', width + CELL_BORDER_WIDTH);\n          }, this);\n        },\n\n        /**\n         * Event handler for 'change:dummyRowCount' event on the renderModel.\n         * @private\n         */\n        _onChangeDummyRowCount: function _onChangeDummyRowCount() {\n          this._resetOverflow();\n\n          this._resetHeight();\n        },\n\n        /**\n         * Resets the overflow of element based on the dummyRowCount in renderModel.\n         * @private\n         */\n        _resetOverflow: function _resetOverflow() {\n          var overflow = 'visible';\n\n          if (this.renderModel.get('dummyRowCount') > 0) {\n            overflow = 'hidden';\n          }\n\n          this.$el.css('overflow', overflow);\n        },\n\n        /**\n         * Resets the height of element based on the dummyRowCount in renderModel\n         * @private\n         */\n        _resetHeight: function _resetHeight() {\n          var dimensionModel = this.dimensionModel;\n\n          if (this.renderModel.get('dummyRowCount') > 0) {\n            this.$el.height(dimensionModel.get('bodyHeight') - dimensionModel.getScrollXHeight());\n          } else {\n            this.$el.css('height', '');\n          }\n        },\n\n        /**\n         * Reset position of a table container\n         * @param {number} top  조정할 top 위치 값\n         */\n        resetTablePosition: function resetTablePosition() {\n          this.$el.css('top', this.renderModel.get('top'));\n        },\n\n        /**\n         * Renders elements\n         * @returns {View.Layout.Body} This object\n         */\n        render: function render() {\n          this._destroyChildren();\n\n          this.$el.html(this.template({\n            colGroup: this._getColGroupMarkup(),\n            tbody: ''\n          }));\n\n          this._addChildren(this.viewFactory.createRowList({\n            bodyTableView: this,\n            el: this.$el.find('tbody'),\n            whichSide: this.whichSide\n          }));\n\n          this._renderChildren(); // To prevent issue of appearing vertical scrollbar when dummy rows exists\n\n\n          this._resetHeight();\n\n          this._resetOverflow();\n\n          return this;\n        },\n\n        /**\n         * 테이블 내부(TR,TD)에서 발생하는 이벤트를 this.el로 넘겨 해당 요소들에게 위임하도록 설정한다.\n         * @private\n         */\n        _attachAllTableEventHandlers: function _attachAllTableEventHandlers() {\n          var cellPainters = this.painterManager.getCellPainters();\n\n          _.each(cellPainters, function (painter) {\n            painter.attachEventHandlers(this.$el, '');\n          }, this);\n        },\n\n        /**\n         * table 요소를 새로 생성한다.\n         * (IE8-9에서 tbody의 innerHTML 변경할 수 없는 문제를 해결하여 성능개선을 하기 위해 사용)\n         * @param {string} tbodyHtml - tbody의 innerHTML 문자열\n         * @returns {jquery} - 새로 생성된 table의 tbody 요소\n         */\n        redrawTable: function redrawTable(tbodyHtml) {\n          this.$el[0].innerHTML = this.template({\n            colGroup: this._getColGroupMarkup(),\n            tbody: tbodyHtml\n          });\n          return this.$el.find('tbody');\n        },\n\n        /**\n         * Table 열 각각의 width 조정을 위한 columnGroup 마크업을 반환한다.\n         * @returns {string} <colgroup> 안에 들어갈 마크업 문자열\n         * @private\n         */\n        _getColGroupMarkup: function _getColGroupMarkup() {\n          var whichSide = this.whichSide;\n          var columnWidths = this.coordColumnModel.getWidths(whichSide);\n          var columns = this.columnModel.getVisibleColumns(whichSide, true);\n          var html = '';\n\n          _.each(columns, function (column, index) {\n            html += this.templateCol({\n              attrColumnName: ATTR_COLUMN_NAME,\n              columnName: column.name,\n              width: columnWidths[index] + CELL_BORDER_WIDTH\n            });\n          }, this);\n\n          return html;\n        }\n      });\n      module.exports = BodyTable;\n      /***/\n    },\n    /* 52 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Summary\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var View = __webpack_require__(4);\n\n      var classNameConst = __webpack_require__(19);\n\n      var constMap = __webpack_require__(10);\n\n      var frameConst = constMap.frame;\n      var ATTR_COLUMN_NAME = constMap.attrName.COLUMN_NAME;\n      var CELL_BORDER_WIDTH = constMap.dimension.CELL_BORDER_WIDTH;\n      /**\n       * Summary area\n       * @module view/layout/summary\n       * @extends module:base/view\n       * @param {Object} options - Options\n       * @ignore\n       */\n\n      var Summary = View.extend(\n      /** @lends module:view/layout/summary.prototype */\n      {\n        initialize: function initialize(options) {\n          /**\n           * L: Left, R: Right\n           * @type {string}\n           */\n          this.whichSide = options.whichSide; // models\n\n          this.columnModel = options.columnModel;\n          this.dimensionModel = options.dimensionModel;\n          this.coordColumnModel = options.coordColumnModel;\n          this.renderModel = options.renderModel;\n          this.summaryModel = options.summaryModel; // events\n\n          this.listenTo(this.renderModel, 'change:scrollLeft', this._onChangeScrollLeft);\n          this.listenTo(this.coordColumnModel, 'columnWidthChanged', this._onChangeColumnWidth);\n\n          if (this.summaryModel) {\n            this.listenTo(this.summaryModel, 'change', this._onChangeSummaryValue);\n          }\n        },\n        className: classNameConst.SUMMARY_AREA,\n        events: {\n          scroll: '_onScrollView'\n        },\n\n        /**\n         * template\n         */\n        template: _.template('<table class=\"<%=className%>\" style=\"height:<%=height%>px\">' + '<colgroup><%=colgroup%></colgroup>' + '<tbody><%=tbody%></tbody>' + '</table>'),\n\n        /**\n         * Template for <td>\n         */\n        templateBody: _.template('<td <%=attrColumnName%>=\"<%=columnName%>\" ' + 'class=\"<%=className%>\" ' + '>' + '<%=value%>' + '</td>'),\n\n        /**\n         * Template for <col>\n         */\n        templateColgroup: _.template('<col ' + '<%=attrColumnName%>=\"<%=columnName%>\" ' + 'style=\"width:<%=width%>px\">'),\n\n        /**\n         * Event handler for 'scroll' event\n         * @param {UIEvent} event - scroll event\n         * @private\n         */\n        _onScrollView: function _onScrollView(event) {\n          if (this.whichSide === frameConst.R) {\n            this.renderModel.set('scrollLeft', event.target.scrollLeft);\n          }\n        },\n\n        /**\n         * Sync scroll-left position with the value of body\n         * @param {Object} model - render model\n         * @param {Number} value - scrollLeft value\n         * @private\n         */\n        _onChangeScrollLeft: function _onChangeScrollLeft(model, value) {\n          if (this.whichSide === frameConst.R) {\n            this.el.scrollLeft = value;\n          }\n        },\n\n        /**\n         * Change column width\n         * @private\n         */\n        _onChangeColumnWidth: function _onChangeColumnWidth() {\n          var columnWidths = this.coordColumnModel.getWidths(this.whichSide);\n          var $ths = this.$el.find('col');\n\n          _.each(columnWidths, function (columnWidth, index) {\n            $ths.eq(index).css('width', columnWidth + CELL_BORDER_WIDTH);\n          });\n        },\n\n        /**\n         * Sets the HTML string of <td> of given column\n         * @param {string} columnName - column name\n         * @param {string} contents - HTML string\n         * @private\n         */\n        _setColumnContent: function _setColumnContent(columnName, contents) {\n          var $th = this.$el.find('td[' + ATTR_COLUMN_NAME + '=\"' + columnName + '\"]');\n          $th.html(contents);\n        },\n\n        /**\n         * Refresh <td> tag whenever summary value is changed.\n         * @param {string} columnName - column name\n         * @param {object} valueMap - value map\n         * @private\n         */\n        _onChangeSummaryValue: function _onChangeSummaryValue(columnName, valueMap) {\n          var contents = this._generateValueHTML(columnName, valueMap);\n\n          this._setColumnContent(columnName, contents);\n        },\n\n        /**\n         * Generates a HTML string of column summary value and returns it.\n         * @param {object} columnName - column name\n         * @param {object} valueMap - value map\n         * @returns {string} HTML string\n         * @private\n         */\n        _generateValueHTML: function _generateValueHTML(columnName, valueMap) {\n          var template = this.summaryModel.getTemplate(columnName);\n          var html = '';\n\n          if (_.isFunction(template)) {\n            html = template(valueMap);\n          } else if (_.isString(template)) {\n            html = template;\n          }\n\n          return html;\n        },\n\n        /**\n         * Generates a HTML string of <colgroup> and returns it\n         * @returns {string} - HTML String\n         * @private\n         */\n        _generateColgroupHTML: function _generateColgroupHTML() {\n          var columns = this.columnModel.getVisibleColumns(this.whichSide, true);\n          var columnWidths = this.coordColumnModel.getWidths(this.whichSide);\n          var htmlList = [];\n\n          _.each(columnWidths, function (width, index) {\n            htmlList.push(this.templateColgroup({\n              attrColumnName: ATTR_COLUMN_NAME,\n              columnName: columns[index].name,\n              width: width + CELL_BORDER_WIDTH\n            }));\n          }, this);\n\n          return htmlList.join('');\n        },\n\n        /**\n         * Generates a HTML string of <tbody> and returns it\n         * @returns {string} - HTML String\n         * @private\n         */\n        _generateTbodyHTML: function _generateTbodyHTML() {\n          var summaryModel = this.summaryModel;\n          var columns = this.columnModel.getVisibleColumns(this.whichSide, true);\n          return _.reduce(columns, function (memo, column) {\n            var columnName = column.name;\n            var valueMap;\n\n            if (summaryModel) {\n              valueMap = summaryModel.getValue(column.name);\n            }\n\n            return memo + this.templateBody({\n              attrColumnName: ATTR_COLUMN_NAME,\n              columnName: columnName,\n              className: [classNameConst.CELL, classNameConst.CELL_SUMMARY].join(' '),\n              value: this._generateValueHTML(columnName, valueMap)\n            });\n          }, '', this);\n        },\n\n        /**\n         * Render\n         * @returns {object}\n         */\n        render: function render() {\n          var summaryHeight = this.dimensionModel.get('summaryHeight');\n\n          if (summaryHeight) {\n            this.$el.html(this.template({\n              className: classNameConst.TABLE,\n              height: summaryHeight,\n              tbody: this._generateTbodyHTML(),\n              colgroup: this._generateColgroupHTML()\n            }));\n          }\n\n          return this;\n        }\n      });\n      module.exports = Summary;\n      /***/\n    },\n    /* 53 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview RowList View\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var View = __webpack_require__(4);\n\n      var constMap = __webpack_require__(10);\n\n      var classNameConst = __webpack_require__(19);\n\n      var attrNameConst = constMap.attrName;\n      var frameConst = constMap.frame;\n      var CELL_BORDER_WIDTH = constMap.dimension.CELL_BORDER_WIDTH;\n      /**\n       * RowList View\n       * @module view/rowList\n       * @extends module:baes/view\n       * @param {object} options - Options\n       * @param {string} [options.whichSide='R']   어느 영역에 속하는 rowList 인지 여부. 'L|R' 중 하나를 지정한다.\n       * @ignore\n       */\n\n      var RowList = View.extend(\n      /** @lends module:view/rowList.prototype */\n      {\n        initialize: function initialize(options) {\n          var focusModel = options.focusModel;\n          var renderModel = options.renderModel;\n          var selectionModel = options.selectionModel;\n          var coordRowModel = options.coordRowModel;\n          var dataModel = options.dataModel;\n          var whichSide = options.whichSide || 'R';\n\n          _.assign(this, {\n            whichSide: whichSide,\n            bodyTableView: options.bodyTableView,\n            focusModel: focusModel,\n            renderModel: renderModel,\n            selectionModel: selectionModel,\n            coordRowModel: coordRowModel,\n            dataModel: dataModel,\n            columnModel: options.columnModel,\n            collection: renderModel.getCollection(whichSide),\n            painterManager: options.painterManager,\n            sortOptions: null,\n            renderedRowKeys: null\n          });\n\n          this.listenTo(this.collection, 'change', this._onModelChange).listenTo(this.collection, 'restore', this._onModelRestore).listenTo(focusModel, 'change:rowKey', this._refreshFocusedRow).listenTo(renderModel, 'rowListChanged', this.render);\n\n          if (this.whichSide === frameConst.L) {\n            this.listenTo(focusModel, 'change:rowKey', this._refreshSelectedMetaColumns).listenTo(selectionModel, 'change:range', this._refreshSelectedMetaColumns).listenTo(renderModel, 'rowListChanged', this._refreshSelectedMetaColumns);\n          }\n        },\n\n        /**\n         * Returns the list of column models in it's own side\n         * @returns {Array} - Column model list\n         */\n        _getColumns: function _getColumns() {\n          return this.columnModel.getVisibleColumns(this.whichSide, true);\n        },\n\n        /**\n         * 기존에 생성되어 있던 TR요소들 중 새로 렌더링할 데이터와 중복되지 않은 목록의 TR요소만 삭제한다.\n         * @param {array} dupRowKeys 중복된 데이터의 rowKey 목록\n         */\n        _removeOldRows: function _removeOldRows(dupRowKeys) {\n          var firstIdx = _.indexOf(this.renderedRowKeys, dupRowKeys[0]);\n\n          var lastIdx = _.indexOf(this.renderedRowKeys, _.last(dupRowKeys));\n\n          var $rows = this.$el.children('tr');\n          $rows.slice(0, firstIdx).remove();\n          $rows.slice(lastIdx + 1).remove();\n        },\n\n        /**\n         * 기존의 렌더링된 데이터와 중복되지 않은 목록에 대해서만 TR요소를 추가한다.\n         * @param {array} rowKeys 렌더링할 데이터의 rowKey 목록\n         * @param {array} dupRowKeys 중복된 데이터의 rowKey 목록\n         */\n        _appendNewRows: function _appendNewRows(rowKeys, dupRowKeys) {\n          var beforeRows = this.collection.slice(0, _.indexOf(rowKeys, dupRowKeys[0]));\n          var afterRows = this.collection.slice(_.indexOf(rowKeys, _.last(dupRowKeys)) + 1);\n          this.$el.prepend(this._getRowsHtml(beforeRows));\n          this.$el.append(this._getRowsHtml(afterRows));\n        },\n\n        /**\n         * Redraw all rows.\n         * @private\n         */\n        _resetRows: function _resetRows() {\n          var html = this._getRowsHtml(this.collection.models);\n\n          var $tbody;\n\n          if (RowList.isInnerHtmlOfTbodyReadOnly) {\n            $tbody = this.bodyTableView.redrawTable(html);\n            this.setElement($tbody, false); // table이 다시 생성되었기 때문에 tbody의 참조를 갱신해준다.\n          } else {\n            // As using a compatibility mode in IE makes it hard to detect the actual version of the browser,\n            // use try/catch block to make in correct.\n            try {\n              this.$el[0].innerHTML = html;\n            } catch (e) {\n              RowList.isInnerHtmlOfTbodyReadOnly = true;\n\n              this._resetRows();\n            }\n          }\n        },\n\n        /**\n         * 행데이터 목록을 받아, HTML 문자열을 생성해서 반환한다.\n         * @param {Model.Row[]} rows - 행데이터 목록\n         * @returns {string} 생성된 HTML 문자열\n         */\n        _getRowsHtml: function _getRowsHtml(rows) {\n          var rowPainter = this.painterManager.getRowPainter();\n\n          var columnNames = _.pluck(this._getColumns(), 'name');\n\n          var hasTreeColumn = this.columnModel.hasTreeColumn();\n          return _.map(rows, function (row) {\n            return rowPainter.generateHtml(row, columnNames, hasTreeColumn);\n          }).join('');\n        },\n\n        /**\n         * Returns a TR element of given rowKey\n         * @param {(string|number)} rowKey - rowKey\n         * @returns {jquery}\n         * @private\n         */\n        _getRowElement: function _getRowElement(rowKey) {\n          return this.$el.find('tr[' + attrNameConst.ROW_KEY + '=' + rowKey + ']');\n        },\n\n        /**\n         * Refreshes 'selected' class of meta columns.\n         * @private\n         */\n        _refreshSelectedMetaColumns: function _refreshSelectedMetaColumns() {\n          var $rows = this.$el.find('tr');\n          var metaSelector = '.' + classNameConst.CELL_ROW_HEAD;\n          var filteredRowList;\n\n          if (this.selectionModel.hasSelection()) {\n            filteredRowList = this._filterRowsByIndexRange($rows, this.selectionModel.get('range').row);\n          } else {\n            filteredRowList = this._filterRowByKey($rows, this.focusModel.get('rowKey'));\n          }\n\n          $rows.find(metaSelector).removeClass(classNameConst.CELL_SELECTED);\n\n          _.each(filteredRowList, function ($row) {\n            $row.find(metaSelector).addClass(classNameConst.CELL_SELECTED);\n          });\n        },\n\n        /**\n         * Filters the rows by given range(index) and returns them.\n         * @param {jQuery} $rows - rows (tr elements)\n         * @param {Array.<Number>} rowRange - [startIndex, endIndex]\n         * @returns {Array.<jQuery>}\n         * @private\n         */\n        _filterRowsByIndexRange: function _filterRowsByIndexRange($rows, rowRange) {\n          var index = rowRange[0];\n          var len = rowRange[1] + 1;\n          var rowList = [];\n          var rowKey;\n\n          for (; index < len; index += 1) {\n            if (this.coordRowModel.getHeightAt(index)) {\n              rowKey = this.dataModel.at(index).get('rowKey');\n              rowList.push(this._getRowElement(rowKey));\n            }\n          }\n\n          return rowList;\n        },\n\n        /**\n         * Filters the row by given rowKey\n         * @param {jQuery} $rows - rows (tr elements)\n         * @param {Number} rowKey - rowKey\n         * @returns {Array.<jQuery>}\n         * @private\n         */\n        _filterRowByKey: function _filterRowByKey($rows, rowKey) {\n          var rowIndex = this.dataModel.indexOfRowKey(rowKey);\n          var renderStartIndex = this.renderModel.get('startIndex');\n          var rowList = [];\n\n          if (renderStartIndex > rowIndex) {\n            return rowList;\n          }\n\n          return rowList.push($rows.eq(rowIndex - renderStartIndex));\n        },\n\n        /**\n         * Removes the CURRENT_ROW class from the cells in the previously focused row and\n         * adds it to the cells in the currently focused row.\n         * @private\n         */\n        _refreshFocusedRow: function _refreshFocusedRow() {\n          var rowKey = this.focusModel.get('rowKey');\n          var prevRowKey = this.focusModel.get('prevRowKey');\n\n          this._setFocusedRowClass(prevRowKey, false);\n\n          this._setFocusedRowClass(rowKey, true);\n        },\n\n        /**\n         * Finds all cells in the row indentified by given rowKey and toggles the CURRENT_ROW on them.\n         * @param {Number|String} rowKey - rowKey\n         * @param {Boolean} focused - if set to true, the class will be added, otherwise be removed.\n         * @private\n         */\n        _setFocusedRowClass: function _setFocusedRowClass(rowKey, focused) {\n          var columnNames = _.pluck(this._getColumns(), 'name');\n\n          var trMap = {};\n\n          _.each(columnNames, function (columnName) {\n            var mainRowKey = this.dataModel.getMainRowKey(rowKey, columnName),\n                $td;\n\n            if (!trMap[mainRowKey]) {\n              trMap[mainRowKey] = this._getRowElement(mainRowKey);\n            }\n\n            $td = trMap[mainRowKey].find('td[' + attrNameConst.COLUMN_NAME + '=\"' + columnName + '\"]');\n            $td.toggleClass(classNameConst.CELL_CURRENT_ROW, focused);\n          }, this);\n        },\n\n        /**\n         * Renders.\n         * @param {boolean} dataListChanged - 데이터 목록이 변경된 경우(add, remove..) true, 아니면(스크롤 변경 등) false\n         * @returns {View.RowList} this 객체\n         */\n        render: function render(dataListChanged) {\n          var rowKeys = this.collection.pluck('rowKey');\n          var dupRowKeys;\n          this.bodyTableView.resetTablePosition();\n\n          if (dataListChanged) {\n            this._resetRows();\n          } else {\n            dupRowKeys = _.intersection(rowKeys, this.renderedRowKeys);\n\n            if (_.isEmpty(rowKeys) || _.isEmpty(dupRowKeys) || // 중복된 데이터가 70% 미만일 경우에는 성능을 위해 innerHTML을 사용.\n            dupRowKeys.length / rowKeys.length < 0.7) {\n              // eslint-disable-line no-magic-numbers\n              this._resetRows();\n            } else {\n              this._removeOldRows(dupRowKeys);\n\n              this._appendNewRows(rowKeys, dupRowKeys);\n            }\n          }\n\n          this.renderedRowKeys = rowKeys;\n          return this;\n        },\n\n        /**\n         * modelChange 이벤트 발생시 실행되는 핸들러 함수.\n         * @param {Model.Row} model Row 모델 객체\n         * @private\n         */\n        _onModelChange: function _onModelChange(model) {\n          var rowKey = model.get('rowKey');\n\n          var $tr = this._getRowElement(rowKey);\n\n          if ('height' in model.changed) {\n            $tr.css('height', model.get('height') + CELL_BORDER_WIDTH);\n          } else {\n            this.painterManager.getRowPainter().refresh(model.changed, $tr);\n            this.coordRowModel.syncWithDom();\n          }\n        },\n\n        /**\n         * Event handler for 'restore' event on module:model/row\n         * @param {Object} cellData - CellData\n         * @private\n         */\n        _onModelRestore: function _onModelRestore(cellData) {\n          var $td = this.dataModel.getElement(cellData.rowKey, cellData.columnName);\n          var editType = this.columnModel.getEditType(cellData.columnName);\n          this.painterManager.getCellPainter(editType).refresh(cellData, $td);\n          this.coordRowModel.syncWithDom();\n        }\n      }, {\n        /**\n         * Whether the innerHTML property of a tbody element is readonly.\n         * @memberof RowList\n         * @static\n         */\n        isInnerHtmlOfTbodyReadOnly: snippet.browser.msie && snippet.browser.version <= 9 // eslint-disable-line no-magic-numbers\n\n      });\n      module.exports = RowList;\n      /***/\n    },\n    /* 54 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Class for the selection layer\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var View = __webpack_require__(4);\n\n      var classNameConst = __webpack_require__(19);\n\n      var CELL_BORDER_WIDTH = __webpack_require__(10).dimension.CELL_BORDER_WIDTH;\n\n      var frameConst = __webpack_require__(10).frame;\n      /**\n       * Class for the selection layer\n       * @module view/selectionLayer\n       * @extends module:base/view\n       * @param {object} options Options\n       * @ignore\n       */\n\n\n      var SelectionLayer = View.extend(\n      /** @lends module:view/selectionLayer.prototype */\n      {\n        initialize: function initialize(options) {\n          _.assign(this, {\n            whichSide: options.whichSide || frameConst.R,\n            dimensionModel: options.dimensionModel,\n            coordRowModel: options.coordRowModel,\n            coordColumnModel: options.coordColumnModel,\n            columnModel: options.columnModel,\n            selectionModel: options.selectionModel\n          });\n\n          this._updateColumnWidths();\n\n          this.listenTo(this.coordColumnModel, 'columnWidthChanged', this._onChangeColumnWidth);\n          this.listenTo(this.selectionModel, 'change:range', this.render);\n        },\n        className: classNameConst.LAYER_SELECTION,\n\n        /**\n         * Updates this.columnWidths\n         * @private\n         */\n        _updateColumnWidths: function _updateColumnWidths() {\n          this.columnWidths = this.coordColumnModel.getWidths(this.whichSide);\n        },\n\n        /**\n         * Event handler for 'columnWidthChanged' evnet on Dimension model.\n         * @private\n         */\n        _onChangeColumnWidth: function _onChangeColumnWidth() {\n          this._updateColumnWidths();\n\n          this.render();\n        },\n\n        /**\n         * Returns relative column range based on 'this.whichSide'\n         * @private\n         * @param {array} columnRange - Column range indexes. [start, end]\n         * @returns {array} - Relative column range indexes. [start, end]\n         */\n        _getOwnSideColumnRange: function _getOwnSideColumnRange(columnRange) {\n          var frozenCount = this.columnModel.getVisibleFrozenCount();\n          var ownColumnRange = null;\n\n          if (this.whichSide === frameConst.L) {\n            if (columnRange[0] < frozenCount) {\n              ownColumnRange = [columnRange[0], Math.min(columnRange[1], frozenCount - 1)];\n            }\n          } else if (columnRange[1] >= frozenCount) {\n            ownColumnRange = [Math.max(columnRange[0], frozenCount) - frozenCount, columnRange[1] - frozenCount];\n          }\n\n          return ownColumnRange;\n        },\n\n        /**\n         * Returns the object containing 'top' and 'height' css value.\n         * @private\n         * @param  {array} rowRange - Row range indexes. [start, end]\n         * @returns {{top: string, height: string}} - css values\n         */\n        _getVerticalStyles: function _getVerticalStyles(rowRange) {\n          var coordRowModel = this.coordRowModel;\n          var top = coordRowModel.getOffsetAt(rowRange[0]);\n          var bottom = coordRowModel.getOffsetAt(rowRange[1]) + coordRowModel.getHeightAt(rowRange[1]);\n          return {\n            top: top + 'px',\n            height: bottom - top + 'px'\n          };\n        },\n\n        /**\n         * Returns the object containing 'left' and 'width' css value.\n         * @private\n         * @param  {array} columnRange - Column range indexes. [start, end]\n         * @returns {{left: string, width: string}} - css values\n         */\n        _getHorizontalStyles: function _getHorizontalStyles(columnRange) {\n          var columnWidths = this.columnWidths;\n          var metaColumnCount = this.columnModel.getVisibleMetaColumnCount();\n          var startIndex = columnRange[0];\n          var endIndex = columnRange[1];\n          var left = 0;\n          var width = 0;\n          var i = 0;\n\n          if (this.whichSide === frameConst.L) {\n            startIndex += metaColumnCount;\n            endIndex += metaColumnCount;\n          }\n\n          endIndex = Math.min(endIndex, columnWidths.length - 1);\n\n          for (; i <= endIndex; i += 1) {\n            if (i < startIndex) {\n              left += columnWidths[i] + CELL_BORDER_WIDTH;\n            } else {\n              width += columnWidths[i] + CELL_BORDER_WIDTH;\n            }\n          }\n\n          width -= CELL_BORDER_WIDTH; // subtract last border width\n\n          return {\n            left: left + 'px',\n            width: width + 'px'\n          };\n        },\n\n        /**\n         * Render.\n         * @returns {SelectionLayer} this object\n         */\n        render: function render() {\n          var range = this.selectionModel.get('range');\n          var styles, columnRange;\n\n          if (range) {\n            columnRange = this._getOwnSideColumnRange(range.column);\n          }\n\n          if (columnRange) {\n            styles = _.assign({}, this._getVerticalStyles(range.row), this._getHorizontalStyles(columnRange));\n            this.$el.show().css(styles);\n          } else {\n            this.$el.hide();\n          }\n\n          return this;\n        }\n      });\n      module.exports = SelectionLayer;\n      /***/\n    },\n    /* 55 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Layer class that represents the state of rendering phase\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var View = __webpack_require__(4);\n\n      var CELL_BORDER_WIDTH = __webpack_require__(10).dimension.CELL_BORDER_WIDTH;\n\n      var attrNameConst = __webpack_require__(10).attrName;\n\n      var classNameConst = __webpack_require__(19);\n      /**\n       * Layer class that represents the state of rendering phase.\n       * @module view/editingLayer\n       * @extends module:base/view\n       * @param {Object} options - Options\n       * @ignore\n       */\n\n\n      var EditingLayer = View.extend(\n      /** @lends module:view/editingLayer.prototype */\n      {\n        initialize: function initialize(options) {\n          this.renderModel = options.renderModel;\n          this.domState = options.domState;\n          this.inputPainters = options.inputPainters;\n          this.listenTo(this.renderModel, 'editingStateChanged', this._onEditingStateChanged);\n        },\n        className: classNameConst.LAYER_EDITING + ' ' + classNameConst.CELL_CONTENT,\n\n        /**\n         * Starts editing the given cell.\n         * @param {Object} cellData - cell data\n         * @private\n         */\n        _startEditing: function _startEditing(cellData) {\n          var rowKey = cellData.rowKey;\n          var columnName = cellData.columnName;\n          var editType = snippet.pick(cellData, 'columnModel', 'editOptions', 'type');\n\n          var styleMap = this._calculateLayoutStyle(rowKey, columnName, this._isWidthExpandable(editType));\n\n          var painter = this.inputPainters[editType];\n          this.$el.html(painter.generateHtml(cellData)).attr(attrNameConst.ROW_KEY, rowKey).attr(attrNameConst.COLUMN_NAME, columnName).css(styleMap).show();\n\n          this._adjustLeftPosition();\n\n          painter.focus(this.$el);\n        },\n\n        /**\n         * Returns whether the width is expandable.\n         * @param {String} editType - edit type\n         * @returns {Boolean}\n         * @private\n         */\n        _isWidthExpandable: function _isWidthExpandable(editType) {\n          return _.contains(['checkbox', 'radio'], editType);\n        },\n\n        /**\n         * Fisishes editing the current cell.\n         * @private\n         */\n        _finishEditing: function _finishEditing() {\n          this.$el.empty().hide();\n        },\n\n        /**\n         * Adjust the left position of the layer not to lay beyond the boundary of the grid.\n         * @private\n         */\n        _adjustLeftPosition: function _adjustLeftPosition() {\n          var gridWidth = this.domState.getWidth();\n          var layerWidth = this.$el.outerWidth();\n          var layerLeftPos = this.$el.position().left;\n\n          if (layerLeftPos + layerWidth > gridWidth) {\n            this.$el.css('left', gridWidth - layerWidth);\n          }\n        },\n\n        /**\n         * Adjust offset value of TD, because it varies from browsers to browsers when borders are callapsed.\n         * @param {Number} offsetValue - offset value (offset.top or offset.left)\n         * @returns {Number}\n         * @private\n         */\n        _adjustCellOffsetValue: function _adjustCellOffsetValue(offsetValue) {\n          var browser = snippet.browser;\n          var result = offsetValue;\n\n          if (browser.msie) {\n            if (browser.version === 9) {\n              result = offsetValue - 1;\n            } else if (browser.version > 9) {\n              result = Math.floor(offsetValue);\n            }\n          }\n\n          return result;\n        },\n\n        /**\n         * Calculates the position and the dimension of the layer and returns the object that contains css properties.\n         * @param {Stirng} rowKey - row key\n         * @param {String} columnName - column name\n         * @param {Boolean} expandable - true if the width of layer is expandable\n         * @returns {Object}\n         * @private\n         */\n        _calculateLayoutStyle: function _calculateLayoutStyle(rowKey, columnName, expandable) {\n          var wrapperOffset = this.domState.getOffset();\n          var $cell = this.domState.getElement(rowKey, columnName);\n          var cellOffset = $cell.offset();\n          var cellHeight = $cell.outerHeight() + CELL_BORDER_WIDTH;\n          var cellWidth = $cell.outerWidth() + CELL_BORDER_WIDTH;\n          return {\n            top: this._adjustCellOffsetValue(cellOffset.top) - wrapperOffset.top,\n            left: this._adjustCellOffsetValue(cellOffset.left) - wrapperOffset.left,\n            height: cellHeight,\n            minWidth: expandable ? cellWidth : '',\n            width: expandable ? '' : cellWidth,\n            lineHeight: cellHeight + 'px'\n          };\n        },\n\n        /**\n         * Event handler for 'editingStateChanged' event on the render model.\n         * @param {Object} cellData - cell data\n         * @private\n         */\n        _onEditingStateChanged: function _onEditingStateChanged(cellData) {\n          if (cellData.editing) {\n            this._startEditing(cellData);\n          } else {\n            this._finishEditing();\n          }\n        },\n\n        /**\n         * Render\n         * @returns {Object} this instance\n         */\n        render: function render() {\n          _.each(this.inputPainters, function (painter) {\n            painter.attachEventHandlers(this.$el, '');\n          }, this);\n\n          return this;\n        }\n      });\n      module.exports = EditingLayer;\n      /***/\n    },\n    /* 56 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Layer View class which contains the 'tui-date-picker'\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var DatePicker = __webpack_require__(34);\n\n      var View = __webpack_require__(4);\n\n      var classNameConst = __webpack_require__(19);\n\n      var DEFAULT_DATE_FORMAT = 'yyyy-MM-dd';\n      var FULL_RANGES = [[new Date(1900, 0, 1), new Date(2999, 11, 31)]];\n      var DatePickerLayer;\n      /**\n       * Layer View class which contains the 'tui-date-picker'\n       * @module view/datePickerLayer\n       * @extends module:base/view\n       * @param {Object} options - Options\n       * @ignore\n       */\n\n      DatePickerLayer = View.extend(\n      /** @lends module:view/datePickerLayer.prototype */\n      {\n        initialize: function initialize(options) {\n          this.focusModel = options.focusModel;\n          this.textPainter = options.textPainter;\n          this.columnModel = options.columnModel;\n          this.domState = options.domState;\n          this.usageStatistics = options.usageStatistics;\n          this.datePickerMap = this._createDatePickers();\n          /**\n           * Current focused input element\n           * @type {jQuery}\n           */\n\n          this.$focusedInput = null;\n          this.listenTo(this.textPainter, 'focusIn', this._onFocusInTextInput);\n          this.listenTo(options.domEventBus, 'windowResize', this._closeDatePickerLayer);\n        },\n        className: classNameConst.LAYER_DATE_PICKER,\n        events: {\n          click: '_onClick'\n        },\n\n        /**\n         * Event handler for the 'click' event on the datepicker layer.\n         * @param {MouseEvent} ev - MouseEvent object\n         * @private\n         */\n        _onClick: function _onClick(ev) {\n          ev.stopPropagation();\n        },\n\n        /**\n         * Creates instances map of 'tui-date-picker'\n         * @returns {Object.<string, DatePicker>}\n         * @private\n         */\n        _createDatePickers: function _createDatePickers() {\n          var datePickerMap = {};\n          var columnModelMap = this.columnModel.get('columnModelMap');\n\n          _.each(columnModelMap, function (columnModel) {\n            var name = columnModel.name;\n            var component = columnModel.component;\n            var options;\n\n            if (component && component.name === 'datePicker') {\n              options = _.extend({\n                usageStatistics: this.usageStatistics\n              }, component.options);\n              datePickerMap[name] = new DatePicker(this.$el, options);\n\n              this._bindEventOnDatePicker(datePickerMap[name]);\n            }\n          }, this);\n\n          return datePickerMap;\n        },\n\n        /**\n         * Bind custom event on the DatePicker instance\n         * @param {DatePicker} datePicker - instance of DatePicker\n         * @private\n         */\n        _bindEventOnDatePicker: function _bindEventOnDatePicker(datePicker) {\n          var self = this;\n          datePicker.on('open', function () {\n            self.textPainter.blockFocusingOut();\n          });\n          datePicker.on('close', function () {\n            var focusModel = self.focusModel;\n            var address = focusModel.which();\n            var rowKey = address.rowKey;\n            var columnName = address.columnName;\n            var changedValue = self.$focusedInput.val();\n            self.textPainter.unblockFocusingOut(); // when the datePicker layer is closed, selected date must set on input element.\n\n            if (focusModel.isEditingCell(rowKey, columnName)) {\n              focusModel.dataModel.setValue(rowKey, columnName, changedValue);\n            }\n\n            focusModel.finishEditing();\n          });\n        },\n\n        /**\n         * Resets date picker options\n         * @param {Object} options - datePicker options\n         * @param {jQuery} $input - target input element\n         * @param {string} columnName - name to find the DatePicker instance created on each column\n         * @private\n         */\n        _resetDatePicker: function _resetDatePicker(options, $input, columnName) {\n          var datePicker = this.datePickerMap[columnName];\n          var format = options.format || DEFAULT_DATE_FORMAT;\n          var date = options.date || new Date();\n          var selectableRanges = options.selectableRanges;\n          datePicker.setInput($input, {\n            format: format,\n            syncFromInput: true\n          });\n\n          if (selectableRanges) {\n            datePicker.setRanges(selectableRanges);\n          } else {\n            datePicker.setRanges(FULL_RANGES);\n          }\n\n          if ($input.val() === '') {\n            datePicker.setDate(date);\n            $input.val('');\n          }\n        },\n\n        /**\n         * Calculates the position of the layer and returns the object that contains css properties.\n         * @param {jQuery} $input - input element\n         * @returns {Object}\n         * @private\n         */\n        _calculatePosition: function _calculatePosition($input) {\n          var inputOffset = $input.offset();\n          var inputHeight = $input.outerHeight();\n          var wrapperOffset = this.domState.getOffset();\n          return {\n            top: inputOffset.top - wrapperOffset.top + inputHeight,\n            left: inputOffset.left - wrapperOffset.left\n          };\n        },\n\n        /**\n         * Event handler for 'focusIn' event of module:painter/input/text\n         * @param {jQuery} $input - target input element\n         * @param {{rowKey: String, columnName: String}} address - target cell address\n         * @private\n         */\n        _onFocusInTextInput: function _onFocusInTextInput($input, address) {\n          var columnName = address.columnName;\n          var component = this.columnModel.getColumnModel(columnName).component;\n          var editType = this.columnModel.getEditType(columnName);\n          var options;\n\n          if (editType === 'text' && component && component.name === 'datePicker') {\n            options = component.options || {};\n            this.$focusedInput = $input;\n            this.$el.css(this._calculatePosition($input)).show();\n\n            this._resetDatePicker(options, $input, columnName);\n\n            this.datePickerMap[columnName].open();\n          }\n        },\n\n        /**\n         * Close the date picker layer that is already opend\n         * @private\n         */\n        _closeDatePickerLayer: function _closeDatePickerLayer() {\n          var name = this.focusModel.which().columnName;\n          var datePicker = this.datePickerMap[name];\n\n          if (datePicker && datePicker.isOpened()) {\n            datePicker.close();\n          }\n        },\n\n        /**\n         * Render\n         * @returns {Object} this object\n         */\n        render: function render() {\n          this.$el.hide();\n          return this;\n        }\n      });\n      module.exports = DatePickerLayer;\n      /***/\n    },\n    /* 57 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Class for the layer view that represents the currently focused cell\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var View = __webpack_require__(4);\n\n      var constMap = __webpack_require__(10);\n\n      var classNameConst = __webpack_require__(19);\n\n      var frameConst = constMap.frame;\n      var CELL_BORDER_WIDTH = constMap.dimension.CELL_BORDER_WIDTH;\n      var HTML_BORDER_DIV = '<div class=\"' + classNameConst.LAYER_FOCUS_BORDER + '\"></div>';\n      var BLUR_CLASS_NAME = classNameConst.LAYER_FOCUS_DEACTIVE;\n      /**\n       * Class for the layer view that represents the currently focused cell\n       * @module view/focusLayer\n       * @extends module:base/view\n       * @param {Object} options - Options\n       * @ignore\n       */\n\n      var FocusLayer = View.extend(\n      /** @lends module:view/focusLayer.prototype */\n      {\n        initialize: function initialize(options) {\n          this.focusModel = options.focusModel;\n          this.columnModel = options.columnModel;\n          this.coordRowModel = options.coordRowModel;\n          this.coordColumnModel = options.coordColumnModel;\n          this.coordConverterModel = options.coordConverterModel;\n          this.whichSide = options.whichSide;\n          this.borderEl = {\n            $top: $(HTML_BORDER_DIV),\n            $left: $(HTML_BORDER_DIV),\n            $right: $(HTML_BORDER_DIV),\n            $bottom: $(HTML_BORDER_DIV)\n          };\n          this.listenTo(this.coordColumnModel, 'columnWidthChanged', this._refreshCurrentLayout);\n          this.listenTo(this.coordRowModel, 'reset', this._refreshCurrentLayout);\n          this.listenTo(this.focusModel, 'blur', this._onBlur);\n          this.listenTo(this.focusModel, 'focus', this._onFocus);\n          this.listenTo(this.focusModel, 'change:active', this._onChangeActiveState);\n        },\n        className: classNameConst.LAYER_FOCUS,\n\n        /**\n         * Refresh the layout of current layer\n         * @private\n         */\n        _refreshCurrentLayout: function _refreshCurrentLayout() {\n          var focusModel = this.focusModel;\n\n          if (this.$el.css('display') !== 'none') {\n            this._refreshBorderLayout(focusModel.get('rowKey'), focusModel.get('columnName'));\n          }\n        },\n\n        /**\n         * Event handler for 'blur' event on the module:model/focus\n         * @private\n         */\n        _onBlur: function _onBlur() {\n          this.$el.hide();\n        },\n\n        /**\n         * Event handler for 'focus' event on module:model/focus\n         * @param {Number} rowKey - target row key\n         * @param {String} columnName - target column name\n         * @private\n         */\n        _onFocus: function _onFocus(rowKey, columnName) {\n          var targetSide = this.columnModel.isLside(columnName) ? frameConst.L : frameConst.R;\n\n          if (targetSide === this.whichSide) {\n            this._refreshBorderLayout(rowKey, columnName);\n\n            this.$el.show();\n          }\n        },\n\n        /**\n         * Event handler for 'change:active' event on module:model/focus\n         * @param {object} model - Focus model\n         * @private\n         */\n        _onChangeActiveState: function _onChangeActiveState(model) {\n          if (!model.changed.active) {\n            this.$el.addClass(BLUR_CLASS_NAME);\n          } else {\n            this.$el.removeClass(BLUR_CLASS_NAME);\n          }\n        },\n\n        /**\n         * Resets the position and the dimension of the layer.\n         * @param {Number} rowKey - row key\n         * @param {String} columnName - column name\n         * @private\n         */\n        _refreshBorderLayout: function _refreshBorderLayout(rowKey, columnName) {\n          var pos = this.coordConverterModel.getCellPosition(rowKey, columnName);\n          var width = pos.right - pos.left;\n          var height = pos.bottom - pos.top;\n          this.borderEl.$left.css({\n            top: pos.top,\n            left: pos.left,\n            width: CELL_BORDER_WIDTH,\n            height: height + CELL_BORDER_WIDTH\n          });\n          this.borderEl.$top.css({\n            top: pos.top === 0 ? CELL_BORDER_WIDTH : pos.top,\n            left: pos.left,\n            width: width + CELL_BORDER_WIDTH,\n            height: CELL_BORDER_WIDTH\n          });\n          this.borderEl.$right.css({\n            top: pos.top,\n            left: pos.left + width,\n            width: CELL_BORDER_WIDTH,\n            height: height + CELL_BORDER_WIDTH\n          });\n          this.borderEl.$bottom.css({\n            top: pos.top + height,\n            left: pos.left,\n            width: width + CELL_BORDER_WIDTH,\n            height: CELL_BORDER_WIDTH\n          });\n        },\n\n        /**\n         * Render\n         * @returns {Object} this instance\n         */\n        render: function render() {\n          var $el = this.$el;\n\n          _.each(this.borderEl, function ($border) {\n            $el.append($border);\n          });\n\n          $el.hide();\n          return this;\n        }\n      });\n      module.exports = FocusLayer;\n      /***/\n    },\n    /* 58 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Creator of domEventBus\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var Backbone = __webpack_require__(5);\n\n      module.exports = {\n        create: function create() {\n          return _.extend({}, Backbone.Events);\n        }\n      };\n      /***/\n    },\n    /* 59 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview This class offers methods that can be used to get the current state of DOM element.\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var attrNameConst = __webpack_require__(10).attrName;\n\n      var classNameConst = __webpack_require__(19);\n      /**\n       * Class for offering methods that can be used to get the current state of DOM element.\n       * @module domState\n       * @param {jQuery} $el - jQuery object of the container element.\n       * @ignore\n       */\n\n\n      var DomState = snippet.defineClass(\n      /** @lends module:domState.prototype */\n      {\n        init: function init($el) {\n          this.$el = $el;\n        },\n\n        /**\n         * Returns a jquery object contains the tr elements\n         * @param {string} frameClassName - class name of frame\n         * @returns {jQuery}\n         * @private\n         */\n        _getBodyTableRows: function _getBodyTableRows(frameClassName) {\n          return this.$el.find('.' + frameClassName).find('.' + classNameConst.BODY_TABLE_CONTAINER).find('tr[' + attrNameConst.ROW_KEY + ']');\n        },\n\n        /**\n         * Returns max height of cells in the given row.\n         * @param {jQuery} $row - traget row\n         * @returns {number}\n         * @private\n         */\n        _getMaxCellHeight: function _getMaxCellHeight($row) {\n          var heights = $row.find('.' + classNameConst.CELL_CONTENT).map(function () {\n            return this.scrollHeight;\n          }).get();\n          return _.max(heights);\n        },\n\n        /**\n         * Returns an element of the table-cell identified by rowKey and columnName\n         * @param {(Number|String)} rowKey - Row key\n         * @param {String} columnName - Column name\n         * @returns {jQuery} Cell(TD) element\n         */\n        getElement: function getElement(rowKey, columnName) {\n          return this.$el.find('tr[' + attrNameConst.ROW_KEY + '=' + rowKey + ']').find('td[' + attrNameConst.COLUMN_NAME + '=\"' + columnName + '\"]');\n        },\n\n        /**\n         * Returns an array of heights of all rows\n         * @returns {Array.<number>}\n         */\n        getRowHeights: function getRowHeights() {\n          var $lsideRows = this._getBodyTableRows(classNameConst.LSIDE_AREA);\n\n          var $rsideRows = this._getBodyTableRows(classNameConst.RSIDE_AREA);\n\n          var lsideHeight, rsideHeight;\n          var heights = [];\n          var i, len;\n\n          for (i = 0, len = $lsideRows.length; i < len; i += 1) {\n            lsideHeight = this._getMaxCellHeight($lsideRows.eq(i));\n            rsideHeight = this._getMaxCellHeight($rsideRows.eq(i));\n            heights[i] = Math.max(lsideHeight, rsideHeight) + 1;\n          }\n\n          return heights;\n        },\n\n        /**\n         * Returns the offset of the container element\n         * @returns {{top: Number, left: Number}} Offset object\n         */\n        getOffset: function getOffset() {\n          return this.$el.offset();\n        },\n\n        /**\n         * Returns the width of the container element\n         * @returns {Number} Width of the container element\n         */\n        getWidth: function getWidth() {\n          return this.$el.width();\n        },\n\n        /**\n         * Returns the height of the parent of container element.\n         * @returns {Number} Height of the parent of container element\n         */\n        getParentHeight: function getParentHeight() {\n          return this.$el.parent().height();\n        },\n\n        /**\n         * Returns whether there's child element having focus.\n         * @returns {boolean} True if there's child element having focus\n         */\n        hasFocusedElement: function hasFocusedElement() {\n          return !!this.$el.find(':focus').length;\n        }\n      });\n      module.exports = DomState;\n      /***/\n    },\n    /* 60 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Public Event Emitter\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var Backbone = __webpack_require__(5);\n\n      var snippet = __webpack_require__(3);\n      /**\n       * Class that listens public events (for external user) to the other object and\n       * triggers them on the public object(module:grid).\n       * @module publicEventEmitter\n       * @param {Object} publicObject - Object on which event will be triggered.\n       *            This object should have methods of Backbone.Events.\n       * @ignore\n       */\n\n\n      var PublicEventEmitter = snippet.defineClass(\n      /** @lends module:publicEventEmitter.prototype */\n      {\n        init: function init(publicObject) {\n          this.publicObject = publicObject;\n        },\n\n        /**\n         * Listen and trigger specified events with same event name.\n         * @param {Object} target - Target object\n         * @param {String[]} eventNames - An array of the event names\n         * @private\n         */\n        _listenForThrough: function _listenForThrough(target, eventNames) {\n          _.each(eventNames, function (eventName) {\n            this.listenTo(target, eventName, _.bind(this._triggerOnPublic, this, eventName));\n          }, this);\n        },\n\n        /**\n         * Trigger specified event on the public object.\n         * @param  {String} eventName - Event name\n         * @param  {Object} eventData - Event data\n         * @private\n         */\n        _triggerOnPublic: function _triggerOnPublic(eventName, eventData) {\n          this.publicObject.trigger(eventName, _.extend(eventData, {\n            instance: this.publicObject\n          }));\n        },\n\n        /**\n         * Listen to Net addon.\n         * @param {module:addon/net} net - Net addon object\n         */\n        listenToNetAddon: function listenToNetAddon(net) {\n          this._listenForThrough(net, ['beforeRequest', 'response', 'successResponse', 'failResponse', 'errorResponse']);\n        },\n\n        /**\n         * Listen to Dom Event bus\n         * @param  {module:event/domEventBus} domEventBus - Dom Event bus\n         */\n        listenToDomEventBus: function listenToDomEventBus(domEventBus) {\n          this._listenForThrough(domEventBus, ['click', 'dblclick', 'mousedown', 'mouseover', 'mouseout']);\n        },\n\n        /**\n         * Listen to Focus model\n         * @param  {module:model/focus} focusModel - Focus model\n         */\n        listenToFocusModel: function listenToFocusModel(focusModel) {\n          this._listenForThrough(focusModel, ['focusChange']);\n        },\n\n        /**\n         * Listen to RowList model\n         * @param {module:model/rowList} dataModel - RowList model\n         */\n        listenToDataModel: function listenToDataModel(dataModel) {\n          this._listenForThrough(dataModel, ['check', 'uncheck', 'deleteRange', 'expanded', 'expandedAll', 'collapsed', 'collapsedAll']);\n        },\n        listenToSelectionModel: function listenToSelectionModel(selectionModel) {\n          this._listenForThrough(selectionModel, ['selection']);\n        }\n      });\n\n      _.extend(PublicEventEmitter.prototype, Backbone.Events);\n\n      module.exports = PublicEventEmitter;\n      /***/\n    },\n    /* 61 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Painter Manager\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var RowPainter = __webpack_require__(62);\n\n      var CellPainter = __webpack_require__(64);\n\n      var TreeCellPainter = __webpack_require__(65);\n\n      var DummyCellPainter = __webpack_require__(66);\n\n      var TextPainter = __webpack_require__(67);\n\n      var SelectPainter = __webpack_require__(69);\n\n      var ButtonPainter = __webpack_require__(70);\n\n      var MainButtonPainter = __webpack_require__(71);\n      /**\n       * Painter manager\n       * @module painter/manager\n       * @param {Object} options - Options\n       * @ignore\n       */\n\n\n      var PainterManager = snippet.defineClass(\n      /** @lends module:painter/manager.prototype */\n      {\n        init: function init(options) {\n          this.gridId = options.gridId;\n          this.selectType = options.selectType;\n          this.fixedRowHeight = options.fixedRowHeight;\n          this.inputPainters = this._createInputPainters(options.controller);\n          this.cellPainters = this._createCellPainters(options.controller, options.domEventBus);\n          this.rowPainter = this._createRowPainter();\n        },\n\n        /**\n         * Creates instances of input painters and returns the object that stores them\n         * using 'inputType' as keys.\n         * @param {module:painter/controller} controller - painter controller\n         * @returns {Object}\n         * @private\n         */\n        _createInputPainters: function _createInputPainters(controller) {\n          return {\n            text: new TextPainter({\n              controller: controller,\n              inputType: 'text'\n            }),\n            password: new TextPainter({\n              controller: controller,\n              inputType: 'password'\n            }),\n            checkbox: new ButtonPainter({\n              controller: controller,\n              inputType: 'checkbox'\n            }),\n            radio: new ButtonPainter({\n              controller: controller,\n              inputType: 'radio'\n            }),\n            select: new SelectPainter({\n              controller: controller\n            }),\n            mainButton: new MainButtonPainter({\n              controller: controller,\n              inputType: this.selectType,\n              gridId: this.gridId\n            })\n          };\n        },\n\n        /**\n         * Creates instances of cell painters and returns the object that stores them\n         * using 'editType' as keys.\n         * @param {module:painter/controller} controller - painter controller\n         * @param {module:event/domEventBus} domEventBus - domEventBus\n         * @returns {Object} Key-value object\n         * @private\n         */\n        _createCellPainters: function _createCellPainters(controller, domEventBus) {\n          var cellPainters = {\n            dummy: new DummyCellPainter({\n              controller: controller\n            }),\n            normal: new CellPainter({\n              domEventBus: domEventBus,\n              controller: controller,\n              fixedRowHeight: this.fixedRowHeight,\n              editType: 'normal'\n            })\n          };\n\n          _.each(this.inputPainters, function (inputPainter, editType) {\n            cellPainters[editType] = new CellPainter({\n              editType: editType,\n              controller: controller,\n              fixedRowHeight: this.fixedRowHeight,\n              inputPainter: inputPainter\n            });\n          }, this);\n\n          cellPainters.tree = new TreeCellPainter({\n            controller: controller,\n            inputPainter: this.inputPainters.text\n          });\n          return cellPainters;\n        },\n\n        /**\n         * Creates row painter and returns it.\n         * @returns {module:painter/row} New row painter instance\n         * @private\n         */\n        _createRowPainter: function _createRowPainter() {\n          return new RowPainter({\n            painterManager: this\n          });\n        },\n\n        /**\n         * Returns an instance of cell painter which has given editType\n         * @param {String} editType - Edit type\n         * @returns {Object} - Cell painter instance\n         */\n        getCellPainter: function getCellPainter(editType) {\n          return this.cellPainters[editType];\n        },\n\n        /**\n         * Returns an instance of tree-cell painter\n         * @returns {object} cell painter instance\n         */\n        getTreeCellPainter: function getTreeCellPainter() {\n          return this.cellPainters.tree;\n        },\n\n        /**\n         * Returns all cell painters\n         * @returns {Object} Object that has edit-type as a key and cell painter as a value\n         */\n        getCellPainters: function getCellPainters() {\n          return this.cellPainters;\n        },\n\n        /**\n         * Returns all input painters\n         * @param {Boolean} withoutMeta - if set to true, returns without meta cell painters\n         * @returns {Object} Object that has edit-type as a key and input painter as a value\n         */\n        getInputPainters: function getInputPainters(withoutMeta) {\n          var result = this.inputPainters;\n\n          if (withoutMeta) {\n            result = _.omit(result, 'mainButton');\n          }\n\n          return result;\n        },\n\n        /**\n         * Returns a row painter\n         * @returns {module:painter/row} Row painter\n         */\n        getRowPainter: function getRowPainter() {\n          return this.rowPainter;\n        }\n      });\n      module.exports = PainterManager;\n      /***/\n    },\n    /* 62 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Painter class for the row(TR) views\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var Painter = __webpack_require__(63);\n\n      var constMap = __webpack_require__(10);\n\n      var classNameConst = __webpack_require__(19);\n\n      var attrNameConst = constMap.attrName;\n      var CELL_BORDER_WIDTH = constMap.dimension.CELL_BORDER_WIDTH;\n      /**\n       * Painter class for the row(TR) views\n       * @module painter/row\n       * @extends module:base/painter\n       * @param {object} options - Options\n       * @ignore\n       */\n\n      var RowPainter = snippet.defineClass(Painter,\n      /** @lends module:painter/row.prototype */\n      {\n        init: function init(options) {\n          Painter.apply(this, arguments);\n          this.painterManager = options.painterManager;\n        },\n\n        /**\n         * css selector to find its own element(s) from a parent element.\n         * @type {String}\n         */\n        selector: 'tr',\n\n        /**\n         * markup template\n         * @returns {String} HTML string\n         */\n        template: _.template('<tr ' + '<%=rowKeyAttr%> ' + 'class=\"<%=className%>\" ' + 'style=\"height:<%=height%>px;\">' + '<%=contents%>' + '</tr>'),\n\n        /**\n         * cellData 의 isEditable 프로퍼티에 따른 editType 을 반환한다.\n         * editable 프로퍼티가 false 라면 normal type 으로 설정한다.\n         * @param {string} columnName 컬럼명\n         * @param {Object} cellData 셀 데이터\n         * @returns {string} cellFactory 에서 사용될 editType\n         * @private\n         */\n        _getEditType: function _getEditType(columnName, cellData) {\n          var editType = snippet.pick(cellData.columnModel, 'editOptions', 'type');\n          return editType || 'normal';\n        },\n\n        /**\n         * Get cell painter by value\n         * @param {boolean} treeCell - Whether the current cell is tree-cell or not\n         * @param {string} editType - When the current cell is normal, the cell type is selected\n         * @returns {object} cell painter\n         */\n        _getCellPainter: function _getCellPainter(treeCell, editType) {\n          var cellPainter;\n\n          if (treeCell) {\n            cellPainter = this.painterManager.getTreeCellPainter();\n          } else {\n            cellPainter = this.painterManager.getCellPainter(editType);\n          }\n\n          return cellPainter;\n        },\n\n        /**\n         * Returns the HTML string of all cells in Dummy row.\n         * @param {Number} rowNum - row number\n         * @param {Array.<String>} columnNames - An array of column names\n         * @returns {String} HTLM string\n         * @private\n         */\n        _generateHtmlForDummyRow: function _generateHtmlForDummyRow(rowNum, columnNames) {\n          var cellPainter = this.painterManager.getCellPainter('dummy');\n          var html = '';\n\n          _.each(columnNames, function (columnName) {\n            html += cellPainter.generateHtml(rowNum, columnName);\n          });\n\n          return html;\n        },\n\n        /**\n         * Returns the HTML string of all cells in Actual row.\n         * @param  {module:model/row} model - View model instance\n         * @param  {Array.<String>} columnNames - An array of column names\n         * @returns {String} HTLM string\n         * @private\n         */\n        _generateHtmlForActualRow: function _generateHtmlForActualRow(model, columnNames) {\n          var html = '';\n\n          _.each(columnNames, function (columnName) {\n            var cellData = model.get(columnName);\n            var treeCell, editType, cellPainter;\n\n            if (cellData && cellData.isMainRow) {\n              treeCell = !!cellData.tree;\n              editType = this._getEditType(columnName, cellData);\n              cellPainter = this._getCellPainter(treeCell, editType);\n              html += cellPainter.generateHtml(cellData);\n            }\n          }, this);\n\n          return html;\n        },\n\n        /**\n         * Returns the HTML string of all cells in the given model (row).\n         * @param {module:model/row} model - View model instance\n         * @param {Array.<String>} columnNames - An array of column names\n         * @returns {String} HTLM string\n         */\n        generateHtml: function generateHtml(model, columnNames) {\n          var rowKey = model.get('rowKey');\n          var rowNum = model.get('rowNum');\n          var className = rowNum % 2 ? classNameConst.ROW_ODD : classNameConst.ROW_EVEN;\n          var rowKeyAttr = '';\n          var html;\n\n          if (_.isUndefined(rowKey)) {\n            html = this._generateHtmlForDummyRow(rowNum, columnNames);\n          } else {\n            rowKeyAttr = attrNameConst.ROW_KEY + '=\"' + rowKey + '\"';\n            html = this._generateHtmlForActualRow(model, columnNames);\n          }\n\n          return this.template({\n            rowKeyAttr: rowKeyAttr,\n            height: model.get('height') + CELL_BORDER_WIDTH,\n            contents: html,\n            className: className\n          });\n        },\n\n        /**\n         * Refreshes the row(TR) element.\n         * @param {object} changed - object that contains the changed data using columnName as keys\n         * @param {jQuery} $tr - jquery object for tr element\n         */\n        refresh: function refresh(changed, $tr) {\n          _.each(changed, function (cellData, columnName) {\n            var treeCell, editType, cellPainter, $td;\n\n            if (columnName !== '_extraData') {\n              $td = $tr.find('td[' + attrNameConst.COLUMN_NAME + '=\"' + columnName + '\"]');\n              editType = this._getEditType(columnName, cellData);\n              treeCell = !!cellData.tree;\n              cellPainter = this._getCellPainter(treeCell, editType);\n              cellPainter.refresh(cellData, $td);\n            }\n          }, this);\n        }\n      });\n      module.exports = RowPainter;\n      /***/\n    },\n    /* 63 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Base class for Painters\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var attrNameConst = __webpack_require__(10).attrName;\n      /**\n       * Base class for Painters\n       * The Painter class is implentation of 'flyweight' pattern for the View class.\n       * This aims to act like a View class but doesn't create an instance of each view items\n       * to improve rendering performance.\n       * @module base/painter\n       * @param {Object} options - options\n       * @ignore\n       */\n\n\n      var Painter = snippet.defineClass(\n      /** @lends module:base/painter.prototype */\n      {\n        init: function init(options) {\n          this.controller = options.controller;\n        },\n\n        /**\n         * key-value object contains event names as keys and handler names as values\n         * @type {Object}\n         */\n        events: {},\n\n        /**\n         * css selector to use delegated event handlers by '$.on()' method.\n         * @type {String}\n         */\n        selector: '',\n\n        /**\n         * Returns the cell address of the target element.\n         * @param {jQuery} $target - target element\n         * @returns {{rowKey: String, columnName: String}}\n         * @private\n         */\n        _getCellAddress: function _getCellAddress($target) {\n          var $addressHolder = $target.closest('[' + attrNameConst.ROW_KEY + ']');\n          return {\n            rowKey: $addressHolder.attr(attrNameConst.ROW_KEY),\n            columnName: $addressHolder.attr(attrNameConst.COLUMN_NAME)\n          };\n        },\n\n        /**\n         * Attaches all event handlers to the $target element.\n         * @param {jquery} $target - target element\n         * @param {String} parentSelector - selector of a parent element\n         */\n        attachEventHandlers: function attachEventHandlers($target, parentSelector) {\n          _.each(this.events, function (methodName, eventName) {\n            var boundHandler = _.bind(this[methodName], this),\n                selector = parentSelector + ' ' + this.selector;\n\n            $target.on(eventName, selector, boundHandler);\n          }, this);\n        },\n\n        /**\n         * Generates a HTML string from given data, and returns it.\n         * @abstract\n         */\n        generateHtml: function generateHtml() {\n          throw new Error('implement generateHtml() method');\n        }\n      });\n      module.exports = Painter;\n      /***/\n    },\n    /* 64 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Painter class for cell(TD) views\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var Painter = __webpack_require__(63);\n\n      var util = __webpack_require__(17);\n\n      var attrNameConst = __webpack_require__(10).attrName;\n\n      var classNameConst = __webpack_require__(19);\n      /**\n       * Painter class for cell(TD) views\n       * @module painter/cell\n       * @extends module:base/painter\n       * @param {Object} options - options\n       * @ignore\n       */\n\n\n      var Cell = snippet.defineClass(Painter,\n      /** @lends module:painter/cell.prototype */\n      {\n        init: function init(options) {\n          Painter.apply(this, arguments);\n          this.editType = options.editType;\n          this.fixedRowHeight = options.fixedRowHeight;\n          this.inputPainter = options.inputPainter;\n          this.selector = 'td[' + attrNameConst.EDIT_TYPE + '=\"' + this.editType + '\"]';\n        },\n\n        /**\n         * template for TD\n         * @returns {string} template\n         */\n        template: _.template('<td <%=attributeString%> style=\"<%=style%>\"><%=contentHtml%></td>'),\n\n        /**\n         * template for DIV (inner content of TD)\n         */\n        contentTemplate: _.template('<div class=\"<%=className%>\" style=\"<%=style%>\"><%=content%></div>'),\n\n        /**\n         * Returns whether the instance is editable type.\n         * @returns {Boolean}\n         */\n        _isEditableType: function _isEditableType() {\n          return !_.contains(['normal', 'mainButton'], this.editType);\n        },\n\n        /**\n         * Returns css style string for given cellData\n         * @param {Object} cellData - cell data\n         * @returns {string}\n         */\n        _getContentStyle: function _getContentStyle(cellData) {\n          var whiteSpace = cellData.columnModel.whiteSpace || 'nowrap';\n          var styles = [];\n\n          if (whiteSpace) {\n            styles.push('white-space:' + whiteSpace);\n          }\n\n          if (this.fixedRowHeight) {\n            styles.push('max-height:' + cellData.height + 'px');\n          }\n\n          return styles.join(';');\n        },\n\n        /**\n         * Returns the HTML string of the contents containg the value of the 'prefix' and 'postfix'.\n         * @param {Object} cellData - cell data\n         * @returns {String}\n         * @private\n         */\n        _getContentHtml: function _getContentHtml(cellData) {\n          var customTemplate = cellData.columnModel.template;\n          var content = cellData.formattedValue;\n          var prefix = cellData.prefix;\n          var postfix = cellData.postfix;\n          var fullContent, template;\n\n          if (this.inputPainter) {\n            content = this.inputPainter.generateHtml(cellData);\n\n            if (this._shouldContentBeWrapped() && !this._isUsingViewMode(cellData)) {\n              prefix = this._getSpanWrapContent(prefix, classNameConst.CELL_CONTENT_BEFORE);\n              postfix = this._getSpanWrapContent(postfix, classNameConst.CELL_CONTENT_AFTER);\n              content = this._getSpanWrapContent(content, classNameConst.CELL_CONTENT_INPUT); // notice the order of concatenation\n\n              fullContent = prefix + postfix + content;\n            }\n          }\n\n          if (!fullContent) {\n            fullContent = prefix + content + postfix;\n          }\n\n          if (cellData.columnName === '_number' && _.isFunction(customTemplate)) {\n            template = customTemplate({\n              content: fullContent\n            });\n          } else {\n            template = this.contentTemplate({\n              content: fullContent,\n              className: classNameConst.CELL_CONTENT,\n              style: this._getContentStyle(cellData)\n            });\n          }\n\n          return template;\n        },\n\n        /**\n         * Returns whether the cell has view mode.\n         * @param {Object} cellData - cell data\n         * @returns {Boolean}\n         * @private\n         */\n        _isUsingViewMode: function _isUsingViewMode(cellData) {\n          return snippet.pick(cellData, 'columnModel', 'editOptions', 'useViewMode') !== false;\n        },\n\n        /**\n         * Returns whether the contents should be wrapped with span tags to display them correctly.\n         * @returns {Boolean}\n         * @private\n         */\n        _shouldContentBeWrapped: function _shouldContentBeWrapped() {\n          return _.contains(['text', 'password', 'select'], this.editType);\n        },\n\n        /**\n         * 주어진 문자열을 span 태그로 감싼 HTML 코드를 반환한다.\n         * @param {string} content - 감싸질 문자열\n         * @param {string} className - span 태그의 클래스명\n         * @returns {string} span 태그로 감싼 HTML 코드\n         * @private\n         */\n        _getSpanWrapContent: function _getSpanWrapContent(content, className) {\n          if (snippet.isFalsy(content)) {\n            content = '';\n          }\n\n          return '<span class=\"' + className + '\">' + content + '</span>';\n        },\n\n        /**\n         * Returns the object contains attributes of a TD element.\n         * @param {Object} cellData - cell data\n         * @returns {Object}\n         * @private\n         */\n        _getAttributes: function _getAttributes(cellData) {\n          var classNames = [cellData.className, classNameConst.CELL];\n          var attrs = {\n            'align': cellData.columnModel.align || 'left'\n          };\n          attrs['class'] = classNames.join(' ');\n          attrs[attrNameConst.EDIT_TYPE] = this.editType;\n          attrs[attrNameConst.ROW_KEY] = cellData.rowKey;\n          attrs[attrNameConst.COLUMN_NAME] = cellData.columnName;\n\n          if (cellData.rowSpan) {\n            attrs.rowspan = cellData.rowSpan;\n          }\n\n          return attrs;\n        },\n\n        /**\n         * Attaches all event handlers to the $target element.\n         * @param {jquery} $target - target element\n         * @param {String} parentSelector - selector of a parent element\n         * @override\n         */\n        attachEventHandlers: function attachEventHandlers($target, parentSelector) {\n          Painter.prototype.attachEventHandlers.call(this, $target, parentSelector);\n\n          if (this.inputPainter) {\n            this.inputPainter.attachEventHandlers($target, parentSelector + ' ' + this.selector);\n          }\n        },\n\n        /**\n         * Generates a HTML string from given data, and returns it.\n         * @param {object} cellData - cell data\n         * @returns {string} HTML string of the cell (TD)\n         * @implements {module:base/painter}\n         */\n        generateHtml: function generateHtml(cellData) {\n          var attributeString = util.getAttributesString(this._getAttributes(cellData));\n\n          var contentHtml = this._getContentHtml(cellData);\n\n          var valign = cellData.columnModel.valign;\n          var styles = [];\n\n          if (valign) {\n            styles.push('vertical-align:' + valign);\n          }\n\n          return this.template({\n            attributeString: attributeString,\n            style: styles.join(';'),\n            contentHtml: contentHtml\n          });\n        },\n\n        /**\n         * Refreshes the cell(td) element.\n         * @param {object} cellData - cell data\n         * @param {jQuery} $td - cell element\n         */\n        refresh: function refresh(cellData, $td) {\n          var contentProps = ['value', 'editing', 'disabled', 'listItems'];\n          var editingChangedToTrue = _.contains(cellData.changed, 'editing') && cellData.editing;\n          var shouldUpdateContent = _.intersection(contentProps, cellData.changed).length > 0;\n          var mainButton = this.editType === 'mainButton';\n          $td.attr(this._getAttributes(cellData));\n\n          if (editingChangedToTrue && !this._isUsingViewMode(cellData)) {\n            this.inputPainter.focus($td);\n          } else if (mainButton) {\n            $td.find(this.inputPainter.selector).prop({\n              checked: cellData.value,\n              disabled: cellData.disabled\n            });\n          } else if (shouldUpdateContent) {\n            $td.html(this._getContentHtml(cellData));\n            $td.scrollLeft(0);\n          }\n        }\n      });\n      module.exports = Cell;\n      /***/\n    },\n    /* 65 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Tree cell painter\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var Painter = __webpack_require__(63);\n\n      var util = __webpack_require__(17);\n\n      var attrNameConst = __webpack_require__(10).attrName;\n\n      var dimensionConst = __webpack_require__(10).dimension;\n\n      var classNameConst = __webpack_require__(19);\n      /**\n       * Painter class for tree-cell(TD) views\n       * @module painter/treeCell\n       * @extends module:base/painter\n       * @param {object} options - options\n       * @ignore\n       */\n\n\n      var TreeCell = snippet.defineClass(Painter,\n      /** @lends module:painter/treeCell.prototype */\n      {\n        init: function init(options) {\n          Painter.apply(this, arguments);\n          /**\n           * Input painter for editing cell data\n           * @type {module:painter/input/text}\n           */\n\n          this._inputPainter = options.inputPainter;\n        },\n\n        /**\n         * Selector of tree-button to bind events\n         * @type {string}\n         */\n        selector: '.' + classNameConst.BTN_TREE,\n        events: {\n          click: '_onClick'\n        },\n\n        /**\n         * Template for TD element\n         * @returns {string} html string\n         */\n        template: _.template('<td <%=attributeString%>\">' + '<div class=\"' + classNameConst.TREE_WARPPER_RELATIVE + '\">' + '<div class=\"' + classNameConst.TREE_WARPPER_VALIGN_CENTER + '\">' + '<%=extraContentHtml%>' + '<%=contentHtml%>' + '</div>' + '</div>' + '</td>'),\n\n        /**\n         * Template for each DIV element (inner content of TD)\n         * @returns {string} html string\n         */\n        contentTemplate: _.template('<div class=\"<%=className%>\" style=\"<%=style%>\">' + '<%=content%>' + '</div>'),\n\n        /**\n         * Template for each line element in extra content\n         * @returns {string} html string\n         */\n        lineTemplate: _.template('<span class=\"' + classNameConst.TREE_DEPTH + '\" style=\"<%=style%>\">' + '<% if (hasButton) { %>' + '<button class=\"' + classNameConst.BTN_TREE + '\"><i></i></button>' + '<% } %>' + '</span>'),\n\n        /**\n         * Event handler for tree-cell's expand/collapse button\n         * @param {Event} ev - dom event object\n         * @private\n         */\n        _onClick: function _onClick(ev) {\n          var $target = $(ev.target);\n          var $td = $target.parents('td');\n\n          var rowKey = this._getCellAddress($target).rowKey;\n\n          var isExpanded = $td.hasClass(classNameConst.TREE_BUTTON_EXPAND);\n          this.controller.changeTreeExpanded(rowKey, isExpanded);\n        },\n\n        /**\n         * Get html of line element in extra content\n         * @param {number} depth - depth of current row\n         * @param {boolean} lastDepth - whether the current row is last depth or not\n         * @param {boolean} hasChildren - whether the current row has children or not\n         * @returns {string} html string\n         * @private\n         */\n        _getLineHtml: function _getLineHtml(depth, lastDepth, hasChildren) {\n          var hasButton = lastDepth && hasChildren;\n          var style = ['left:' + depth * dimensionConst.INDENT_WIDTH + 'px;'];\n          return this.lineTemplate({\n            style: style.join(''),\n            hasButton: hasButton\n          });\n        },\n\n        /**\n         * Get html of icon element in extra content\n         * @param {number} depth - depth of current row\n         * @returns {string} html string\n         * @private\n         */\n        _getIconHtml: function _getIconHtml(depth) {\n          var style = 'left:' + depth * dimensionConst.INDENT_WIDTH + 'px;';\n          return '<span class=\"' + classNameConst.TREE_ICON + '\" style=\"' + style + '\"><i></i></span>';\n        },\n\n        /**\n         * Get html of extra content that contains line and expand/collapse button elements\n         * @param {object} cellData - tree cell data\n         * @returns {string} html string\n         * @private\n         */\n        _getExtraContentHtml: function _getExtraContentHtml(cellData) {\n          var depth = cellData.depth;\n          var hasChildren = cellData.hasChildren;\n          var useIcon = cellData.useIcon;\n          var index = 0;\n          var htmls = [];\n          var lastDepth;\n\n          for (; index < depth; index += 1) {\n            lastDepth = index === depth - 1;\n            htmls.push(this._getLineHtml(index, lastDepth, hasChildren));\n          }\n\n          if (useIcon) {\n            htmls.push(this._getIconHtml(depth));\n          }\n\n          return this.contentTemplate({\n            className: classNameConst.TREE_EXTRA_CONTENT,\n            style: '',\n            content: htmls.join('')\n          });\n        },\n\n        /**\n         * Get attributes string of TD\n         * @param {object} cellData - cell data\n         * @returns {string} connected attribute string\n         * @private\n         */\n        _getAttributes: function _getAttributes(cellData) {\n          var classNames = [cellData.className, classNameConst.CELL, classNameConst.CELL_HAS_TREE];\n          var attrs = {};\n\n          if (cellData.hasChildren) {\n            if (cellData.isExpanded) {\n              classNames.push(classNameConst.TREE_BUTTON_EXPAND);\n            } else {\n              classNames.push(classNameConst.TREE_BUTTON_COLLAPSE);\n            }\n          }\n\n          attrs['class'] = classNames.join(' ');\n          attrs[attrNameConst.ROW_KEY] = cellData.rowKey;\n          attrs[attrNameConst.COLUMN_NAME] = cellData.columnName;\n          return attrs;\n        },\n\n        /**\n         * Get html of data content in tree-cell's right area\n         * @param {object} cellData - cell data\n         * @returns {string} concat string of styles\n         * @private\n         */\n        _getContentStyle: function _getContentStyle(cellData) {\n          var whiteSpace = cellData.columnModel.whiteSpace || 'nowrap';\n          var marginLeft = cellData.depth * dimensionConst.INDENT_WIDTH;\n          var styles = [];\n\n          if (whiteSpace) {\n            styles.push('white-space:' + whiteSpace);\n          }\n\n          if (this.fixedRowHeight) {\n            styles.push('max-height:' + cellData.height + 'px');\n          }\n\n          if (cellData.useIcon) {\n            marginLeft += dimensionConst.INDENT_WIDTH;\n          }\n\n          styles.push('margin-left:' + marginLeft + 'px');\n          return styles.join(';');\n        },\n\n        /**\n         * Whether the current cell is using 'view-mode' or not\n         * @param {object} cellData - cell data\n         * @returns {boolean} using state\n         * @private\n         */\n        _isUsingViewMode: function _isUsingViewMode(cellData) {\n          return snippet.pick(cellData, 'columnModel', 'editOptions', 'useViewMode') !== false;\n        },\n\n        /**\n         * Get html of wrapping content by span tag\n         * @param {string} content - content to wrap\n         * @param {string} className - class names of span tag\n         * @returns {string} html string\n         * @private\n         */\n        _getSpanWrapContent: function _getSpanWrapContent(content, className) {\n          if (snippet.isFalsy(content)) {\n            content = '';\n          }\n\n          return '<span class=\"' + className + '\">' + content + '</span>';\n        },\n\n        /**\n         * Get html of data content\n         * @param {object} cellData - cell data\n         * @returns {string} html string\n         * @private\n         */\n        _getContentHtml: function _getContentHtml(cellData) {\n          var content = cellData.formattedValue;\n          var prefix = cellData.prefix;\n          var postfix = cellData.postfix;\n          var fullContent;\n\n          if (this._inputPainter) {\n            content = this._inputPainter.generateHtml(cellData);\n\n            if (!this._isUsingViewMode(cellData)) {\n              prefix = this._getSpanWrapContent(prefix, classNameConst.CELL_CONTENT_BEFORE);\n              postfix = this._getSpanWrapContent(postfix, classNameConst.CELL_CONTENT_AFTER);\n              content = this._getSpanWrapContent(content, classNameConst.CELL_CONTENT_INPUT); // notice the order of concatenation\n\n              fullContent = prefix + postfix + content;\n            }\n          }\n\n          if (!fullContent) {\n            fullContent = prefix + content + postfix;\n          }\n\n          return this.contentTemplate({\n            className: classNameConst.CELL_CONTENT,\n            style: this._getContentStyle(cellData),\n            content: fullContent\n          });\n        },\n\n        /**\n         * Generate content html of TD\n         * @param {object} cellData - cell data\n         * @returns {string} html string\n         */\n        generateHtml: function generateHtml(cellData) {\n          var attributeString = util.getAttributesString(this._getAttributes(cellData));\n\n          var extraContentHtml = this._getExtraContentHtml(cellData);\n\n          var contentHtml = this._getContentHtml(cellData);\n\n          return this.template({\n            attributeString: attributeString,\n            extraContentHtml: extraContentHtml,\n            contentHtml: contentHtml\n          });\n        },\n\n        /**\n         * Rerender content html of TD\n         * @param {object} cellData - cell data\n         * @param {jQuery} $td - cell element\n         */\n        refresh: function refresh(cellData, $td) {\n          var editingChangedToTrue = _.contains(cellData.changed, 'editing') && cellData.editing;\n          var shouldUpdateContent = cellData.changed.length > 0;\n\n          var attrs = this._getAttributes(cellData);\n\n          var contentHtml;\n          $td.attr(attrs);\n\n          if (editingChangedToTrue && !this._isUsingViewMode(cellData)) {\n            this._inputPainter.focus($td);\n          } else if (shouldUpdateContent) {\n            contentHtml = this._getContentHtml(cellData);\n            $td.find('.' + classNameConst.CELL_CONTENT).remove();\n            $td.find('.' + classNameConst.TREE_EXTRA_CONTENT).after(contentHtml);\n            $td.scrollLeft(0);\n          }\n        }\n      });\n      module.exports = TreeCell;\n      /***/\n    },\n    /* 66 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Dummy cell painter\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var Painter = __webpack_require__(63);\n\n      var util = __webpack_require__(17);\n\n      var attrNameConst = __webpack_require__(10).attrName;\n\n      var classNameConst = __webpack_require__(19);\n      /**\n       * Dummy Cell Painter\n       * @module painter/dummyCell\n       * @extends module:base/painter\n       * @ignore\n       */\n\n\n      var DummyCell = snippet.defineClass(Painter,\n      /** @lends module:painter/dummyCell.prototype */\n      {\n        init: function init() {\n          Painter.apply(this, arguments);\n        },\n\n        /**\n         * css selector to find its own element(s) from a parent element.\n         * @type {String}\n         */\n        selector: 'td[' + attrNameConst.EDIT_TYPE + '=\"dummy\"]',\n\n        /**\n         * Template function\n         * @returns {String} HTML string\n         */\n        template: _.template('<td ' + attrNameConst.COLUMN_NAME + '=\"<%=columnName%>\" ' + attrNameConst.EDIT_TYPE + '=\"dummy\" ' + 'class=\"<%=className%>\">' + '</td>'),\n\n        /**\n         * Generates a HTML string from given data, and returns it.\n         * @param {Number} rowNum - row number\n         * @param {String} columnName - column name\n         * @returns {string} HTML string\n         * @implements {module:base/painter}\n         */\n        generateHtml: function generateHtml(rowNum, columnName) {\n          var classNames = [classNameConst.CELL, classNameConst.CELL_DUMMY];\n\n          if (util.isMetaColumn(columnName)) {\n            classNames.push(classNameConst.CELL_ROW_HEAD);\n          }\n\n          return this.template({\n            columnName: columnName,\n            className: classNames.join(' ')\n          });\n        }\n      });\n      module.exports = DummyCell;\n      /***/\n    },\n    /* 67 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Painter class for the 'input[type=text]' and 'input[type=password]'.\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var InputPainter = __webpack_require__(68);\n\n      var util = __webpack_require__(17);\n\n      var classNameConst = __webpack_require__(19);\n\n      var SELECTOR_TEXT = '.' + classNameConst.CELL_CONTENT_TEXT;\n      var SELECTOR_PASSWORD = 'input[type=password]';\n      /**\n       * Painter class for the 'input[type=text]' and 'input[type=password]'\n       * @module painter/input/text\n       * @extends module:painter/input/base\n       * @param {Object} options - options\n       * @ignore\n       */\n\n      var TextPainter = snippet.defineClass(InputPainter,\n      /** @lends module:painter/input/text.prototype */\n      {\n        init: function init(options) {\n          InputPainter.apply(this, arguments);\n          this.inputType = options.inputType;\n          /**\n           * css selector to use delegated event handlers by '$.on()' method.\n           * @type {String}\n           */\n\n          this.selector = options.inputType === 'text' ? SELECTOR_TEXT : SELECTOR_PASSWORD;\n\n          this._extendEvents({\n            selectstart: '_onSelectStart'\n          });\n        },\n\n        /**\n         * template for input\n         * @returns {string} html\n         */\n        templateInput: _.template('<input' + ' class=\"<%=className%>\"' + ' type=\"<%=type%>\"' + ' value=\"<%=value%>\"' + ' name=\"<%=name%>\"' + ' align=\"center\"' + ' maxLength=\"<%=maxLength%>\"' + ' <%=disabled%>' + '/>'),\n\n        /**\n         * template for textarea\n         * @returns {string} html\n         */\n        templateTextArea: _.template('<textarea' + ' class=\"<%=className%>\"' + ' name=\"<%=name%>\"' + ' maxLength=\"<%=maxLength%>\"' + ' <%=disabled%>><%=value%>' + '</textarea>'),\n\n        /**\n         * Event handler for the 'selectstart' event.\n         * (To prevent 'selectstart' event be prevented by module:view/layout/body in IE)\n         * @param {Event} event - DOM event object\n         * @private\n         */\n        _onSelectStart: function _onSelectStart(event) {\n          event.stopPropagation();\n        },\n\n        /**\n         * Convert each character in the given string to '*' and returns them as a string.\n         * @param {String} value - value string\n         * @returns {String}\n         * @private\n         */\n        _convertStringToAsterisks: function _convertStringToAsterisks(value) {\n          return Array(value.length + 1).join('*');\n        },\n\n        /**\n         * Returns the value string of given data to display in the cell.\n         * @param {Object} cellData - cell data\n         * @implements {module:painter/input/base}\n         * @returns {String}\n         * @protected\n         */\n        _getDisplayValue: function _getDisplayValue(cellData) {\n          var value = cellData.formattedValue;\n\n          if (this.inputType === 'password') {\n            value = this._convertStringToAsterisks(cellData.value);\n          }\n\n          return value;\n        },\n\n        /**\n         * Generates an input HTML string from given data, and returns it.\n         * @param {object} cellData - cell data\n         * @implements {module:painter/input/base}\n         * @returns {string}\n         * @protected\n         */\n        _generateInputHtml: function _generateInputHtml(cellData) {\n          var maxLength = snippet.pick(cellData, 'columnModel', 'editOptions', 'maxLength');\n          var params = {\n            type: this.inputType,\n            className: classNameConst.CELL_CONTENT_TEXT,\n            value: cellData.value,\n            name: util.getUniqueKey(),\n            disabled: cellData.disabled ? 'disabled' : '',\n            maxLength: maxLength\n          };\n\n          if (cellData.whiteSpace !== 'nowrap') {\n            return this.templateTextArea(params);\n          }\n\n          return this.templateInput(params);\n        },\n\n        /**\n         * Finds an element from the given parent element with 'this.selector', and moves focus to it.\n         * @param {jquery} $parent - parent element\n         * @override\n         */\n        focus: function focus($parent) {\n          var $input = $parent.find(this.selector);\n\n          if ($input.length === 1 && !$input.is(':focus')) {\n            $input.select();\n          }\n        }\n      });\n      module.exports = TextPainter;\n      /***/\n    },\n    /* 68 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Base class for the Input Painter\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var Backbone = __webpack_require__(5);\n\n      var snippet = __webpack_require__(3);\n\n      var Painter = __webpack_require__(63);\n\n      var keyNameMap = __webpack_require__(10).keyName;\n      /**\n       * Input Painter Base\n       * @module painter/input/base\n       * @extends module:base/painter\n       * @param {Object} options - options\n       * @ignore\n       */\n\n\n      var InputPainter = snippet.defineClass(Painter,\n      /** @lends module:painter/input/base.prototype */\n      {\n        init: function init() {\n          Painter.apply(this, arguments);\n          /**\n           * State of finishing to edit\n           * @type {Boolean}\n           */\n\n          this._finishedEditing = false;\n        },\n\n        /**\n         * key-value object contains event names as keys and handler names as values\n         * @type {Object}\n         */\n        events: {\n          keydown: '_onKeyDown',\n          focusin: '_onFocusIn',\n          focusout: '_onFocusOut',\n          change: '_onChange'\n        },\n\n        /**\n         * keydown Actions\n         * @type {Object}\n         */\n        keyDownActions: {\n          ESC: function ESC(param) {\n            this.controller.finishEditing(param.address, true);\n          },\n          ENTER: function ENTER(param) {\n            this.controller.finishEditing(param.address, true, param.value);\n          },\n          TAB: function TAB(param) {\n            this.controller.finishEditing(param.address, true, param.value);\n            this.controller.focusInToNextCell(param.shiftKey);\n          }\n        },\n\n        /**\n         * Extends the default keydown actions.\n         * @param {Object} actions - Object that contains the action functions\n         * @private\n         */\n        _extendKeydownActions: function _extendKeydownActions(actions) {\n          this.keyDownActions = _.assign({}, this.keyDownActions, actions);\n        },\n\n        /**\n         * Extends the default event object\n         * @param {Object} events - Object that contains the names of event handlers\n         */\n        _extendEvents: function _extendEvents(events) {\n          this.events = _.assign({}, this.events, events);\n        },\n\n        /**\n         * Executes the custom handler (defined by user) of the input events.\n         * @param {Event} event - DOM event object\n         * @param {{rowKey: number, columnName: string}} address - target cell address\n         * @private\n         */\n        _executeCustomEventHandler: function _executeCustomEventHandler(event, address) {\n          this.controller.executeCustomInputEventHandler(event, address);\n        },\n\n        /**\n         * Event handler for the 'change' event.\n         * This method is just a stub. Override this if necessary.\n         * @private\n         */\n        _onChange: function _onChange() {// do nothing\n        },\n\n        /**\n         * Event handler for the 'focusin' event.\n         * @param {Event} event - DOM event object\n         * @private\n         */\n        _onFocusIn: function _onFocusIn(event) {\n          var $target = $(event.target);\n\n          var address = this._getCellAddress($target);\n\n          var self = this; // Defers starting editing\n          // as button-type(checkbox, radio) defers finishing editing for detecting blurred state.\n          // see {@link module:painter/input/button#_onFocusOut}\n\n          _.defer(function () {\n            self._executeCustomEventHandler(event, address);\n\n            self.trigger('focusIn', $target, address);\n            self.controller.startEditing(address);\n          });\n        },\n\n        /**\n         * Event handler for the 'focusout' event.\n         * @param {Event} event - DOM event object\n         * @private\n         */\n        _onFocusOut: function _onFocusOut(event) {\n          var $target = $(event.target);\n\n          var address = this._getCellAddress($target);\n\n          if (!this._finishedEditing) {\n            this._executeCustomEventHandler(event, address);\n\n            this.trigger('focusOut', $target, address);\n            this.controller.finishEditing(address, false, $target.val());\n          }\n        },\n\n        /**\n         * Event handler for the 'keydown' event.\n         * @param  {KeyboardEvent} event - KeyboardEvent object\n         * @private\n         */\n        _onKeyDown: function _onKeyDown(event) {\n          var keyCode = event.keyCode || event.which;\n          var keyName = keyNameMap[keyCode];\n          var action = this.keyDownActions[keyName];\n          var $target = $(event.target);\n          var param = {\n            $target: $target,\n            address: this._getCellAddress($target),\n            shiftKey: event.shiftKey,\n            value: $target.val()\n          };\n\n          this._executeCustomEventHandler(event, param.address);\n\n          if (action && !event.shiftKey) {\n            action.call(this, param);\n            event.preventDefault();\n          }\n        },\n\n        /**\n         * Returns the value string of given data to display in the cell.\n         * @abstract\n         * @protected\n         */\n        _getDisplayValue: function _getDisplayValue() {\n          throw new Error('implement _getDisplayValue() method');\n        },\n\n        /**\n         * Generates an input HTML string from given data, and returns it.\n         * @abstract\n         * @protected\n         */\n        _generateInputHtml: function _generateInputHtml() {\n          throw new Error('implement _generateInputHtml() method');\n        },\n\n        /**\n         * Returns whether the cell has view mode.\n         * @param {Object} cellData - cell data\n         * @returns {Boolean}\n         * @private\n         */\n        _isUsingViewMode: function _isUsingViewMode(cellData) {\n          return snippet.pick(cellData, 'columnModel', 'editOptions', 'useViewMode') !== false;\n        },\n\n        /**\n         * Generates a HTML string from given data, and returns it.\n         * @param {Object} cellData - cell data\n         * @returns {String}\n         * @implements {module:painter/input/base}\n         */\n        generateHtml: function generateHtml(cellData) {\n          var result;\n\n          if (!_.isNull(cellData.convertedHTML)) {\n            result = cellData.convertedHTML;\n          } else if (!this._isUsingViewMode(cellData) || cellData.editing) {\n            result = this._generateInputHtml(cellData);\n          } else {\n            result = this._getDisplayValue(cellData);\n          }\n\n          return result;\n        },\n\n        /**\n         * Finds an element from the given parent element with 'this.selector', and moves focus to it.\n         * @param {jquery} $parent - parent element\n         */\n        focus: function focus($parent) {\n          var $input = $parent.find(this.selector);\n\n          if (!$input.is(':focus')) {\n            $input.eq(0).focus();\n          }\n        },\n\n        /**\n         * Block focusing out\n         */\n        blockFocusingOut: function blockFocusingOut() {\n          this._finishedEditing = true;\n        },\n\n        /**\n         * Unblock focusing out\n         */\n        unblockFocusingOut: function unblockFocusingOut() {\n          this._finishedEditing = false;\n        }\n      });\n\n      _.assign(InputPainter.prototype, Backbone.Events);\n\n      module.exports = InputPainter;\n      /***/\n    },\n    /* 69 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Painter class for 'select' input.\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var InputPainter = __webpack_require__(68);\n\n      var util = __webpack_require__(17);\n      /**\n       * Painter class for 'select' input.\n       * @module painter/input/select\n       * @extends module:painter/input/base\n       * @ignore\n       */\n\n\n      var SelectPainter = snippet.defineClass(InputPainter,\n      /** @lends module:painter/input/select.prototype */\n      {\n        init: function init() {\n          InputPainter.apply(this, arguments);\n          /**\n           * css selector to use delegated event handlers by '$.on()' method.\n           * @type {String}\n           */\n\n          this.selector = 'select';\n        },\n\n        /**\n         * Content markup template\n         * @returns {string} html\n         */\n        template: _.template('<select name=\"<%=name%>\" <%=disabled%>><%=options%></select>'),\n\n        /**\n         * Options markup template\n         * @returns {string} html\n         */\n        optionTemplate: _.template('<option value=\"<%=value%>\" <%=selected%>><%=text%></option>'),\n\n        /**\n         * Event handler for the 'change' event\n         * @param {Event} ev - DOM Event\n         */\n        _onChange: function _onChange(ev) {\n          var $target = $(ev.target);\n\n          var address = this._getCellAddress($target);\n\n          this.controller.setValueIfNotUsingViewMode(address, $target.val());\n        },\n\n        /**\n         * Returns the value string of given data to display in the cell.\n         * @param {Object} cellData - cell data\n         * @implements {module:painter/input/base}\n         * @returns {String}\n         * @protected\n         */\n        _getDisplayValue: function _getDisplayValue(cellData) {\n          var selectedOption = _.find(cellData.listItems, function (item) {\n            return String(item.value) === String(cellData.value);\n          });\n\n          return selectedOption ? selectedOption.text : '';\n        },\n\n        /**\n         * Generates an input HTML string from given data, and returns it.\n         * @param {object} cellData - cell data\n         * @implements {module:painter/input/base}\n         * @returns {string}\n         * @protected\n         */\n        _generateInputHtml: function _generateInputHtml(cellData) {\n          var optionHtml = _.reduce(cellData.listItems, function (html, item) {\n            return html + this.optionTemplate({\n              value: item.value,\n              text: item.text,\n              selected: String(cellData.value) === String(item.value) ? 'selected' : ''\n            });\n          }, '', this);\n\n          return this.template({\n            name: util.getUniqueKey(),\n            disabled: cellData.disabled ? 'disabled' : '',\n            options: optionHtml\n          });\n        }\n      });\n      module.exports = SelectPainter;\n      /***/\n    },\n    /* 70 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Painter class for 'checkbox' and 'radio button'.\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var InputPainter = __webpack_require__(68);\n\n      var util = __webpack_require__(17);\n      /**\n       * Painter class for 'checkbox' and 'radio button'.\n       * @module painter/input/button\n       * @extends module:painter/input/base\n       * @param {Object} options - options\n       * @ignore\n       */\n\n\n      var ButtonPainter = snippet.defineClass(InputPainter,\n      /** @lends module:painter/input/button.prototype */\n      {\n        init: function init(options) {\n          InputPainter.apply(this, arguments);\n          this.inputType = options.inputType;\n          /**\n           * css selector to use delegated event handlers by '$.on()' method.\n           * @type {String}\n           */\n\n          this.selector = 'fieldset[data-type=' + this.inputType + ']';\n\n          this._extendEvents({\n            mousedown: '_onMouseDown'\n          });\n\n          this._extendKeydownActions({\n            TAB: function TAB(param) {\n              var value;\n\n              if (!this._focusNextInput(param.$target, param.shiftKey)) {\n                value = this._getCheckedValueString(param.$target);\n                this.controller.finishEditing(param.address, true, value);\n                this.controller.focusInToNextCell(param.shiftKey);\n              }\n            },\n            ENTER: function ENTER(param) {\n              var value = this._getCheckedValueString(param.$target);\n\n              this.controller.finishEditing(param.address, true, value);\n            },\n            LEFT_ARROW: function LEFT_ARROW(param) {\n              this._focusNextInput(param.$target, true);\n            },\n            RIGHT_ARROW: function RIGHT_ARROW(param) {\n              this._focusNextInput(param.$target);\n            },\n            UP_ARROW: function UP_ARROW() {},\n            DOWN_ARROW: function DOWN_ARROW() {}\n          });\n        },\n\n        /**\n         * fieldset markup template\n         * @returns {String}\n         */\n        template: _.template('<fieldset data-type=\"<%=type%>\"><%=content%></fieldset>'),\n\n        /**\n         * Input markup template\n         * @returns {String}\n         */\n        inputTemplate: _.template('<input type=\"<%=type%>\" data-value-type=\"<%=valueType%>\" name=\"<%=name%>\" id=\"<%=id%>\" value=\"<%=value%>\"' + ' <%=checked%> <%=disabled%> />'),\n\n        /**\n         * Label markup template\n         * @returns {String}\n         */\n        labelTemplate: _.template('<label for=\"<%=id%>\"><%=labelText%></label>'),\n\n        /**\n         * Event handler for 'change' event\n         * @param {Event} ev - DOM Event\n         */\n        _onChange: function _onChange(ev) {\n          var $target = $(ev.target);\n\n          var address = this._getCellAddress($target);\n\n          var value = this._getCheckedValueString($target);\n\n          this.controller.setValueIfNotUsingViewMode(address, value);\n        },\n\n        /**\n         * Event handler for 'blur' event\n         * @param {Event} event - event object\n         * @override\n         * @private\n         */\n        _onFocusOut: function _onFocusOut(event) {\n          var $target = $(event.target);\n          var self = this;\n\n          _.defer(function () {\n            var address, value;\n\n            if (!$target.siblings('input:focus').length) {\n              address = self._getCellAddress($target);\n              value = self._getCheckedValueString($target);\n              self.controller.finishEditing(address, false, value);\n            }\n          });\n        },\n\n        /**\n         * Event handler for 'mousedown' DOM event\n         * @param {MouseEvent} event - mouse event object\n         * @private\n         */\n        _onMouseDown: function _onMouseDown(event) {\n          var $target = $(event.target);\n          var hasFocusedInput = $target.closest('fieldset').find('input:focus').length > 0;\n\n          if (!$target.is('input') && hasFocusedInput) {\n            event.stopPropagation();\n            event.preventDefault();\n          }\n        },\n\n        /**\n         * Moves focus to the next input element.\n         * @param {jquery} $target - target element\n         * @param {Boolean} reverse - if set to true, find previous element instead of next element.\n         * @returns {Boolean} - false if no element exist, true otherwise.\n         * @private\n         */\n        _focusNextInput: function _focusNextInput($target, reverse) {\n          var traverseFuncName = reverse ? 'prevAll' : 'nextAll',\n              $nextInputs = $target[traverseFuncName]('input');\n\n          if ($nextInputs.length) {\n            $nextInputs.first().focus();\n            return true;\n          }\n\n          return false;\n        },\n\n        /**\n         * Returns the comma seperated value of all checked inputs\n         * @param {jQuery} $target - target element\n         * @returns {String}\n         * @private\n         */\n        _getCheckedValueString: function _getCheckedValueString($target) {\n          var $checkedInputs = $target.parent().find('input:checked');\n          var checkedValues = [];\n          var result;\n          $checkedInputs.each(function () {\n            var $input = $(this);\n            var valueType = $input.attr('data-value-type');\n            var value = util.convertValueType($input.val(), valueType);\n            checkedValues.push(value);\n          });\n\n          if (checkedValues.length === 1) {\n            result = checkedValues[0];\n          } else {\n            result = checkedValues.join(',');\n          }\n\n          return result;\n        },\n\n        /**\n         * Returns the set object that contains the checked value.\n         * @param {String} value - value\n         * @returns {Object}\n         * @private\n         */\n        _getCheckedValueSet: function _getCheckedValueSet(value) {\n          var checkedMap = {};\n\n          _.each(String(value).split(','), function (itemValue) {\n            checkedMap[itemValue] = true;\n          });\n\n          return checkedMap;\n        },\n\n        /**\n         * Returns the value string of given data to display in the cell.\n         * @param {Object} cellData - cell data\n         * @implements {module:painter/input/base}\n         * @returns {String}\n         * @protected\n         */\n        _getDisplayValue: function _getDisplayValue(cellData) {\n          var checkedSet = this._getCheckedValueSet(cellData.value);\n\n          var optionTexts = [];\n\n          _.each(cellData.listItems, function (item) {\n            if (checkedSet[item.value]) {\n              optionTexts.push(item.text);\n            }\n          });\n\n          return optionTexts.join(',');\n        },\n\n        /**\n         * Generates an input HTML string from given data, and returns it.\n         * @param {object} cellData - cell data\n         * @implements {module:painter/input/base}\n         * @returns {string}\n         * @protected\n         */\n        _generateInputHtml: function _generateInputHtml(cellData) {\n          var checkedSet = this._getCheckedValueSet(cellData.value);\n\n          var name = util.getUniqueKey();\n          var contentHtml = '';\n\n          _.each(cellData.listItems, function (item) {\n            var id = name + '_' + item.value;\n            contentHtml += this.inputTemplate({\n              type: this.inputType,\n              id: id,\n              name: name,\n              value: item.value,\n              valueType: typeof item.value,\n              checked: checkedSet[item.value] ? 'checked' : '',\n              disabled: cellData.isDisabled ? 'disabled' : ''\n            });\n\n            if (item.text) {\n              contentHtml += this.labelTemplate({\n                id: id,\n                labelText: item.text\n              });\n            }\n          }, this);\n\n          return this.template({\n            type: this.inputType,\n            content: contentHtml\n          });\n        },\n\n        /**\n         * Finds an element from the given parent element with 'this.selector', and moves focus to it.\n         * @param {jquery} $parent - parent element\n         * @override\n         */\n        focus: function focus($parent) {\n          var $input = $parent.find('input');\n\n          if (!$input.is(':focus')) {\n            $input.eq(0).focus();\n          }\n        }\n      });\n      module.exports = ButtonPainter;\n      /***/\n    },\n    /* 71 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Main Button Painter\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var Painter = __webpack_require__(63);\n\n      var classNameConst = __webpack_require__(19);\n\n      var keyCodeMap = __webpack_require__(10).keyCode;\n\n      var className = classNameConst.CELL_MAIN_BUTTON;\n      /**\n       * Main Button Painter\n       * (This class does not extend from module:painter/input/base but from module:base/painter directly)\n       * @module painter/input/mainButton\n       * @extends module:base/painter\n       * @param {Object} options - options\n       * @ignore\n       */\n\n      var InputPainter = snippet.defineClass(Painter,\n      /** @lends module:painter/input/mainButton.prototype */\n      {\n        init: function init(options) {\n          Painter.apply(this, arguments);\n          this.selector = 'input.' + className;\n          this.inputType = options.inputType;\n          this.gridId = options.gridId;\n        },\n\n        /**\n         * key-value object contains event names as keys and handler names as values\n         * @type {Object}\n         */\n        events: {\n          change: '_onChange',\n          keydown: '_onKeydown'\n        },\n\n        /**\n         * markup template\n         * @returns {String}\n         */\n        template: _.template('<input class=\"<%=className%>\" ' + 'type=\"<%=type%>\" name=\"<%=name%>\" <%=checked%> <%=disabled%> />'),\n\n        /**\n         * Event handler for 'change' DOM event.\n         * @param {Event} event - DOM event object\n         * @private\n         */\n        _onChange: function _onChange(event) {\n          var $target = $(event.target);\n\n          var address = this._getCellAddress($target);\n\n          this.controller.setValue(address, $target.is(':checked'));\n        },\n\n        /**\n         * Event handler for 'keydown' DOM event\n         * @param {KeyboardEvent} event [description]\n         */\n        _onKeydown: function _onKeydown(event) {\n          var address;\n\n          if (event.keyCode === keyCodeMap.TAB) {\n            event.preventDefault();\n            address = this._getCellAddress($(event.target));\n            this.controller.focusInToRow(address.rowKey);\n          }\n        },\n\n        /**\n         * Generates a HTML string from given data, and returns it.\n         * @param {Object} cellData - cell data\n         * @returns {String}\n         * @implements {module:painter/input/base}\n         */\n        generateHtml: function generateHtml(cellData) {\n          var customTemplate = cellData.columnModel.template;\n          var convertedHTML = null;\n          var props = {\n            type: this.inputType,\n            name: this.gridId,\n            className: className\n          };\n\n          if (_.isFunction(customTemplate)) {\n            convertedHTML = customTemplate(_.extend(props, {\n              checked: cellData.value,\n              disabled: cellData.disabled\n            }));\n          } else {\n            convertedHTML = this.template(_.extend(props, {\n              checked: cellData.value ? 'checked' : '',\n              disabled: cellData.disabled ? 'disabled' : ''\n            }));\n          }\n\n          return convertedHTML;\n        }\n      });\n      module.exports = InputPainter;\n      /***/\n    },\n    /* 72 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Controller class to handle actions from the painters\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n\n      var util = __webpack_require__(17);\n      /**\n       * Controller class to handle actions from the painters\n       * @module painter/controller\n       * @param {Object} options - options\n       * @ignore\n       */\n\n\n      var PainterController = snippet.defineClass(\n      /** @lends module:painter/controller.prototype */\n      {\n        init: function init(options) {\n          this.focusModel = options.focusModel;\n          this.dataModel = options.dataModel;\n          this.columnModel = options.columnModel;\n          this.selectionModel = options.selectionModel;\n        },\n\n        /**\n         * Starts editing a cell identified by a given address, and returns the result.\n         * @param {{rowKey:String, columnName:String}} address - cell address\n         * @param {Boolean} force - if set to true, finish current editing before start.\n         * @returns {Boolean} true if succeeded, false otherwise\n         */\n        startEditing: function startEditing(address, force) {\n          var result;\n\n          if (force) {\n            this.focusModel.finishEditing();\n          }\n\n          result = this.focusModel.startEditing(address.rowKey, address.columnName);\n\n          if (result) {\n            this.selectionModel.end();\n          }\n\n          return result;\n        },\n\n        /**\n         * Check if given column has 'maxLength' property and returns the substring limited by maxLength.\n         * @param {string} columnName - columnName\n         * @param {string} value - value\n         * @returns {string}\n         * @private\n         */\n        _checkMaxLength: function _checkMaxLength(columnName, value) {\n          var column = this.columnModel.getColumnModel(columnName);\n          var maxLength = snippet.pick(column, 'editOptions', 'maxLength');\n\n          if (maxLength > 0 && value.length > maxLength) {\n            return value.substring(0, maxLength);\n          }\n\n          return value;\n        },\n\n        /**\n         * Ends editing a cell identified by a given address, and returns the result.\n         * @param {{rowKey:String, columnName:String}} address - cell address\n         * @param {Boolean} shouldBlur - if set to true, make the current input lose focus.\n         * @param {String} [value] - if exists, set the value of the data model to this value.\n         * @returns {Boolean} - true if succeeded, false otherwise\n         */\n        finishEditing: function finishEditing(address, shouldBlur, value) {\n          var focusModel = this.focusModel;\n          var row, currentValue;\n\n          if (!focusModel.isEditingCell(address.rowKey, address.columnName)) {\n            return false;\n          }\n\n          this.selectionModel.enable();\n\n          if (!_.isUndefined(value)) {\n            row = this.dataModel.get(address.rowKey);\n            currentValue = row.get(address.columnName);\n\n            if (!(util.isBlank(value) && util.isBlank(currentValue))) {\n              this.setValue(address, this._checkMaxLength(address.columnName, value));\n            }\n          }\n\n          focusModel.finishEditing();\n\n          if (shouldBlur) {\n            focusModel.focusClipboard();\n          } else {\n            _.defer(function () {\n              focusModel.refreshState();\n            });\n          }\n\n          return true;\n        },\n\n        /**\n         * Moves focus to the next cell, and starts editing the cell.\n         * @param {Boolean} reverse - if set to true, find the previous cell instead of next cell\n         */\n        focusInToNextCell: function focusInToNextCell(reverse) {\n          var focusModel = this.focusModel;\n          var address = reverse ? focusModel.prevAddress() : focusModel.nextAddress();\n          focusModel.focusIn(address.rowKey, address.columnName, true);\n        },\n\n        /**\n         * Moves focus to the first cell of the given row, and starts editing the cell.\n         * @param {number} rowKey - rowKey\n         */\n        focusInToRow: function focusInToRow(rowKey) {\n          var focusModel = this.focusModel;\n          focusModel.focusIn(rowKey, focusModel.firstColumnName(), true);\n        },\n\n        /**\n         * Executes the custom handler (defined by user) of the input events.\n         * @param {Event} event - DOM Event object\n         * @param {{rowKey:String, columnName:String}} address - cell address\n         */\n        executeCustomInputEventHandler: function executeCustomInputEventHandler(event, address) {\n          var columnModel = this.columnModel.getColumnModel(address.columnName);\n          var eventType, editOptions, handler;\n\n          if (!columnModel) {\n            return;\n          }\n\n          eventType = event.type;\n          editOptions = columnModel.editOptions || {};\n          handler = editOptions[getEventHandlerName(eventType)];\n\n          if (_.isFunction(handler)) {\n            handler.call(event.target, event, address);\n          }\n        },\n\n        /**\n         * Sets the value of the given cell.\n         * @param {{rowKey:String, columnName:String}} address - cell address\n         * @param {(Number|String|Boolean)} value - value\n         */\n        setValue: function setValue(address, value) {\n          var columnModel = this.columnModel.getColumnModel(address.columnName);\n\n          if (_.isString(value)) {\n            value = $.trim(value);\n          }\n\n          if (columnModel.validation && columnModel.validation.dataType === 'number') {\n            value = convertToNumber(value);\n          }\n\n          if (columnModel.name === '_button') {\n            if (value) {\n              this.dataModel.check(address.rowKey);\n            } else {\n              this.dataModel.uncheck(address.rowKey);\n            }\n          } else {\n            this.dataModel.setValue(address.rowKey, address.columnName, value);\n          }\n        },\n\n        /**\n         * Sets the value of the given cell, if the given column is not using view-mode.\n         * @param {{rowKey:String, columnName:String}} address - cell address\n         * @param {(Number|String|Boolean)} value - value\n         */\n        setValueIfNotUsingViewMode: function setValueIfNotUsingViewMode(address, value) {\n          var columnModel = this.columnModel.getColumnModel(address.columnName);\n\n          if (!snippet.pick(columnModel, 'editOptions', 'useViewMode')) {\n            this.setValue(address, value);\n          }\n        },\n\n        /**\n         * Change tree expanded state\n         * @param {string} rowKey - Row key\n         * @param {boolean} state - State of expanded\n         */\n        changeTreeExpanded: function changeTreeExpanded(rowKey, state) {\n          if (state) {\n            this.dataModel.treeCollapse(rowKey);\n          } else {\n            this.dataModel.treeExpand(rowKey);\n          }\n        }\n      });\n      /**\n       * Converts given value to a number type and returns it.\n       * If the value is not a number type, returns the original value.\n       * @param {*} value - value\n       * @returns {*}\n       */\n\n      function convertToNumber(value) {\n        if (_.isString(value)) {\n          value = value.replace(/,/g, '');\n        }\n\n        if (_.isNumber(value) || isNaN(value) || util.isBlank(value)) {\n          return value;\n        }\n\n        return Number(value);\n      }\n      /**\n       * Returns a property name of a custom event handler matched to the given eventType\n       * @param {string} eventType - event type\n       * @returns {string}\n       */\n\n\n      function getEventHandlerName(eventType) {\n        switch (eventType) {\n          case 'focusin':\n            return 'onFocus';\n\n          case 'focusout':\n            return 'onBlur';\n\n          case 'keydown':\n            return 'onKeyDown';\n\n          default:\n            return '';\n        }\n      }\n\n      module.exports = PainterController;\n      /***/\n    },\n    /* 73 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Add-on for binding to remote data\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var Backbone = __webpack_require__(5);\n\n      var _ = __webpack_require__(2);\n\n      var View = __webpack_require__(4);\n\n      var Router = __webpack_require__(74);\n\n      var util = __webpack_require__(17);\n\n      var formUtil = __webpack_require__(75);\n\n      var i18n = __webpack_require__(42);\n\n      var GridEvent = __webpack_require__(16);\n\n      var renderStateMap = __webpack_require__(10).renderState;\n\n      var DELAY_FOR_LOADING_STATE = 200;\n      var requestMessageMap = {\n        createData: 'net.confirmCreate',\n        updateData: 'net.confirmUpdate',\n        deleteData: 'net.confirmDelete',\n        modifyData: 'net.confirmModify'\n      };\n      var errorMessageMap = {\n        createData: 'net.noDataToCreate',\n        updateData: 'net.noDataToUpdate',\n        deleteData: 'net.noDataToDelete',\n        modifyData: 'net.noDataToModify'\n      };\n      /**\n       * Add-on for binding to remote data\n       * @module addon/net\n       * @param {object} options\n       *      @param {jquery} [options.el] - Form element (to be used for ajax request)\n       *      @param {boolean} [options.initialRequest=true] - Whether to request 'readData' after initialized\n       *      @param {string} [options.readDataMethod='POST'] - Http method to be used for 'readData' API ('POST' or 'GET')\n       *      @param {object} [options.api] - URL map\n       *          @param {string} [options.api.readData] - URL for read-data\n       *          @param {string} [options.api.createData] - URL for create\n       *          @param {string} [options.api.updateData] - URL for update\n       *          @param {string} [options.api.modifyData] - URL for modify (create/update/delete at once)\n       *          @param {string} [options.api.deleteData] - URL for delete\n       *          @param {string} [options.api.downloadExcel] - URL for download data of this page as an excel-file\n       *          @param {string} [options.api.downloadExcelAll] - URL for download all data as an excel-file\n       *      @param {number} [options.perPage=500] - The number of items to be shown in a page\n       *      @param {boolean} [options.enableAjaxHistory=true] - Whether to use the browser history for the ajax requests\n       *      @param {boolean} [options.withCredentials=false] - Use withCredentials flag of XMLHttpRequest for ajax requests if true\n      allow cross-domain requests if true\n       * @example\n       *   <form id=\"data_form\">\n       *   <input type=\"text\" name=\"query\"/>\n       *   </form>\n       *   <script>\n       *      var net;\n       *      var grid = new tui.Grid({\n       *          //...options...\n       *      });\n       *\n       *      // Activate 'Net' addon\n       *      grid.use('Net', {\n       *         el: $('#data_form'),\n       *         initialRequest: true,\n       *         readDataMethod: 'GET',\n       *         perPage: 500,\n       *         enableAjaxHistory: true,\n       *         withCredentials: false,\n       *         api: {\n       *             'readData': './api/read',\n       *             'createData': './api/create',\n       *             'updateData': './api/update',\n       *             'deleteData': './api/delete',\n       *             'modifyData': './api/modify',\n       *             'downloadExcel': './api/download/excel',\n       *             'downloadExcelAll': './api/download/excelAll'\n       *         }\n       *      });\n       *\n       *      // Bind event handlers\n       *      grid.on('beforeRequest', function(data) {\n       *          // For all requests\n       *      }).on('response', function(data) {\n       *          // For all response (regardless of success or failure)\n       *      }).on('successResponse', function(data) {\n       *          // Only if response.result is true\n       *      }).on('failResponse', function(data) {\n       *          // Only if response.result is false\n       *      }).on('errorResponse', function(data) {\n       *          // For error response\n       *      });\n       *\n       *      net = grid.getAddOn('Net');\n       *\n       *      // Request create\n       *      net.request('createData');\n       *\n       *      // Request update\n       *      net.request('updateData');\n       *\n       *      // Request delete\n       *      net.request('deleteData');\n       *\n       *      // Request create/update/delete at once\n       *      net.request('modifyData');\n       *   </script>\n       */\n\n      var Net = View.extend(\n      /** @lends module:addon/net.prototype */\n      {\n        initialize: function initialize(options) {\n          var defaultOptions = {\n            initialRequest: true,\n            perPage: 500,\n            enableAjaxHistory: true,\n            withCredentials: false\n          };\n          var defaultApi = {\n            readData: '',\n            createData: '',\n            updateData: '',\n            deleteData: '',\n            modifyData: '',\n            downloadExcel: '',\n            downloadExcelAll: ''\n          };\n          options = _.assign(defaultOptions, options);\n          options.api = _.assign(defaultApi, options.api);\n\n          _.assign(this, {\n            // models\n            dataModel: options.dataModel,\n            renderModel: options.renderModel,\n            // extra objects\n            router: null,\n            domEventBus: options.domEventBus,\n            pagination: options.pagination,\n            // configs\n            api: options.api,\n            enableAjaxHistory: options.enableAjaxHistory,\n            readDataMethod: options.readDataMethod || 'POST',\n            perPage: options.perPage,\n            withCredentials: options.withCredentials,\n            // state data\n            curPage: 1,\n            timeoutIdForDelay: null,\n            requestedFormData: null,\n            isLocked: false,\n            lastRequestedReadData: null\n          });\n\n          this._initializeDataModelNetwork();\n\n          this._initializeRouter();\n\n          this._initializePagination();\n\n          this.listenTo(this.dataModel, 'sortChanged', this._onSortChanged);\n          this.listenTo(this.domEventBus, 'click:excel', this._onClickExcel);\n\n          if (options.initialRequest) {\n            if (!this.lastRequestedReadData) {\n              this._readDataAt(1, false);\n            }\n          }\n        },\n        tagName: 'form',\n        events: {\n          submit: '_onSubmit'\n        },\n\n        /**\n         * pagination instance 를 초기화 한다.\n         * @private\n         */\n        _initializePagination: function _initializePagination() {\n          var pagination = this.pagination;\n\n          if (pagination) {\n            pagination.setItemsPerPage(this.perPage);\n            pagination.setTotalItems(1);\n            pagination.on('beforeMove', $.proxy(this._onPageBeforeMove, this));\n          }\n        },\n\n        /**\n         * Event listener for 'route:read' event on Router\n         * @param  {String} queryStr - Query string\n         * @private\n         */\n        _onRouterRead: function _onRouterRead(queryStr) {\n          var data = util.toQueryObject(queryStr);\n\n          this._requestReadData(data);\n        },\n\n        /**\n         * Event listener for 'click:excel' event on domEventBus\n         * @param {module:event/gridEvent} gridEvent - GridEvent\n         * @private\n         */\n        _onClickExcel: function _onClickExcel(gridEvent) {\n          var downloadType = gridEvent.type === 'all' ? 'excelAll' : 'excel';\n          this.download(downloadType);\n        },\n\n        /**\n         * dataModel 이 network 통신을 할 수 있도록 설정한다.\n         * @private\n         */\n        _initializeDataModelNetwork: function _initializeDataModelNetwork() {\n          this.dataModel.url = this.api.readData;\n          this.dataModel.sync = $.proxy(this._sync, this);\n        },\n\n        /**\n         * ajax history 를 사용하기 위한 router 를 초기화한다.\n         * @private\n         */\n        _initializeRouter: function _initializeRouter() {\n          if (this.enableAjaxHistory) {\n            this.router = new Router({\n              net: this\n            });\n            this.listenTo(this.router, 'route:read', this._onRouterRead);\n\n            if (!Backbone.History.started) {\n              Backbone.history.start();\n            }\n          }\n        },\n\n        /**\n         * pagination 에서 before page move가 발생했을 때 이벤트 핸들러\n         * @param {{page:number}} customEvent pagination 으로부터 전달받는 이벤트 객체\n         * @private\n         */\n        _onPageBeforeMove: function _onPageBeforeMove(customEvent) {\n          var page = customEvent.page;\n\n          if (this.curPage !== page) {\n            this._readDataAt(page, true);\n          }\n        },\n\n        /**\n         * form 의 submit 이벤트 발생시 이벤트 핸들러\n         * @param {event} submitEvent   submit 이벤트 객체\n         * @private\n         */\n        _onSubmit: function _onSubmit(submitEvent) {\n          submitEvent.preventDefault();\n\n          this._readDataAt(1, false);\n        },\n\n        /**\n         * 폼 데이터를 설정한다.\n         * @param {Object} data - 폼 데이터 정보\n         * @private\n         */\n        _setFormData: function _setFormData(data) {\n          var formData = _.clone(data);\n\n          _.each(this.lastRequestedReadData, function (value, key) {\n            if ((_.isUndefined(formData[key]) || _.isNull(formData[key])) && value) {\n              formData[key] = '';\n            }\n          });\n\n          formUtil.setFormData(this.$el, formData);\n        },\n\n        /**\n         * fetch 수행 이후 custom ajax 동작 처리를 위해 Backbone 의 기본 sync 를 오버라이드 하기위한 메서드.\n         * @param {String} method   router 로부터 전달받은 method 명\n         * @param {Object} model    fetch 를 수행한 dataModel\n         * @param {Object} options  request 정보\n         * @private\n         */\n        _sync: function _sync(method, model, options) {\n          var params;\n\n          if (method === 'read') {\n            options = options || {};\n            params = $.extend({}, options);\n\n            if (!options.url) {\n              params.url = _.result(model, 'url');\n            }\n\n            this._ajax(params);\n          } else {\n            Backbone.sync(Backbone, method, model, options);\n          }\n        },\n\n        /**\n         * network 통신에 대한 _lock 을 건다.\n         * @private\n         */\n        _lock: function _lock() {\n          var renderModel = this.renderModel;\n          this.timeoutIdForDelay = setTimeout(function () {\n            renderModel.set('state', renderStateMap.LOADING);\n          }, DELAY_FOR_LOADING_STATE);\n          this.isLocked = true;\n        },\n\n        /**\n         * network 통신에 대해 unlock 한다.\n         * loading layer hide 는 rendering 하는 로직에서 수행한다.\n         * @private\n         */\n        _unlock: function _unlock() {\n          if (this.timeoutIdForDelay !== null) {\n            clearTimeout(this.timeoutIdForDelay);\n            this.timeoutIdForDelay = null;\n          }\n\n          this.isLocked = false;\n        },\n\n        /**\n         * form 으로 지정된 엘리먼트의 Data 를 반환한다.\n         * @returns {object} formData 데이터 오브젝트\n         * @private\n         */\n        _getFormData: function _getFormData() {\n          return formUtil.getFormData(this.$el);\n        },\n\n        /**\n         * DataModel 에서 Backbone.fetch 수행 이후 success 콜백\n         * @param {object} dataModel grid 의 dataModel\n         * @param {object} responseData 응답 데이터\n         * @private\n         */\n        _onReadSuccess: function _onReadSuccess(dataModel, responseData) {\n          var pagination = this.pagination;\n          var page, totalCount;\n          dataModel.setOriginalRowList();\n\n          if (pagination && responseData.pagination) {\n            page = responseData.pagination.page;\n            totalCount = responseData.pagination.totalCount;\n            pagination.setItemsPerPage(this.perPage);\n            pagination.setTotalItems(totalCount);\n            pagination.movePageTo(page);\n            this.curPage = page;\n          }\n        },\n\n        /**\n         * DataModel 에서 Backbone.fetch 수행 이후 error 콜백\n         * @param {object} dataModel grid 의 dataModel\n         * @param {object} responseData 응답 데이터\n         * @param {object} options  ajax 요청 정보\n         * @private\n         */\n        _onReadError: function _onReadError(dataModel, responseData, options) {},\n        // eslint-disable-line\n\n        /**\n         * Requests 'readData' with last requested data.\n         */\n        reloadData: function reloadData() {\n          this._requestReadData(this.lastRequestedReadData);\n        },\n\n        /**\n         * Requests 'readData' to the server. The last requested data will be extended with new data.\n         * @param {Number} page - Page number\n         * @param {Object} data - Data(parameters) to send to the server\n         * @param {Boolean} resetData - If set to true, last requested data will be ignored.\n         */\n        readData: function readData(page, data, resetData) {\n          if (resetData) {\n            if (!data) {\n              data = {};\n            }\n\n            data.perPage = this.perPage;\n\n            this._changeSortOptions(data, this.dataModel.sortOptions);\n          } else {\n            data = _.assign({}, this.lastRequestedReadData, data);\n          }\n\n          data.page = page;\n\n          this._requestReadData(data);\n        },\n\n        /**\n         * 데이터 조회 요청.\n         * @param {object} data 요청시 사용할 request 파라미터\n         * @private\n         */\n        _requestReadData: function _requestReadData(data) {\n          var startNumber = 1;\n\n          this._setFormData(data);\n\n          if (!this.isLocked) {\n            this.renderModel.initializeVariables();\n\n            this._lock();\n\n            this.requestedFormData = _.clone(data);\n            this.curPage = data.page || this.curPage;\n            startNumber = (this.curPage - 1) * this.perPage + 1;\n            this.renderModel.set({\n              startNumber: startNumber\n            }); // 마지막 요청한 reloadData에서 사용하기 위해 data 를 저장함.\n\n            this.lastRequestedReadData = _.clone(data);\n            this.dataModel.fetch({\n              requestType: 'readData',\n              data: data,\n              type: this.readDataMethod,\n              success: $.proxy(this._onReadSuccess, this),\n              error: $.proxy(this._onReadError, this),\n              reset: true,\n              withCredentials: this.withCredentials\n            });\n            this.dataModel.setSortOptionValues(data.sortColumn, data.sortAscending);\n          }\n\n          if (this.router) {\n            this.router.navigate('read/' + util.toQueryString(data), {\n              trigger: false\n            });\n          }\n        },\n\n        /**\n         * sortChanged 이벤트 발생시 실행되는 함수\n         * @private\n         * @param {object} sortOptions 정렬 옵션\n         * @param {string} sortOptions.sortColumn 정렬할 컬럼명\n         * @param {boolean} sortOptions.ascending 오름차순 여부\n         */\n        _onSortChanged: function _onSortChanged(sortOptions) {\n          if (sortOptions.requireFetch) {\n            this._readDataAt(1, true, sortOptions);\n          }\n        },\n\n        /**\n         * 데이터 객체의 정렬 옵션 관련 값을 변경한다.\n         * @private\n         * @param {object} data 데이터 객체\n         * @param {object} sortOptions 정렬 옵션\n         * @param {string} sortOptions.sortColumn 정렬할 컬럼명\n         * @param {boolean} sortOptions.ascending 오름차순 여부\n         */\n        _changeSortOptions: function _changeSortOptions(data, sortOptions) {\n          if (!sortOptions) {\n            return;\n          }\n\n          if (sortOptions.columnName === 'rowKey') {\n            delete data.sortColumn;\n            delete data.sortAscending;\n          } else {\n            data.sortColumn = sortOptions.columnName;\n            data.sortAscending = sortOptions.ascending;\n          }\n        },\n\n        /**\n         * 현재 form data 기준으로, page 에 해당하는 데이터를 조회 한다.\n         * @param {Number} page 조회할 페이지 정보\n         * @param {Boolean} [isUsingRequestedData=true] page 단위 검색이므로, form 수정여부와 관계없이 처음 보낸 form 데이터로 조회할지 여부를 결정한다.\n         * @param {object} sortOptions 정렬 옵션\n         * @param {string} sortOptions.sortColumn 정렬할 컬럼명\n         * @param {boolean} sortOptions.ascending 오름차순 여부\n         * @private\n         */\n        _readDataAt: function _readDataAt(page, isUsingRequestedData, sortOptions) {\n          var data;\n          isUsingRequestedData = _.isUndefined(isUsingRequestedData) ? true : isUsingRequestedData;\n          data = isUsingRequestedData ? this.requestedFormData : this._getFormData();\n          data.page = page;\n          data.perPage = this.perPage;\n\n          this._changeSortOptions(data, sortOptions);\n\n          this._requestReadData(data);\n        },\n\n        /**\n         * Send request to server to sync data\n         * @param {String} requestType - 'createData|updateData|deleteData|modifyData'\n         * @param {object} options - Options\n         *      @param {String} [options.url] - URL to send the request\n         *      @param {boolean} [options.hasDataParam=true] - Whether the row-data to be included in the request param\n         *      @param {boolean} [options.checkedOnly=true] - Whether the request param only contains checked rows\n         *      @param {boolean} [options.modifiedOnly=true] - Whether the request param only contains modified rows\n         *      @param {boolean} [options.showConfirm=true] - Whether to show confirm dialog before sending request\n         *      @param {boolean} [options.updateOriginal=false] - Whether to update original data with current data\n         *      @param {boolean} [options.withCredentials=false] - Use withCredentials flag of XMLHttpRequest for ajax requests if true\n         * @returns {boolean} Whether requests or not\n         */\n        request: function request(requestType, options) {\n          var newOptions = _.extend({\n            url: this.api[requestType],\n            type: null,\n            hasDataParam: true,\n            checkedOnly: true,\n            modifiedOnly: true,\n            showConfirm: true,\n            updateOriginal: false\n          }, options);\n\n          var param = this._getRequestParam(requestType, newOptions);\n\n          if (param) {\n            if (newOptions.updateOriginal) {\n              this.dataModel.setOriginalRowList();\n            }\n\n            this._ajax(param);\n          }\n\n          return !!param;\n        },\n\n        /**\n         * Change window.location to registered url for downloading data\n         * @param {string} type - Download type. 'excel' or 'excelAll'.\n         *        Will be matched with API 'downloadExcel', 'downloadExcelAll'.\n         */\n        download: function download(type) {\n          var apiName = 'download' + util.toUpperCaseFirstLetter(type),\n              data = this.requestedFormData,\n              url = this.api[apiName],\n              paramStr;\n\n          if (type === 'excel') {\n            data.page = this.curPage;\n            data.perPage = this.perPage;\n          } else {\n            data = _.omit(data, 'page', 'perPage');\n          }\n\n          paramStr = $.param(data);\n          window.location = url + '?' + paramStr;\n        },\n\n        /**\n         * Set number of rows per page and reload current page\n         * @param {number} perPage - Number of rows per page\n         */\n        setPerPage: function setPerPage(perPage) {\n          this.perPage = perPage;\n\n          this._readDataAt(1);\n        },\n\n        /**\n         * 서버로 요청시 사용될 파라미터 중 Grid 의 데이터에 해당하는 데이터를 Option 에 맞추어 반환한다.\n         * @param {String} requestType  요청 타입. 'createData|updateData|deleteData|modifyData' 중 하나를 인자로 넘긴다.\n         * @param {Object} [options] Options\n         *      @param {boolean} [options.hasDataParam=true] request 데이터에 rows 관련 데이터가 포함될 지 여부.\n         *      @param {boolean} [options.modifiedOnly=true] rows 관련 데이터 중 수정된 데이터만 포함할 지 여부\n         *      @param {boolean} [options.checkedOnly=true] rows 관련 데이터 중 checked 된 데이터만 포함할 지 여부\n         * @returns {{count: number, data: {requestType: string, url: string, rows: object,\n         *      type: string, dataType: string}}} 옵션 조건에 해당하는 그리드 데이터 정보\n         * @private\n         */\n        _getDataParam: function _getDataParam(requestType, options) {\n          var dataModel = this.dataModel,\n              checkMap = {\n            createData: ['createdRows'],\n            updateData: ['updatedRows'],\n            deleteData: ['deletedRows'],\n            modifyData: ['createdRows', 'updatedRows', 'deletedRows']\n          },\n              checkList = checkMap[requestType],\n              data = {},\n              count = 0,\n              dataMap;\n          options = _.defaults(options || {}, {\n            hasDataParam: true,\n            modifiedOnly: true,\n            checkedOnly: true\n          });\n\n          if (options.hasDataParam) {\n            if (options.modifiedOnly) {\n              // {createdRows: [], updatedRows:[], deletedRows: []} 에 담는다.\n              dataMap = dataModel.getModifiedRows({\n                checkedOnly: options.checkedOnly\n              });\n\n              _.each(dataMap, function (list, name) {\n                if (_.contains(checkList, name) && list.length) {\n                  count += list.length;\n                  data[name] = JSON.stringify(list);\n                }\n              }, this);\n            } else {\n              // {rows: []} 에 담는다.\n              data.rows = dataModel.getRows(options.checkedOnly);\n              count = data.rows.length;\n            }\n          }\n\n          return {\n            data: data,\n            count: count\n          };\n        },\n\n        /**\n         * requestType 에 따라 서버에 요청할 파라미터를 반환한다.\n         * @param {String} requestType 요청 타입. 'createData|updateData|deleteData|modifyData' 중 하나를 인자로 넘긴다.\n         * @param {Object} [options] Options\n         *      @param {String} [options.url=this.api[requestType]] 요청할 url.\n         *      지정하지 않을 시 option 으로 넘긴 API 중 request Type 에 해당하는 url 로 지정됨\n         *      @param {String} [options.type='POST'] request method 타입\n         *      @param {boolean} [options.hasDataParam=true] request 데이터에 rowList 관련 데이터가 포함될 지 여부.\n         *      @param {boolean} [options.modifiedOnly=true] rowList 관련 데이터 중 수정된 데이터만 포함할 지 여부\n         *      @param {boolean} [options.checkedOnly=true] rowList 관련 데이터 중 checked 된 데이터만 포함할 지 여부\n         * @returns {{requestType: string, url: string, data: object, type: string, dataType: string}}\n         *      ajax 호출시 사용될 option 파라미터\n         * @private\n         */\n        _getRequestParam: function _getRequestParam(requestType, options) {\n          var defaultOptions = {\n            url: this.api[requestType],\n            type: null,\n            hasDataParam: true,\n            modifiedOnly: true,\n            checkedOnly: true,\n            withCredentials: this.withCredentials\n          };\n          var newOptions = $.extend(defaultOptions, options);\n\n          var dataParam = this._getDataParam(requestType, newOptions);\n\n          var param = null;\n\n          if (!newOptions.showConfirm || this._isConfirmed(requestType, dataParam.count)) {\n            param = {\n              requestType: requestType,\n              url: newOptions.url,\n              data: dataParam.data,\n              type: newOptions.type,\n              withCredentials: newOptions.withCredentials\n            };\n          }\n\n          return param;\n        },\n\n        /**\n         * requestType 에 따른 컨펌 메세지를 노출한다.\n         * @param {String} requestType 요청 타입. 'createData|updateData|deleteData|modifyData' 중 하나를 인자로 넘긴다.\n         * @param {Number} count   전송될 데이터 개수\n         * @returns {boolean}    계속 진행할지 여부를 반환한다.\n         * @private\n         */\n        _isConfirmed: function _isConfirmed(requestType, count) {\n          var result = false;\n\n          if (count > 0) {\n            result = confirm(this._getConfirmMessage(requestType, count));\n          } else {\n            alert(this._getConfirmMessage(requestType, count));\n          }\n\n          return result;\n        },\n\n        /**\n         * confirm message 를 반환한다.\n         * @param {String} requestType 요청 타입. 'createData|updateData|deleteData|modifyData' 중 하나를 인자로 넘긴다.\n         * @param {Number} count 전송될 데이터 개수\n         * @returns {string} 생성된 confirm 메세지\n         * @private\n         */\n        _getConfirmMessage: function _getConfirmMessage(requestType, count) {\n          var messageKey = count > 0 ? requestMessageMap[requestType] : errorMessageMap[requestType];\n          var replacedValues = {\n            count: count\n          };\n          return i18n.get(messageKey, replacedValues);\n        },\n\n        /**\n         * Request server using $.ajax\n         * @param {object} options - request parameters for $.ajax\n         *     @param {string} options.url - url\n         *     @param {object} [options.data] - data\n         *     @param {string} [options.type] - 'GET|POST'\n         *     @param {string} [options.dataType] - 'text|html|xml|json|jsonp'\n         *     @param {string} [options.requestType] - 'createData|updateData|deleteData|modifyData'\n         *     @param {boolean} [options.withCredentials=false] - use withCredentials flag of XMLHttpRequest for ajax requests if true\n         * @private\n         */\n        _ajax: function _ajax(options) {\n          var gridEvent = new GridEvent(null, options.data);\n          var params;\n          /**\n           * Occurs before the http request is sent\n           * @event Grid#beforeRequest\n           * @type {module:event/gridEvent}\n           * @property {Grid} instance - Current grid instance\n           */\n\n          this.trigger('beforeRequest', gridEvent);\n\n          if (gridEvent.isStopped()) {\n            return;\n          }\n\n          options = $.extend({\n            requestType: ''\n          }, options);\n          params = {\n            url: options.url,\n            data: options.data || {},\n            type: options.type || 'POST',\n            dataType: options.dataType || 'json',\n            complete: $.proxy(this._onComplete, this, options.complete, options),\n            success: $.proxy(this._onSuccess, this, options.success, options),\n            error: $.proxy(this._onError, this, options.error, options),\n            xhrFields: {\n              withCredentials: options.withCredentials\n            }\n          };\n\n          if (options.url) {\n            $.ajax(params);\n          }\n        },\n\n        /**\n         * ajax complete 이벤트 핸들러\n         * @param {Function} callback   통신 완료 이후 수행할 콜백함수\n         * @param {object} jqXHR    jqueryXHR  객체\n         * @param {number} status   http status 정보\n         * @private\n         */\n        _onComplete: function _onComplete(callback, jqXHR, status) {\n          // eslint-disable-line no-unused-vars\n          this._unlock();\n        },\n\n        /* eslint-disable complexity */\n\n        /**\n         * ajax success 이벤트 핸들러\n         * @param {Function} callback Callback function\n         * @param {{requestType: string, url: string, data: object, type: string, dataType: string}} options ajax 요청 파라미터\n         * @param {Object} responseData 응답 데이터\n         * @param {number} status   http status 정보\n         * @param {object} jqXHR    jqueryXHR  객체\n         * @private\n         */\n        _onSuccess: function _onSuccess(callback, options, responseData, status, jqXHR) {\n          var responseMessage = responseData && responseData.message;\n          var gridEvent = new GridEvent(null, {\n            httpStatus: status,\n            requestType: options.requestType,\n            requestParameter: options.data,\n            responseData: responseData\n          });\n          /**\n           * Occurs when the response is received from the server\n           * @event Grid#response\n           * @type {module:event/gridEvent}\n           * @property {number} httpStatus - HTTP status\n           * @property {string} requestType - Request type\n           * @property {string} requestParameter - Request parameters\n           * @property {Object} responseData - response data\n           * @property {Grid} instance - Current grid instance\n           */\n\n          this.trigger('response', gridEvent);\n\n          if (gridEvent.isStopped()) {\n            return;\n          }\n\n          if (responseData && responseData.result) {\n            /**\n             * Occurs after the response event, if the result is true\n             * @event Grid#successResponse\n             * @type {module:event/gridEvent}\n             * @property {number} httpStatus - HTTP status\n             * @property {string} requestType - Request type\n             * @property {string} requestParameter - Request parameter\n             * @property {Object} responseData - response data\n             * @property {Grid} instance - Current grid instance\n             */\n            this.trigger('successResponse', gridEvent);\n\n            if (gridEvent.isStopped()) {\n              return;\n            }\n\n            if (_.isFunction(callback)) {\n              callback(responseData.data || {}, status, jqXHR);\n            }\n          } else {\n            /**\n             * Occurs after the response event, if the result is false\n             * @event Grid#failResponse\n             * @type {module:event/gridEvent}\n             * @property {number} httpStatus - HTTP status\n             * @property {string} requestType - Request type\n             * @property {string} requestParameter - Request parameter\n             * @property {Object} responseData - response data\n             * @property {Grid} instance - Current grid instance\n             */\n            this.trigger('failResponse', gridEvent);\n\n            if (gridEvent.isStopped()) {\n              return;\n            }\n\n            if (responseMessage) {\n              alert(responseMessage);\n            }\n          }\n        },\n\n        /* eslint-enable complexity */\n\n        /**\n         * ajax error 이벤트 핸들러\n         * @param {Function} callback Callback function\n         * @param {{requestType: string, url: string, data: object, type: string, dataType: string}} options ajax 요청 파라미터\n         * @param {object} jqXHR    jqueryXHR  객체\n         * @param {number} status   http status 정보\n         * @param {String} errorMessage 에러 메세지\n         * @private\n         */\n        _onError: function _onError(callback, options, jqXHR, status) {\n          var eventData = new GridEvent(null, {\n            httpStatus: status,\n            requestType: options.requestType,\n            requestParameter: options.data,\n            responseData: null\n          });\n          this.renderModel.set('state', renderStateMap.DONE);\n          this.trigger('response', eventData);\n\n          if (eventData.isStopped()) {\n            return;\n          }\n          /**\n           * Occurs after the response event, if the response is Error\n           * @event Grid#errorResponse\n           * @type {module:event/gridEvent}\n           * @property {number} httpStatus - HTTP status\n           * @property {string} requestType - Request type\n           * @property {string} requestParameter - Request parameters\n           * @property {Grid} instance - Current grid instance\n           */\n\n\n          this.trigger('errorResponse', eventData);\n\n          if (eventData.isStopped()) {\n            return;\n          }\n\n          if (jqXHR.readyState > 1) {\n            alert(i18n.get('net.failResponse'));\n          }\n        }\n      });\n      module.exports = Net;\n      /***/\n    },\n    /* 74 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Router for Addon.Net\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var Backbone = __webpack_require__(5);\n      /**\n       * Router for Addon.Net\n       * @module addon/net-router\n       * @param  {object} attributes - Attributes\n       * @ignore\n       */\n\n\n      var Router = Backbone.Router.extend(\n      /** @lends module:addon/net-router.prototype */\n      {\n        initialize: function initialize(attributes) {\n          this.net = attributes.net;\n        },\n        routes: {\n          'read/:queryStr': 'read'\n        }\n      });\n      module.exports = Router;\n      /***/\n    },\n    /* 75 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Utilities for form data, form element\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n      /**\n       * @module formUtil\n       * @ignore\n       */\n\n\n      var formUtil = {\n        /**\n         * form 의 input 요소 값을 설정하기 위한 객체\n         * @alias form.setInput\n         * @memberof module:util\n         */\n        setInput: {\n          /**\n           * 배열의 값들을 전부 String 타입으로 변환한다.\n           * @ignore\n           * @param {Array}  arr 변환할 배열\n           * @returns {Array} 변환된 배열 결과 값\n           */\n          '_changeToStringInArray': function _changeToStringInArray(arr) {\n            _.each(arr, function (value, i) {\n              arr[i] = String(value);\n            });\n\n            return arr;\n          },\n\n          /**\n           * radio type 의 input 요소의 값을 설정한다.\n           * @ignore\n           * @param {HTMLElement} targetElement - Target element\n           * @param {String} formValue - Form value\n           */\n          'radio': function radio(targetElement, formValue) {\n            targetElement.checked = targetElement.value === formValue;\n          },\n\n          /**\n           * radio type 의 input 요소의 값을 설정한다.\n           * @ignore\n           * @memberof module:util\n           * @param {HTMLElement} targetElement - Target element\n           * @param {String} formValue - Form value\n           */\n          'checkbox': function checkbox(targetElement, formValue) {\n            if (_.isArray(formValue)) {\n              targetElement.checked = $.inArray(targetElement.value, this._changeToStringInArray(formValue)) !== -1;\n            } else {\n              targetElement.checked = targetElement.value === formValue;\n            }\n          },\n\n          /**\n           * select-one type 의 input 요소의 값을 설정한다.\n           * @ignore\n           * @param {HTMLElement} targetElement - Target element\n           * @param {String} formValue - Form value\n           */\n          'select-one': function selectOne(targetElement, formValue) {\n            var options = snippet.toArray(targetElement.options);\n            targetElement.selectedIndex = _.findIndex(options, function (option) {\n              return option.value === formValue || option.text === formValue;\n            });\n          },\n\n          /**\n           * select-multiple type 의 input 요소의 값을 설정한다.\n           * @ignore\n           * @param {HTMLElement} targetElement - Target element\n           * @param {String} formValue - Form value\n           */\n          'select-multiple': function selectMultiple(targetElement, formValue) {\n            var options = snippet.toArray(targetElement.options);\n\n            if (_.isArray(formValue)) {\n              formValue = this._changeToStringInArray(formValue);\n\n              _.each(options, function (targetOption) {\n                targetOption.selected = $.inArray(targetOption.value, formValue) !== -1 || $.inArray(targetOption.text, formValue) !== -1;\n              });\n            } else {\n              this['select-one'].apply(this, arguments);\n            }\n          },\n\n          /**\n           * input 요소의 값을 설정하는 default 로직\n           * @memberof module:util\n           * @param {HTMLElement} targetElement - Target element\n           * @param {String} formValue - Form value\n           */\n          'defaultAction': function defaultAction(targetElement, formValue) {\n            targetElement.value = formValue;\n          }\n        },\n\n        /**\n         * $form 에 정의된 인풋 엘리먼트들의 값을 모아서 DataObject 로 구성하여 반환한다.\n         * @memberof module:util\n         * @alias form.getFormData\n         * @param {jQuery} $form jQuery()로 감싼 폼엘리먼트\n         * @returns {object} form 내의 데이터들을 key:value 형태의 DataObject 로 반환한다.\n         **/\n        getFormData: function getFormData($form) {\n          var result = {},\n              valueList = $form.serializeArray(),\n              isExisty = snippet.isExisty;\n\n          _.each(valueList, function (obj) {\n            var value = obj.value || '',\n                name = obj.name;\n\n            if (isExisty(result[name])) {\n              result[name] = [].concat(result[name], value);\n            } else {\n              result[name] = value;\n            }\n          });\n\n          return result;\n        },\n\n        /**\n         * 폼 안에 있는 모든 인풋 엘리먼트를 배열로 리턴하거나, elementName에 해당하는 인풋 엘리먼트를 리턴한다.\n         * @memberof module:util\n         * @alias form.getFormElement\n         * @param {jQuery} $form jQuery()로 감싼 폼엘리먼트\n         * @param {String} [elementName] 특정 이름의 인풋 엘리먼트만 가져오고 싶은 경우 전달하며, 생략할 경우 모든 인풋 엘리먼트를 배열 형태로 리턴한다.\n         * @returns {jQuery} jQuery 로 감싼 엘리먼트를 반환한다.\n         */\n        getFormElement: function getFormElement($form, elementName) {\n          var formElement;\n\n          if ($form && $form.length) {\n            if (elementName) {\n              formElement = $form.prop('elements')[String(elementName)];\n            } else {\n              formElement = $form.prop('elements');\n            }\n          }\n\n          return $(formElement);\n        },\n\n        /**\n         * 파라미터로 받은 데이터 객체를 이용하여 폼내에 해당하는 input 요소들의 값을 설정한다.\n         * @memberof module:util\n         * @alias form.setFormData\n         * @param {jQuery} $form jQuery()로 감싼 폼엘리먼트\n         * @param {Object} formData 폼에 설정할 폼 데이터 객체\n         **/\n        setFormData: function setFormData($form, formData) {\n          _.each(formData, function (value, property) {\n            this.setFormElementValue($form, property, value);\n          }, this);\n        },\n\n        /**\n         * elementName에 해당하는 인풋 엘리먼트에 formValue 값을 설정한다.\n         * -인풋 엘리먼트의 이름을 기준으로 하기에 라디오나 체크박스 엘리먼트에 대해서도 쉽게 값을 설정할 수 있다.\n         * @memberof module:util\n         * @alias form.setFormElementValue\n         * @param {jQuery} $form jQuery()로 감싼 폼엘리먼트\n         * @param {String}  elementName 값을 설정할 인풋 엘리먼트의 이름\n         * @param {String|Array} formValue 인풋 엘리먼트에 설정할 값으로 체크박스나 멀티플 셀렉트박스인 경우에는 배열로 설정할 수 있다.\n         **/\n        setFormElementValue: function setFormElementValue($form, elementName, formValue) {\n          var $elementList = this.getFormElement($form, elementName),\n              type;\n\n          if (!$elementList.length) {\n            return;\n          }\n\n          if (!_.isArray(formValue)) {\n            formValue = String(formValue);\n          }\n\n          $elementList = snippet.isHTMLTag($elementList) ? [$elementList] : $elementList;\n          $elementList = snippet.toArray($elementList);\n\n          _.each($elementList, function (targetElement) {\n            type = this.setInput[targetElement.type] ? targetElement.type : 'defaultAction';\n            this.setInput[type](targetElement, formValue);\n          }, this);\n        },\n\n        /**\n         * input 타입의 엘리먼트의 커서를 가장 끝으로 이동한다.\n         * @memberof module:util\n         * @alias form.setCursorToEnd\n         * @param {HTMLElement} target HTML input 엘리먼트\n         */\n        setCursorToEnd: function setCursorToEnd(target) {\n          var length = target.value.length,\n              range;\n          target.focus();\n\n          if (target.setSelectionRange) {\n            try {\n              target.setSelectionRange(length, length);\n            } catch (e) {// to prevent unspecified error in IE (occurs when running test)\n            }\n          } else if (target.createTextRange) {\n            range = target.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', length);\n            range.moveStart('character', length);\n\n            try {\n              range.select();\n            } catch (e) {// to prevent unspecified error in IE (occurs when running test)\n            }\n          }\n        }\n      };\n      module.exports = formUtil;\n      /***/\n    },\n    /* 76 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * @fileoverview Component holder\n       * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n       */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var snippet = __webpack_require__(3);\n\n      var defaultOptionsMap = {\n        pagination: null\n      };\n      /**\n       * Component holder\n       * @module componentHolder\n       * @ignore\n       */\n\n      var ComponentHolder = snippet.defineClass(\n      /** @lends module:componentHolder.prototype */\n      {\n        init: function init(optionsMap) {\n          this.optionsMap = $.extend(true, defaultOptionsMap, optionsMap);\n          this.instanceMap = {};\n        },\n\n        /**\n         * Returns an instance of tui.Pagination\n         * @param {String} key - component key\n         * @returns {tui.Pagination}\n         */\n        getInstance: function getInstance(key) {\n          return this.instanceMap[key];\n        },\n\n        /**\n         * Sets an instance of tui.Pagination\n         * @param {String} key - component key\n         * @param {tui.Pagination} instance - pagination instance\n         */\n        setInstance: function setInstance(key, instance) {\n          this.instanceMap[key] = instance;\n        },\n\n        /**\n         * Returns an option object.\n         * @param {String} key - component key\n         * @returns {Object}\n         */\n        getOptions: function getOptions(key) {\n          return this.optionsMap[key];\n        }\n      });\n      module.exports = ComponentHolder;\n      /***/\n    },\n    /* 77 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n      * @fileoverview theme manager\n      * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n      */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var util = __webpack_require__(17);\n\n      var styleGen = __webpack_require__(78);\n\n      var themeNameConst = __webpack_require__(10).themeName;\n\n      var STYLE_ELEMENT_ID = 'tui-grid-theme-style';\n      var presetOptions = {};\n      presetOptions[themeNameConst.DEFAULT] = __webpack_require__(80);\n      presetOptions[themeNameConst.STRIPED] = __webpack_require__(81);\n      presetOptions[themeNameConst.CLEAN] = __webpack_require__(82);\n      /**\n       * build css string with given options.\n       * @param {Object} options - options\n       * @returns {String}\n       * @ignore\n       */\n\n      function buildCssString(options) {\n        var styles = [styleGen.outline(options.outline), styleGen.frozenBorder(options.frozenBorder), styleGen.scrollbar(options.scrollbar), styleGen.heightResizeHandle(options.heightResizeHandle), styleGen.pagination(options.pagination), styleGen.selection(options.selection)];\n        var area = options.area;\n        var cell = options.cell;\n        styles = styles.concat([styleGen.headArea(area.header), styleGen.bodyArea(area.body), styleGen.summaryArea(area.summary)]);\n\n        if (cell) {\n          styles = styles.concat([styleGen.cell(cell.normal), styleGen.cellDummy(cell.dummy), styleGen.cellEditable(cell.editable), styleGen.cellHead(cell.head), styleGen.cellRowHead(cell.rowHead), styleGen.cellSummary(cell.summary), styleGen.cellOddRow(cell.oddRow), styleGen.cellEvenRow(cell.evenRow), styleGen.cellRequired(cell.required), styleGen.cellDisabled(cell.disabled), styleGen.cellInvalid(cell.invalid), styleGen.cellCurrentRow(cell.currentRow), styleGen.cellSelectedHead(cell.selectedHead), styleGen.cellSelectedRowHead(cell.selectedRowHead), styleGen.cellFocused(cell.focused), styleGen.cellFocusedInactive(cell.focusedInactive)]);\n        }\n\n        return styles.join('');\n      }\n      /**\n       * Set document style with given options.\n       * @param {Object} options - options\n       * @ignore\n       */\n\n\n      function setDocumentStyle(options) {\n        var cssString = buildCssString(options);\n        $('#' + STYLE_ELEMENT_ID).remove();\n        util.appendStyleElement(STYLE_ELEMENT_ID, cssString);\n      }\n\n      module.exports = {\n        /**\n         * Creates a style element using theme options identified by given name,\n         * and appends it to the document.\n         * @param {String} themeName - preset theme name\n         * @param {Object} extOptions - if exist, extend preset theme options with it.\n         */\n        apply: function apply(themeName, extOptions) {\n          var options = presetOptions[themeName];\n\n          if (!options) {\n            options = presetOptions[themeNameConst.DEFAULT];\n          }\n\n          options = $.extend(true, {}, options, extOptions);\n          setDocumentStyle(options);\n        },\n\n        /**\n         * Returns whether the style of a theme is applied.\n         * @returns {Boolean}\n         */\n        isApplied: function isApplied() {\n          return $('#' + STYLE_ELEMENT_ID).length === 1;\n        }\n      };\n      /***/\n    },\n    /* 78 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n      * @fileoverview css style generator\n      * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n      */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var builder = __webpack_require__(79);\n\n      var classNameConst = __webpack_require__(19);\n      /**\n       * Shortcut for the builder.createClassRule() method.\n       * @ignore\n       */\n\n\n      var classRule = _.bind(builder.createClassRule, builder);\n      /**\n       * Shortcut for the builder.createClassComposeRule() method.\n       * @ignore\n       */\n\n\n      var classComposeRule = _.bind(builder.createClassComposeRule, builder);\n      /**\n       * Creates a rule string for background and text colors.\n       * @param {String} className - class name\n       * @param {Objecr} options - options\n       * @returns {String}\n       * @ignore\n       */\n\n\n      function bgTextRuleString(className, options) {\n        return classRule(className).bg(options.background).text(options.text).build();\n      }\n      /**\n       * Creates a rule string for background and border colors.\n       * @param {String} className - class name\n       * @param {Objecr} options - options\n       * @returns {String}\n       * @ignore\n       */\n\n\n      function bgBorderRuleString(className, options) {\n        return classRule(className).bg(options.background).border(options.border).build();\n      }\n\n      module.exports = {\n        /**\n         * Generates a css string for grid outline.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        outline: function outline(options) {\n          var borderTopRule = classRule(classNameConst.BORDER_TOP).bg(options.border);\n          var borderBottomRule = classComposeRule(' .', [classNameConst.NO_SCROLL_X, classNameConst.BORDER_BOTTOM]).bg(options.border);\n          var rules = [borderTopRule, borderBottomRule];\n          var borderLeftRule, borderRightRule;\n\n          if (options.showVerticalBorder) {\n            borderLeftRule = classRule(classNameConst.BORDER_LEFT).bg(options.border);\n            borderRightRule = classComposeRule(' .', [classNameConst.NO_SCROLL_Y, classNameConst.BORDER_RIGHT]).bg(options.border);\n            rules = rules.concat([borderLeftRule, borderRightRule]);\n          }\n\n          return builder.buildAll(rules);\n        },\n\n        /**\n         * Generates a css string for border of frozen columns.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        frozenBorder: function frozenBorder(options) {\n          return classRule(classNameConst.FROZEN_BORDER).bg(options.border).build();\n        },\n\n        /**\n         * Generates a css string for scrollbars.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        scrollbar: function scrollbar(options) {\n          var webkitScrollbarRules = builder.createWebkitScrollbarRules('.' + classNameConst.CONTAINER, options);\n          var ieScrollbarRule = builder.createIEScrollbarRule('.' + classNameConst.CONTAINER, options);\n          var xInnerBorderRule = classRule(classNameConst.BORDER_BOTTOM).bg(options.border);\n          var xOuterBorderRule = classRule(classNameConst.CONTENT_AREA).border(options.border);\n          var yInnerBorderRule = classRule(classNameConst.SCROLLBAR_Y_INNER_BORDER).bg(options.border);\n          var yOuterBorderRule = classRule(classNameConst.SCROLLBAR_Y_OUTER_BORDER).bg(options.border);\n          var spaceRightTopRule = classRule(classNameConst.SCROLLBAR_RIGHT_TOP).bg(options.emptySpace).border(options.border);\n          var spaceRightBottomRule = classRule(classNameConst.SCROLLBAR_RIGHT_BOTTOM).bg(options.emptySpace).border(options.border);\n          var spaceLeftBottomRule = classRule(classNameConst.SCROLLBAR_LEFT_BOTTOM).bg(options.emptySpace).border(options.border);\n          var frozenBorderRule = classRule(classNameConst.SCROLLBAR_FROZEN_BORDER).bg(options.emptySpace).border(options.border);\n          return builder.buildAll(webkitScrollbarRules.concat([ieScrollbarRule, xInnerBorderRule, xOuterBorderRule, yInnerBorderRule, yOuterBorderRule, spaceRightTopRule, spaceRightBottomRule, spaceLeftBottomRule, frozenBorderRule]));\n        },\n\n        /**\n         * Generates a css string for a resize-handle.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        heightResizeHandle: function heightResizeHandle(options) {\n          return bgBorderRuleString(classNameConst.HEIGHT_RESIZE_HANDLE, options);\n        },\n\n        /**\n         * Generates a css string for a pagination.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        pagination: function pagination(options) {\n          return bgBorderRuleString(classNameConst.PAGINATION, options);\n        },\n\n        /**\n         * Generates a css string for selection layers.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        selection: function selection(options) {\n          return bgBorderRuleString(classNameConst.LAYER_SELECTION, options);\n        },\n\n        /**\n         * Generates a css string for head area.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        headArea: function headArea(options) {\n          return classRule(classNameConst.HEAD_AREA).bg(options.background).border(options.border).build();\n        },\n\n        /**\n         * Generates a css string for body area.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        bodyArea: function bodyArea(options) {\n          return classRule(classNameConst.BODY_AREA).bg(options.background).build();\n        },\n\n        /**\n         * Generates a css string for summary area.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        summaryArea: function summaryArea(options) {\n          var contentAreaRule = classRule(classNameConst.SUMMARY_AREA).bg(options.background).border(options.border);\n          var bodyAreaRule = classComposeRule(' .', [classNameConst.HAS_SUMMARY_TOP, classNameConst.BODY_AREA]).border(options.border);\n          return builder.buildAll([contentAreaRule, bodyAreaRule]);\n        },\n\n        /**\n         * Generates a css string for table cells.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cell: function cell(options) {\n          return classRule(classNameConst.CELL).bg(options.background).border(options.border).borderWidth(options).text(options.text).build();\n        },\n\n        /*\n         * Generates a css string for head cells.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cellHead: function cellHead(options) {\n          var tableRule = classComposeRule(' .', [classNameConst.SHOW_LSIDE_AREA, classNameConst.LSIDE_AREA, classNameConst.HEAD_AREA, classNameConst.TABLE]).verticalBorderStyle(options, 'right');\n          var cellRule = classRule(classNameConst.CELL_HEAD).bg(options.background).border(options.border).borderWidth(options).text(options.text);\n          return builder.buildAll([tableRule, cellRule]);\n        },\n\n        /*\n         * Generates a css string for row's head cells.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cellRowHead: function cellRowHead(options) {\n          var tableRule = classComposeRule(' .', [classNameConst.SHOW_LSIDE_AREA, classNameConst.LSIDE_AREA, classNameConst.BODY_AREA, classNameConst.TABLE]).verticalBorderStyle(options, 'right');\n          var cellRule = classRule(classNameConst.CELL_ROW_HEAD).bg(options.background).border(options.border).borderWidth(options).text(options.text);\n          return builder.buildAll([tableRule, cellRule]);\n        },\n\n        /*\n         * Generates a css string for summary cells.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cellSummary: function cellSummary(options) {\n          var tableRule = classComposeRule(' .', [classNameConst.SHOW_LSIDE_AREA, classNameConst.LSIDE_AREA, classNameConst.SUMMARY_AREA, classNameConst.TABLE]).verticalBorderStyle(options, 'right');\n          var cellRule = classRule(classNameConst.CELL_SUMMARY).bg(options.background).border(options.border).borderWidth(options).text(options.text);\n          return builder.buildAll([tableRule, cellRule]);\n        },\n\n        /**\n         * Generates a css string for the cells in even rows.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cellEvenRow: function cellEvenRow(options) {\n          return classComposeRule('>', [classNameConst.ROW_EVEN, 'td']).bg(options.background).build();\n        },\n\n        /**\n         * Generates a css string for the cells in odd rows.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cellOddRow: function cellOddRow(options) {\n          return classComposeRule('>', [classNameConst.ROW_ODD, 'td']).bg(options.background).build();\n        },\n\n        /**\n         * Generates a css string for selected head cells.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cellSelectedHead: function cellSelectedHead(options) {\n          return classComposeRule('.', [classNameConst.CELL_HEAD, classNameConst.CELL_SELECTED]).bg(options.background).text(options.text).build();\n        },\n\n        /**\n         * Generates a css string for selected row head cells.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cellSelectedRowHead: function cellSelectedRowHead(options) {\n          return classComposeRule('.', [classNameConst.CELL_ROW_HEAD, classNameConst.CELL_SELECTED]).bg(options.background).text(options.text).build();\n        },\n\n        /**\n         * Generates a css string for focused cell.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cellFocused: function cellFocused(options) {\n          var focusLayerRule = classRule(classNameConst.LAYER_FOCUS_BORDER).bg(options.border);\n          var editingLayerRule = classRule(classNameConst.LAYER_EDITING).border(options.border);\n          return builder.buildAll([focusLayerRule, editingLayerRule]);\n        },\n\n        /**\n         * Generates a css string for focus inactive cell.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cellFocusedInactive: function cellFocusedInactive(options) {\n          return classComposeRule(' .', [classNameConst.LAYER_FOCUS_DEACTIVE, classNameConst.LAYER_FOCUS_BORDER]).bg(options.border).build();\n        },\n\n        /**\n         * Generates a css string for editable cells.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cellEditable: function cellEditable(options) {\n          return bgTextRuleString(classNameConst.CELL_EDITABLE, options);\n        },\n\n        /**\n         * Generates a css string for required cells.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cellRequired: function cellRequired(options) {\n          return bgTextRuleString(classNameConst.CELL_REQUIRED, options);\n        },\n\n        /**\n         * Generates a css string for disabled cells.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cellDisabled: function cellDisabled(options) {\n          return bgTextRuleString(classNameConst.CELL_DISABLED, options);\n        },\n\n        /**\n         * Generates a css string for dummy cells.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cellDummy: function cellDummy(options) {\n          return bgTextRuleString(classNameConst.CELL_DUMMY, options);\n        },\n\n        /**\n         * Generates a css string for invalid cells.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cellInvalid: function cellInvalid(options) {\n          return bgTextRuleString(classNameConst.CELL_INVALID, options);\n        },\n\n        /**\n         * Generates a css string for cells in a current row.\n         * @param {Object} options - options\n         * @returns {String}\n         */\n        cellCurrentRow: function cellCurrentRow(options) {\n          return bgTextRuleString(classNameConst.CELL_CURRENT_ROW, options);\n        }\n      };\n      /***/\n    },\n    /* 79 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n      * @fileoverview CSS Rule string builder\n      * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n      */\n      'use strict';\n\n      var _ = __webpack_require__(2);\n\n      var snippet = __webpack_require__(3);\n      /**\n       * create css rule string and returns it\n       * @module {theme/cssBuilder}\n       * @param {String} selector - css selector\n       * @param {String} property - css property\n       * @param {String} value - css value\n       * @ignore\n       */\n\n\n      var CSSRuleBuilder = snippet.defineClass({\n        init: function init(selector) {\n          if (!_.isString(selector) || !selector) {\n            throw new Error('The Selector must be a string and not be empty.');\n          }\n\n          this._selector = selector;\n          this._propValues = [];\n        },\n\n        /**\n         * Add a set of css property and value.\n         * @param {String} property - css property\n         * @param {String} value - css value\n         * @returns {CSSRuleBuilder}\n         */\n        add: function add(property, value) {\n          if (value) {\n            this._propValues.push(property + ':' + value);\n          }\n\n          return this;\n        },\n\n        /**\n         * Shortcut for add('border-color', value)\n         * @param {String} value - css value\n         * @returns {CSSRuleBuilder}\n         */\n        border: function border(value) {\n          return this.add('border-color', value);\n        },\n\n        /**\n         * Add a border-width style to the rule.\n         * @param {Object} options - visible options\n         * @param {Boolean} [options.showVerticalBorder] - whether the vertical border is visible\n         * @param {Boolean} [options.showHorizontalBorder] - whether the horizontal border is visible\n         * @returns {CSSRuleBuilder}\n         */\n        borderWidth: function borderWidth(options) {\n          var vertical = options.showVerticalBorder;\n          var horizontal = options.showHorizontalBorder;\n          var value;\n\n          if (_.isBoolean(vertical)) {\n            value = vertical ? '1px' : '0';\n            this.add('border-left-width', value).add('border-right-width', value);\n          }\n\n          if (_.isBoolean(horizontal)) {\n            value = horizontal ? '1px' : '0';\n            this.add('border-top-width', value).add('border-bottom-width', value);\n          }\n\n          return this;\n        },\n\n        /**\n         * Add a vertical border style to the rule.\n         * @param {Object} options - visible options\n         * @param {Boolean} [options.showVerticalBorder] - whether the vertical border is visible\n         * @param {String} position - Position of the vertical border ('right' or 'left')\n         * @returns {CSSRuleBuilder}\n         */\n        verticalBorderStyle: function verticalBorderStyle(options, position) {\n          var vertical = options.showVerticalBorder;\n          var value;\n\n          if (_.isBoolean(vertical) && position) {\n            value = vertical ? 'solid' : 'hidden';\n            this.add('border-' + position + '-style', value);\n          }\n\n          return this;\n        },\n\n        /**\n         * Shortcut for add('background-color', value)\n         * @param {String} value - css value\n         * @returns {CSSRuleBuilder}\n         */\n        bg: function bg(value) {\n          return this.add('background-color', value);\n        },\n\n        /**\n         * Shortcut for add('color', value)\n         * @param {String} value - css value\n         * @returns {CSSRuleBuilder}\n         */\n        text: function text(value) {\n          return this.add('color', value);\n        },\n\n        /**\n         * Create a CSS rule string with a selector and prop-values.\n         * @returns {String}\n         */\n        build: function build() {\n          var result = '';\n\n          if (this._propValues.length) {\n            result = this._selector + '{' + this._propValues.join(';') + '}';\n          }\n\n          return result;\n        }\n      });\n      module.exports = {\n        /**\n         * Creates new Builder instance.\n         * @param {String} selector - selector\n         * @returns {CSSRuleBuilder}\n         */\n        create: function create(selector) {\n          return new CSSRuleBuilder(selector);\n        },\n\n        /**\n         * Creates a new Builder instance with a class name selector.\n         * @param {String} className - class name\n         * @returns {Builder}\n         */\n        createClassRule: function createClassRule(className) {\n          return this.create('.' + className);\n        },\n\n        /**\n         * Creates a new Builder instance with a composed class name.\n         * @param {String} selector - selector to compose class names\n         * @param {Array} classNames - class name list\n         * @returns {Builder}\n         */\n        createClassComposeRule: function createClassComposeRule(selector, classNames) {\n          return this.create('.' + classNames.join(selector));\n        },\n\n        /**\n         * Creates an array of new Builder instances for the -webkit-scrollbar styles.\n         * @param {String} selector - selector\n         * @param {Object} options - options\n         * @returns {Array.<CSSRuleBuilder>}\n         */\n        createWebkitScrollbarRules: function createWebkitScrollbarRules(selector, options) {\n          return [this.create(selector + ' ::-webkit-scrollbar').bg(options.background), this.create(selector + ' ::-webkit-scrollbar-thumb').bg(options.thumb), this.create(selector + ' ::-webkit-scrollbar-thumb:hover').bg(options.active)];\n        },\n\n        /**\n         * Creates a builder instance for the IE scrollbar styles.\n         * @param {String} selector - selector\n         * @param {Object} options - options\n         * @returns {Array.<CSSRuleBuilder>}\n         */\n        createIEScrollbarRule: function createIEScrollbarRule(selector, options) {\n          var bgProps = ['scrollbar-3dlight-color', 'scrollbar-darkshadow-color', 'scrollbar-track-color', 'scrollbar-shadow-color'];\n          var thumbProps = ['scrollbar-face-color', 'scrollbar-highlight-color'];\n          var ieScrollbarRule = this.create(selector);\n\n          _.each(bgProps, function (prop) {\n            ieScrollbarRule.add(prop, options.background);\n          });\n\n          _.each(thumbProps, function (prop) {\n            ieScrollbarRule.add(prop, options.thumb);\n          });\n\n          ieScrollbarRule.add('scrollbar-arrow-color', options.active);\n          return ieScrollbarRule;\n        },\n\n        /**\n         * Build all rules and returns the concatenated string.\n         * @param {Array.<Rule>} rules - rule builders\n         * @returns {String}\n         */\n        buildAll: function buildAll(rules) {\n          return _.map(rules, function (rule) {\n            return rule.build();\n          }).join('');\n        }\n      };\n      /***/\n    },\n    /* 80 */\n\n    /***/\n    function (module, exports) {\n      /**\n      * @fileoverview default theme preset\n      * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n      */\n      'use strict';\n\n      module.exports = {\n        selection: {\n          background: '#00A9ff',\n          border: '#00a9ff'\n        },\n        heightResizeHandle: {\n          border: '#fff',\n          background: '#fff'\n        },\n        pagination: {\n          border: 'transparent',\n          background: 'transparent'\n        },\n        scrollbar: {\n          border: '#eee',\n          background: '#fff',\n          emptySpace: '#f9f9f9',\n          thumb: '#ddd',\n          active: '#ddd'\n        },\n        outline: {\n          border: '#aaa',\n          showVerticalBorder: false\n        },\n        frozenBorder: {\n          border: '#aaa'\n        },\n        area: {\n          header: {\n            border: '#ccc',\n            background: '#fff'\n          },\n          body: {\n            background: '#fff'\n          },\n          summary: {\n            border: '#eee',\n            background: '#fff'\n          }\n        },\n        cell: {\n          normal: {\n            background: '#f4f4f4',\n            border: '#eee',\n            text: '#333',\n            showVerticalBorder: false,\n            showHorizontalBorder: true\n          },\n          head: {\n            background: '#fff',\n            border: '#eee',\n            text: '#222',\n            showVerticalBorder: true,\n            showHorizontalBorder: true\n          },\n          rowHead: {\n            background: '#fff',\n            border: '#eee',\n            text: '#333',\n            showVerticalBorder: false,\n            showHorizontalBorder: true\n          },\n          summary: {\n            background: '#fff',\n            border: '#eee',\n            text: '#333',\n            showVerticalBorder: false\n          },\n          selectedHead: {\n            background: '#e5f6ff'\n          },\n          selectedRowHead: {\n            background: '#e5f6ff'\n          },\n          focused: {\n            border: '#00a9ff'\n          },\n          focusedInactive: {\n            border: '#aaa'\n          },\n          required: {\n            background: '#fffdeb'\n          },\n          editable: {\n            background: '#fff'\n          },\n          disabled: {\n            background: '#f9f9f9',\n            text: '#c1c1c1'\n          },\n          dummy: {\n            background: '#fff'\n          },\n          invalid: {\n            background: '#ffe5e5'\n          },\n          evenRow: {},\n          oddRow: {},\n          currentRow: {}\n        }\n      };\n      /***/\n    },\n    /* 81 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n      * @fileoverview default theme preset\n      * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n      */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var presetDefault = __webpack_require__(80);\n\n      module.exports = $.extend(true, {}, presetDefault, {\n        outline: {\n          border: '#eee',\n          showVerticalBorder: false\n        },\n        frozenBorder: {\n          border: '#ccc'\n        },\n        area: {\n          header: {\n            border: '#fff',\n            background: '#eee'\n          },\n          body: {\n            background: '#fff'\n          },\n          summary: {\n            border: '#fff',\n            background: '#fff'\n          }\n        },\n        cell: {\n          normal: {\n            background: '#fff',\n            border: '#fff',\n            showVerticalBorder: false,\n            showHorizontalBorder: false\n          },\n          head: {\n            background: '#eee',\n            border: '#fff',\n            showVerticalBorder: true,\n            showHorizontalBorder: true\n          },\n          rowHead: {\n            border: '#fff',\n            showVerticalBorder: false,\n            showHorizontalBorder: false\n          },\n          oddRow: {\n            background: '#fff'\n          },\n          evenRow: {\n            background: '#f4f4f4'\n          }\n        }\n      });\n      /***/\n    },\n    /* 82 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n      * @fileoverview default theme preset\n      * @author NHN. FE Development Lab <dl_javascript@nhn.com>\n      */\n      'use strict';\n\n      var $ = __webpack_require__(7);\n\n      var presetDefault = __webpack_require__(80);\n\n      module.exports = $.extend(true, {}, presetDefault, {\n        outline: {\n          border: '#eee',\n          showVerticalBorder: false\n        },\n        frozenBorder: {\n          border: '#ddd'\n        },\n        area: {\n          header: {\n            border: '#eee',\n            background: '#f9f9f9'\n          },\n          body: {\n            background: '#fff'\n          },\n          summary: {\n            border: '#fff',\n            background: '#fff'\n          }\n        },\n        cell: {\n          normal: {\n            background: '#fff',\n            border: '#eee',\n            showVerticalBorder: false,\n            showHorizontalBorder: false\n          },\n          head: {\n            background: '#f9f9f9',\n            border: '#eee',\n            showVerticalBorder: true,\n            showHorizontalBorder: true\n          },\n          rowHead: {\n            border: '#eee',\n            showVerticalBorder: false,\n            showHorizontalBorder: false\n          }\n        }\n      });\n      /***/\n    },\n    /* 83 */\n\n    /***/\n    function (module, exports) {// removed by extract-text-webpack-plugin\n\n      /***/\n    }])\n  );\n});\n\n;","map":null,"metadata":{},"sourceType":"script"}